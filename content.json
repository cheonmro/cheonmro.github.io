{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"Cheon","url":"https://cheonmro.github.io"},"pages":[{"title":"about","date":"2018-08-28T11:57:15.000Z","updated":"2018-08-28T12:09:35.162Z","comments":true,"path":"about/index.html","permalink":"https://cheonmro.github.io/about/index.html","excerpt":"","text":"Introduction"},{"title":"categories","date":"2018-08-28T12:01:37.000Z","updated":"2018-08-28T12:02:33.051Z","comments":true,"path":"categories/index.html","permalink":"https://cheonmro.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-08-28T12:03:36.000Z","updated":"2018-08-28T12:03:49.565Z","comments":true,"path":"tags/index.html","permalink":"https://cheonmro.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"REST API란 무엇인가?","slug":"rest-api","date":"2018-08-30T04:06:44.000Z","updated":"2018-08-30T04:06:44.265Z","comments":true,"path":"2018/08/30/rest-api/","link":"","permalink":"https://cheonmro.github.io/2018/08/30/rest-api/","excerpt":"","text":"REST API란? REpresentational State Transfer의 약자로, 서버의 자원을 정의하고, 자원에 대한 주소를 지정하는 방법(표기법)을 말한다. 2000년, 아파치 HTTP 서버 프로젝트의 공동설립자인 Roy fielding(로이 필딩)에 의해 처음 소개가 되었는데, 이 분은 HTTP/1.0,1.1 스펙 작성에 참여하신 분이다. 그는 웹의 장점을 최대한 활용할 수 있는 Architecture로써 REST를 소개하면서, REST API 규칙을 만들었다. 이런 REST API 규칙을 잘 지킨 서비스 디자인을 “RESTful”하다고 표현한다. REST API는 HTPP 프로토콜을 정확히 의도에 맞게 활용하여 디자인하게 유도하기 때문에, 디자인 기준이 명확해지고, 의미적인 범용성을 지닌다. 즉, 서버가 이해하기 쉽게 자원에 대한 주소를 지정하는 표기법이 REST API이다. REST API 구성 요소 REST API를 구성하는 것은 다음과 같이 3가지가 있다. 자원(Resource) 행위(Verb) 표현(Representation) 자원(Resource) 자원(Resource)이란, 해당 소프트웨어가 관리하는 모든 것이 될 수 있다.JSON, XML 등의 문서가 될 수 있고, 그림파일이 될 수도 있다.즉, 어떤 데이터(문서, 파일, 비디오 등)를 말한다. 예를 들어, 서버 데이터베이스에 사용자들에 대한 정보가 들어가 있다면, 이 사용자들의 정보가 데이터이기 때문에, 자원(Resource)이 된다. 이때, 이 사용자들에 대한 데이터를 대표하는 이름을 users라고 해보자. 만약, 이 사용자들 중에서 어떤 한 명의 사용자에 대한 자원을 얻고자 한다면 어떻게 해야할까? 그럴때는, users/id 처럼, 사용자들 중 특정 id로 사용자를 구분해서 사용할 수 있다. 자원(Resource)은 HTTP URI로 표현한다. 예를 들어, http://localhost:4000/users/1 이런식으로 작성하며, 이 URI를 이용하여 원하는 자원(Resource)에 접근할 수 있다. 행위(Verb) REST API에서 말하는 행위(Verb)는 자원에 대한 행위를 말한다. 즉, HTTP Method를 사용해서 자원을 얻거나, 만들거나, 변경하거나, 삭제하는 등의 행위를 할 수 있다. HTTP Method 중 대표적으로 자주 사용되는 메서드는 다음과 같다. GET : 서버 자원을 가져오고자 할 때 사용한다.(Retrieve: 모든/특정 자원을 조회) POST : 서버에 자원을 새로 등록하고자 할 때 사용한다.(Create: 자원을 생성) PUT : 서버의 자원을 새로 요청한 자원으로 변경하고자 할 때 사용한다.(Update: 자원을 갱신) PATCH : 서버 자원의 일부만 수정하고자 할 때 사용한다. DELETE : 서버의 자원을 삭제하고자 할 때 사용한다.(Delete: 자원을 삭제) 위 4가지(GET/POST/PUT/DELETE)를 이용해서 CRUD를 구현할 수 있다. 표현(Representation) 표현(Representation)은 자원에 대한 행위의 내용을 말하는데, 이때 내용은 서버에 요청할 때 무엇인가를 새로 생성하거나, 변경할 때 필요한 내용을 말한다. 이때, HTTP Message인 payload를 사용한다. 서버 자원에 무언가 새로운 것을 생성할 때, HTTP Method 중 POST와 함께 payload를 같이 요청한다. 예를 들어, 사용자들에 대한 정보가 있는 users에 새로운 사용자 정보를 생성하고 싶다면, 이 새로운 사용자에 대한 정보를 새로 만들어서 추가해줘야 하는데, 이것을 payload라고 한다. 1234567POST http://localhost:4000/users/&#123; &quot;id&quot;: 1, &quot;name: &quot;Ro&quot;, &quot;country&quot;: &quot;Korea&quot;&#125; 위 객체를 payload라고 하는데, 위 자원(http://localhost:4000/users/) 에 POST 방식으로 위 payload(객체)와 함께 서버에 요청을 해야한다. REST API 중심 규칙 위와 같은 내용을 잘 정리한 것이 REST API 중심 규칙이다.REST한 API를 설계하기 위한 중심 규칙은 대표적으로 2가지이다. 1. URI는 정보의 자원을 표현해야 한다. URI는 정보의 자원을 표현하는데 중점을 두어야 하기 때문에, 어떤 행위를 나타내는 동사보다는 자원의 의미를 명확히 전달하기 위해 명사를 사용해야 한다. id가 1인 사용자에 대한 자원을 얻고 싶다면, 다음과 같이 작성해야 한다. 1GET /users/1 행위를 나타내는 다음과 같은 URI는 잘못된 방법이다. 12GET /getUsers/1GET /users/show/1 2. 자원에 대한 행위는 HTTP Method로 표현한다. 1DELETE /users/1 REST API Architecture REST API는 자원과 메서드만 보고 요청의 내용을 명확하게 알 수 있다는 것이 장점이다. 이런 REST API의 Architecture를 보면 다음과 같다. 출처: REST API Architecture 어떤 클라이언트(웹브라우저/안드로이드 앱/ios 앱)에서 서버에 요청을 할 때 HTTP 통신을 하고, HTTP Method를 사용하여 원하는 행위를 하여 서버로부터 응답을 받는다. REST API 사용 예제 Ajax를 사용하여 REST API를 어떻게 사용하는지 알아보자. 사용자에 대한 정보인 users 데이터는 다음과 같다고 해보자. 123456789101112131415161718192021222324&#123; &quot;users&quot;: [ &#123; &quot;id&quot;: 1, &quot;name&quot;: &quot;Ro&quot;, &quot;country&quot;: &quot;Korea&quot; &#125;, &#123; &quot;id&quot;: 2, &quot;name&quot;: &quot;John&quot;, &quot;country&quot;: &quot;Canada&quot; &#125;, &#123; &quot;id&quot;: 3, &quot;name&quot;: &quot;Doh&quot;, &quot;country&quot;: &quot;China&quot; &#125;, &#123; &quot;id&quot;: 4, &quot;name&quot;: &quot;Hitaro&quot;, &quot;country&quot;: &quot;Japan&quot; &#125; ]&#125; 1. GET 1-1. users 자원에서 모든 사용자의 정보를 가져온다.(모든 사용자)1GET http://localhost:4000/users 위와 같이 users에 대한 자원을 GET하게 되면 다음과 같이 모든 users에 대한 정보를 가져올 수 있다. 12345678910111213141516171819202122[ &#123; &quot;id&quot;: 1, &quot;name&quot;: &quot;Ro&quot;, &quot;country&quot;: &quot;Korea&quot; &#125;, &#123; &quot;id&quot;: 2, &quot;name&quot;: &quot;John&quot;, &quot;country&quot;: &quot;Canada&quot; &#125;, &#123; &quot;id&quot;: 3, &quot;name&quot;: &quot;Doh&quot;, &quot;country&quot;: &quot;China&quot; &#125;, &#123; &quot;id&quot;: 4, &quot;name&quot;: &quot;Hitaro&quot;, &quot;country&quot;: &quot;Japan&quot; &#125; ] 이것을 코드로 작성하면 다음과 같다. 12345678910111213var req = new XMLHttpRequest();req.open(&apos;GET&apos;, &apos;http://localhost:4000/users&apos;);req.send();req.onreadystatechange = function (e) &#123; if (req.readyState === XMLHttpRequest.DONE) &#123; if(req.status === 200) &#123; console.log(req.responseText); &#125; else &#123; console.log(&quot;Error!&quot;); &#125; &#125;&#125;; 1-2. users 자원에서 id가 1인 사용자의 정보를 가져온다.(특정 사용자)1GET http://localhost:4000/users/1 위와 같이 users 자원에서 id가 1인 사용자에 대한 자원을 GET하게 되면 다음과 같이 id가 1인 사용자에 대한 정보를 가져올 수 있다. 12345&#123; &quot;id&quot;: 1, &quot;name&quot;: &quot;Ro&quot;, &quot;country&quot;: &quot;Korea&quot;&#125; 이것을 코드로 작성하면 다음과 같다. 12345678910111213var req = new XMLHttpRequest();req.open(&apos;GET&apos;, &apos;http://localhost:4000/users/1&apos;);req.send();req.onreadystatechange = function (e) &#123; if (req.readyState === XMLHttpRequest.DONE) &#123; if(req.status === 200) &#123; console.log(req.responseText); &#125; else &#123; console.log(&quot;Error!&quot;); &#125; &#125;&#125;; 2. POSTusers 자원에 새로운 사용자의 정보를 생성한다.123POST http://localhost:4000/users&quot;Content-Type: application/json&quot;&apos;&#123;&quot;name&quot;: &quot;donald&quot;, &quot;country&quot;: &quot;United States&quot;&#125;&apos; 새로운 사용자의 정보를 생성하기 위해서는 payload가 필요하며, 위와 같이 Content-Type 등을 추가로 작성해야 한다. 12345&#123; &quot;name&quot;: &quot;donald&quot;, &quot;country&quot;: &quot;United States&quot;, &quot;id&quot;: 5&#125; 이것을 코드로 작성하면 다음과 같다. 1234567891011121314151617var req = new XMLHttpRequest();req.open(&apos;POST&apos;, &apos;http://localhost:4000/users&apos;);req.setRequestHeader(&apos;Content-type&apos;, &apos;application/json&apos;);req.send(JSON.stringify(&#123; name: &quot;donald&quot;, country: &quot;United States&quot;&#125;));req.onreadystatechange = function (e) &#123; if (req.readyState === XMLHttpRequest.DONE) &#123; if(req.status === 201) &#123; console.log(req.responseText); &#125; else &#123; console.log(&quot;Error!&quot;); &#125; &#125;&#125;; 3. PUTusers 자원에서 새로 추가된 name을 jack으로 변경한다.123PUT http://localhost:4000/users/5&quot;Content-Type: application/json&quot;&apos;&#123;&quot;name&quot;: &quot;jack&quot;, &quot;country&quot;: &quot;United States&quot;&#125;&apos; PUT은 특정 id에 대한 어떤 정보를 변경할 때, payload에 모든 정보를 포함해서 보내준다. 12345&#123; &quot;name&quot;: &quot;jack&quot;, &quot;country&quot;: &quot;United States&quot;, &quot;id&quot;: 5&#125; 이것을 코드로 작성하면 다음과 같다. 1234567891011121314151617var req = new XMLHttpRequest();req.open(&apos;PUT&apos;, &apos;http://localhost:4000/users/5&apos;);req.setRequestHeader(&apos;Content-type&apos;, &apos;application/json&apos;);req.send(JSON.stringify(&#123; name: &apos;jack&apos;, country: &quot;United States&quot;&#125;));req.onreadystatechange = function (e) &#123; if (req.readyState === XMLHttpRequest.DONE) &#123; if(req.status === 200) &#123; console.log(req.responseText); &#125; else &#123; console.log(&quot;Error!&quot;); &#125; &#125;&#125;; 4. DELETEusers 자원에서 id가 5인 사용자를 삭제한다.1DELETE http://localhost:4000/users/5 사용자의 id까지 포함해서 DELETE 해야한다. 1&#123;&#125; 이것을 코드로 작성하면 다음과 같다. 12345678910111213var req = new XMLHttpRequest();req.open(&apos;DELETE&apos;, &apos;http://localhost:4000/users/5&apos;);req.send();req.onreadystatechange = function (e) &#123; if (req.readyState === XMLHttpRequest.DONE) &#123; if(req.status === 200) &#123; console.log(req.responseText); &#125; else &#123; console.log(&quot;Error!&quot;); &#125; &#125;&#125;;","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://cheonmro.github.io/categories/Javascript/"}],"tags":[{"name":"REST API","slug":"REST-API","permalink":"https://cheonmro.github.io/tags/REST-API/"}]},{"title":"트랜스파일링을 위한 typescript 개발환경 구축 방법","slug":"typescript-compiler","date":"2018-08-08T06:19:55.000Z","updated":"2018-08-08T06:19:55.741Z","comments":true,"path":"2018/08/08/typescript-compiler/","link":"","permalink":"https://cheonmro.github.io/2018/08/08/typescript-compiler/","excerpt":"","text":"Typescript와 트랜스파일링 자바스크립트의 문제점을 보완하기 위해 typescript을 사용한다. 그러나, typescript으로 작성한 파일은 브라우저에서 동작하지 않는다. 따라서, typescript로 작성한 파일을 자바스크립트로 변환해야 하는데, 이를 트랜스파일링 또는 컴파일이라고 한다. 트랜스파일링을 하기 위해서는 typescript 컴파일러를 설치하여 사용하는 typescript 개발환경을 구축해야한다. typescript 컴파일러 설치 방법 다음과 같이 typescript를 전역에 설치한다.1npm install -g typescript 설치가 완료되면, typescript의 버전 체크를 하여, typescript 컴파일러 설치가 제대로 되었는지 확인한다.1tsc -v typescript 컴파일러로 트랜스파일링 하기 typescript로 작성된 파일(.ts)을 자바스크립트 파일로 트랜스파일링 하기 위해서는, 위에서 설치한 typescript 컴파일러(tsc)를 사용한다. 1개의 파일 트랜스파일링 하기 아래의 코드를 작성하고, 확장자를 .ts로 하는 typescript 파일로 만든다.1234567891011121314class Cafe &#123; private name: string; constructor(name: string) &#123; this.name = name; &#125; greeting() &#123; return &quot;Welcome to&quot; + this.name; &#125;&#125;const cafe = new Cafe(&apos;Starbucks&apos;);console.log(cafe.greeting()); 위 typescript 파일을 트랜스파일링하여 자바스크립트로 만들기 위해서는 아래의 명령어를 작성하면 된다.1tsc cafe tsc 다음에 위 파일(cafe.ts)의 이름(cafe)을 입력하면 된다. 그러면, 트랜스파일링이 되어, 또 하나의 자바스크립트 파일이 생성된다.1234567891011121314&quot;use strict&quot;;exports.__esModule = true;var Cafe = /** @class */ (function () &#123; function Cafe(name) &#123; this.name = name; &#125; Cafe.prototype.greeting = function () &#123; return &quot;Welcome to&quot; + this.name; &#125;; return Cafe;&#125;());exports.Cafe = Cafe;var cafe = new Cafe(&apos;Starbucks&apos;);console.log(cafe.greeting()); 그런데, 트랜스파일링된 자바스크립트 파일은 ES3 버전으로 생성되는데, 이는 트랜스파일링해서 생성되는 기본 버전이 ES3이기 때문이다. target 컴파일 옵션을 사용해서 원하는 버전으로 트랜스파일링 하기 만약 원하는 버전으로 트랜스파일링 하고 싶다면, typescript 컴파일 옵션중 –target또는 -t를 사용하면 된다.1tsc cafe -t es6 ES6 버전은 아래와 같이 나온다.12345678910class Cafe &#123; constructor(name) &#123; this.name = name; &#125; greeting() &#123; return &quot;Welcome to&quot; + this.name; &#125;&#125;const cafe = new Cafe(&apos;Starbucks&apos;);console.log(cafe.greeting()); 그러면, 처음에 생성된 ES3 버전의 자바스크립트 파일이 ES6 버전의 자바스크립트 파일로 코드의 내용이 변경된다. 2개의 파일 트랜스파일링 하기 2개의 typescript 파일을 작성하여, 트랜스파일링을 해보자.123456789101112131415// cafe.tsexport class Cafe &#123; protected name: string; constructor(name: string) &#123; this.name = name; &#125; greeting() &#123; return &quot;Welcome to&quot; + this.name; &#125;&#125;const cafe = new Cafe(&apos;Starbucks&apos;);console.log(cafe.greeting()); 123456789101112// bakery.tsimport &#123; Cafe &#125; from &apos;./cafe&apos;;class Bakery extends Cafe &#123; bake(): string &#123; return `$&#123;this.name&#125; is baking bread. Wow!!`; &#125;&#125;const bakery = new Bakery(&apos;Starbucks&apos;);console.log(bakery.greeting());console.log(bakery.bake()); 위 두개의 typescript 파일들을 트랜스파일링 하기 위한 명령어를 작성하면 된다.1tsc cafe bakery 그러면, 두개의 typescript 파일들이 두개의 자바스크립트 파일로 트랜스파일링 된다. 3개 이상의 파일 트랜스파일링 하기 3개 이상의 모든 typescript 파일들을 한번에 트랜스파일링 하기위해서는 와일드카드(*)를 사용해야 한다.1tsc *.ts 자동으로 트랜스파일링 하기 typescript 컴파일 옵션 중 —watch 또는 -w 를 사용하면, 파일의 내용이 변경되었을 때, 이를 감지하여 자동으로 그 파일이 트랜스파일링 된다.1tsc bakery —watch","categories":[{"name":"typescript","slug":"typescript","permalink":"https://cheonmro.github.io/categories/typescript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://cheonmro.github.io/tags/typescript/"},{"name":"typescript compiler","slug":"typescript-compiler","permalink":"https://cheonmro.github.io/tags/typescript-compiler/"}]},{"title":"typescript란 무엇인가?","slug":"what-is-typescript","date":"2018-08-07T13:36:53.000Z","updated":"2018-08-28T11:45:51.125Z","comments":true,"path":"2018/08/07/what-is-typescript/","link":"","permalink":"https://cheonmro.github.io/2018/08/07/what-is-typescript/","excerpt":"","text":"typescript란 무엇인가? typescript는 자바스크립트에서 좀 더 확장된 언어로, 자바스크립트의 문법을 포함하면서 자바스크립트가 가지고 있는 문제를 보완하기 위한 문법을 가진 언어이다. 2012년에 마이크로소프트에서 발표한 오픈소스로써, C#을 개발한 아네르스 하일스베르가 개발하였다. 위 그림과 같이, 타입스크립트는 ES5, ES6를 모두 포함하는 자바스크립트의 상위집합이기 때문에, 타입스크립트에서 기존의 자바스크립트 문법을 그대로 사용할 수 있다. 또한, 타입스크립트는 아직 ECMAScript 표준에 포함되지는 않았지만(2018년 7월 기준), ECMAScript의 업그레이드에 따른 새로운 기능(스펙)을 계속 추가하기 때문에, ECMAScript의 표준을 따라가는 것처럼 보인다. typescript를 왜 사용할까? C나 JAVA와 같은 C-family 언어와는 다른 자바스크립트만의 특성이 있다. 프로토타입 기반 객체지향 언어 스코프와 this 동적 타입 언어 이와 같은 특성들은 클래스 기반 객체지향 언어(C, JAVA 등)에 익숙한 개발자에게는 혼란스럽다.또한, 할당하는 값에 따라 타입이 바뀌는 문제도 있어, 꼭 타입 체크를 해줘야 하는 점도 있다. 이런 문제들을 보완하기 위해, 타입스크립트에는 클래스, 정적 타이핑 등이 포함되어있다. 자바스크립트의 프레임워크인 Angular는 주력 언어로 타입스크립트를 채용했기 때문에, Angular를 사용하는 개발자는 타입스크립트를 이해하는 것이 필수적이다. 즉, Angular는 타입스크립트 뿐만 아니라, 자바스크립트, Dart 등으로도 작성이 가능하지만, Angular 사이트에 나와있는 문서나 커뮤니티 활동에서도 가장 많이 사용되고 있어, Angular를 사용하고 싶다면 타입스크립트를 아는 것이 좋다.","categories":[{"name":"typescript","slug":"typescript","permalink":"https://cheonmro.github.io/categories/typescript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://cheonmro.github.io/tags/typescript/"}]},{"title":"hexo 블로그 포스트 작성 및 배포하는 방법","slug":"how-to-write-posts","date":"2018-08-05T15:37:33.000Z","updated":"2018-08-05T15:37:33.768Z","comments":true,"path":"2018/08/06/how-to-write-posts/","link":"","permalink":"https://cheonmro.github.io/2018/08/06/how-to-write-posts/","excerpt":"","text":"hexo 블로그에 포스트 작성 및 배포하는 방법 새 포스트 작성을 위한 글제목 명령어를 입력한다. 1hexo new option 글제목 이 명령어를 작성하게 되면, 글제목 폴더와 글제목.md 파일이 만들어진다.이미지는 글제목 폴더에서 관리하고, 글의 내용은 글제목.md 파일에서 관리한다.만약, 글제목 폴더가 만들어지지 않는다면, _config.yml에서 post_asset_folder: true를 추가하면 된다. 이때, option에는 ‘post’ 또는 ‘draft’가 올 수 있다. 만약 작성한 글을 바로 배포하려면 ‘post’라고 쓴다.1hexo new post 글제목 바로 배포하지 않고, 초안으로 보관만 하려고 할 때는 ‘draft’라고 쓴다.1hexo new draft 글제목 draft 글을 배포하기 위해서 _posts 폴더로 이동시킨다. ‘draft’를 사용하여 명령어를 입력하게 되면, source/_drafts 폴더에 저장된다.이 폴더에 저장이 되면, 배포 대상에서 제외되기 때문에, 원래 사용하던 ‘hexo server’로는 확인할 수 없고 ‘–draft’라는 옵션을 추가해여 로컬 서버에서 확인이 가능하다.1hexo server --draft 초안이 다 완성이 되어 배포를 하고 싶을 경우, 해당 파일과 폴더가 source/_posts 폴더에 있어야 한다.이때, 아래와 같은 명령어를 입력하면 해당 파일과 폴더과 source/_posts로 이동하게 된다.1hexo publish post 글제목 _posts 폴더에 있는 글을 블로그에 배포한다. 최종적으로, source/_posts안에 있는 모든 글들을 배포하기 위해 아래의 명령어를 입력한다.1hexo generate --deploy","categories":[{"name":"hexo","slug":"hexo","permalink":"https://cheonmro.github.io/categories/hexo/"}],"tags":[{"name":"hexo posts","slug":"hexo-posts","permalink":"https://cheonmro.github.io/tags/hexo-posts/"}]},{"title":"hexo를 이용해서 블로그를 설치하는 방법","slug":"how-to-setup-hexo","date":"2018-08-05T15:24:54.000Z","updated":"2018-08-05T15:24:54.154Z","comments":true,"path":"2018/08/06/how-to-setup-hexo/","link":"","permalink":"https://cheonmro.github.io/2018/08/06/how-to-setup-hexo/","excerpt":"","text":"hexo를 이용해서 블로그 설치하기 hexo 설치하기 hexo 설치하기 위해서는 기본적으로 설치해야할 것이 2가지가 있다. Node.js Git 위 2개를 설치했다면, 먼저 npm을 사용해서 hexo를 설치해야 한다.나같은 경우에는 git을 관리하는 dev 폴더안에서 설치했다.1npm install hexo-cli -g 본인이 원하는 이름(나의 경우: myblog)으로 hexo init을 하고, npm을 설치한다.123hexo init myblogcd myblognpm install hexo 서버를 통해 구축된 hexo 기본 사이트를 확인한다.1hexo server 위와 같이 따라서 설치하면 기본적인 hexo 블로그를 로컬 호스트로 구축을 할 수 있다. Github에서 제공하는 github.io로 사이트 구축하기 hexo 블로그를 사용하기 위해서는 깃헙에서 제공하는 블로그용 깃헙사이트가 필요하다. Github에서 블로그용으로 만들 repo를 생성한다.repo를 username.github.io 이런식으로 만들면 된다. 내 컴퓨터로 클론한다.나같은 경우 dev 폴더안에서 클론했다.1git clone https://github.com/cheonmro/cheonmro.github.io.git _config.yml에서 세팅하기 실제 사이트 url로 배포하기 위해 기본적인 세팅이 필요하다.세팅 관련해서는 항상 _config.yml에서 한다. 앞으로 hexo 블로그를 이용해서 작성할 모든 내용들을, 위에서 생성한 블로그용 깃헙에서 관리를 할 것이기 때문에, 아래와 같이 type에 git으로 하고, repository에 자신의 블로그용 깃헙 주소를 작성한다.1234deploy: type: git repository: https://github.com/cheonmro/cheonmro.github.io branch: master 구축한 사이트 배포하기 지금까지 구축한 hexo 블로그를 배포(deploy)한다.1hexo deploy 위 명령어를 실행하게 되면, 자동으로 commit, push가 되어, 깃헙과 웹사이트(블로그)에 파일들이 generate되어, 기본적인 사이트 구축이 완성되게 된다.(웹사이트 자체를 배포할 때 사용한다.) 위에서 구축한 사이트를 직접 확인한다.1https://cheonmro.github.io/ hexo 블로그의 테마를 바꾸는 방법 위와 같이, 기본적인 hexo 블로그 설치는 간단한다.기본적으로 themes 폴더안에 있는 landscape 테마를 바탕으로한 기본 사이트가 구축된다. hexo 블로그에서 테마를 바꾸고 싶을 때는, 원하는 테마를 themes 안에 가져오고, _config.yml에서 theme의 이름만 바꿔주면 된다. 원하는 테마를 themes 폴더안으로 git clone 한다.(나같은 경우는 hexo-theme-hipaper 테마를 사용했다.)1git clone https://github.com/iTimeTraveler/hexo-theme-hipaper.git _config.yml에서 theme 옆에 이름을 새로 변경할 테마의 이름으로 바꾼다.1theme: hexo-theme-hipaper 기존 테마를 지우고, 새로 변경할 테마로 바꾸려면, hexo 블로그를 다시 배포(deploy)해야한다.1hexo deploy 위와같이 하면, Github의 파일들이 새로 변경할 테마의 내용들로 바뀌고, 사이트 또한 새롭게 변경된다. 만약, “Deployer not found: git” 이라는 에러가 난다면, deployer를 설치하면 된다.1npm install hexo-deployer-git --save 그리고, 다시 배포한다.1hexo deploy","categories":[{"name":"hexo","slug":"hexo","permalink":"https://cheonmro.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://cheonmro.github.io/tags/hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-08-05T13:24:49.289Z","updated":"2018-08-05T13:24:49.289Z","comments":true,"path":"2018/08/05/hello-world/","link":"","permalink":"https://cheonmro.github.io/2018/08/05/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}