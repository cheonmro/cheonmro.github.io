{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"Cheon","url":"https://cheonmro.github.io"},"pages":[{"title":"About Me","date":"2018-08-28T11:57:15.000Z","updated":"2018-10-31T09:41:42.690Z","comments":true,"path":"about/index.html","permalink":"https://cheonmro.github.io/about/index.html","excerpt":"","text":"안녕하세요, 영향력있는 개발자 노천명입니다. Email: cheonmro@gmail.com About Projects #3. Banking System DApp 프로젝트 목표: Core 뱅킹 시스템 웹서비스 DApp 개발 기간: 2018.10.15 ~ 2018.10.19 기술 스택: Javascript, HTML, CSS, Web3.js, Meteor, Solidity 협업 방식: 프론트엔드 개발자 1명과 백엔드 개발자 3명 전반적인 기획 및 smart contract 기능은 공동으로 구현 프론트엔드는 1명이 웹서비스의 전반적인 UI 기능 구현 백엔드는 3명이 서버와 Geth로 트랜잭션 관리 및 구현 나의 역할: 입금 및 출금 기능을 smart contract로 구현 웹서비스의 전반적인 UI 기능 구현 web3.js를 이용해 Ethereum 클라이언트와 연동 구현 동영상 #1. Deposit &amp; Withdrawal #2. Transfer 기능구현 1. Deposit(입금) 목표 로그인한 사용자의 계좌에 입력한 금액만큼의 토큰을 입금하는 기능 구현 접근법 클라이언트: Deposit form에서 입력한 값(계좌주소와 토큰값)과 사용자 id를 받아서 서버에 요청 서버: web3를 이용해서 배포한 컨트랙트 중 Deposit 함수를 호출하고 서버에 변경된 내용 저장 Issues &amp; Solutions #1: 클라이언트 Issue: 입력한 값들을 변수로 선언하여, 서버에 요청해야하는데, Meteor에서 서버로 요청하는 방법을 모름 Solution: Meteor에서 서버로 요청하는 방법에 대한 Document를 먼저 이해한 후, 적용하여 성공하면, alert를 띄우는 방식으로 코드를 작성 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// deposit send buttonTemplate.deposit.events(&#123; // when clicking &apos;Deposit&apos; button &quot;click button[name=send-deposit]&quot; (evt,tmpl)&#123; console.log(&apos;clicked send deposit&apos;); /* 템플릿에서 데이터 가져오기 */ var tokenAmount = tmpl.find(&quot;input[type=number]&quot;).value; document.getElementById(&quot;amountToPay&quot;).innerHTML = &apos;Amount to Pay: &apos; + &apos;$&apos; + tokenAmount + &apos; USD&apos;; &#125;, // when clicking &apos;pay&apos; button &quot;click button[name=pay-deposit]&quot; (evt,tmpl)&#123; console.log(&apos;clicked despoit pay button&apos;); var infoa = &#123; userId: Session.get(&apos;userId&apos;), address: Session.get(&apos;address&apos;), amount: tmpl.find(&quot;input[type=number]&quot;).value &#125; console.log(tmpl.find(&quot;input[type=number]&quot;).value); Meteor.call(&apos;deposit&apos;, infoa, function(error, result)&#123; if (error) &#123; console.log(error); &#125; else &#123; // hide modal $(&apos;#depositModal&apos;) .on(&apos;hidden.bs.modal&apos;, function() &#123; FlowRouter.go(&apos;/accounts&apos;); &#125;) .modal(&apos;hide&apos;); if(result) &#123; console.log(&apos;deposit success&apos;); alert(&apos;depoist was successed!&apos;); &#125; else &#123; console.log(&apos;deposit failed&apos;); alert(&apos;deposit failed&apos;); &#125; &#125; &#125;); &#125;&#125;); #2: 서버 Issue: 컨트랙트에서 정의한 Deposit 함수를 호출하는 방법을 모름. Solution: web3 Docs와 구글링을 통해 배포한 컨트랙트를 호출하는 방법을 찾아 코드를 작성 Code: 123456789101112131415161718192021222324Meteor.methods(&#123; &apos;deposit&apos; : function(infoa) &#123; var userId = infoa.userId; var address = infoa.address; var amount = infoa.amount; if(web3.personal.unlockAccount(bankAddress, bankKey) == true)&#123; if(bankContract.deposit(address, amount, &#123;from: bankAddress, gas: 3000000&#125;)) &#123; var fromAccount = Accounts.findOne(&#123;address: address&#125;); var fromBalance = fromAccount.balance; fromBalance = Number(fromBalance) + Number(amount); Accounts.update(fromAccount, &#123;$set: &#123;balance: fromBalance&#125;&#125;); return true; &#125; else return false; &#125; else return false;&#125;); 2. Modal UI 목표 입금 및 출금 기능이 작동할 때, Modal을 띄워 진행하는 기능 구현 접근법 Bootstrap Modal 코드를 사용하여 Deposit 버튼 클릭시, Modal을 띄우기 Issues &amp; Solutions Issue: Modal은 띄웠으나, Deposit 기능이 모두 수행된 후에도, 여전히 focus가 Modal에 가 있어서, 다른 화면의 기능들을 사용할 수가 없게됨. Solution: modal의 ‘hide’ 기능을 하는 코드를 추가하여, modal을 숨기게 하여, 이동된 화면에 focus가 가게함. Code: 123456// hide modal $(&apos;#depositModal&apos;) .on(&apos;hidden.bs.modal&apos;, function() &#123; FlowRouter.go(&apos;/accounts&apos;); &#125;) .modal(&apos;hide&apos;); 3. Smart Contract for Deposit &amp; Withdrawal 목표 스마트 컨트랙트의 기능 중 입금 및 출금에 대한 컨트랙트 함수 기능 구현 접근법 입금 또는 출금되는 토큰의 값이 현재 가지고 있는 토큰의 양보다 적을 경우에만 적용되는 코드를 작성 만약 위 내용이 true이면, 입금 또는 출금되는 계좌의 토큰에서 +-를 하고, 전체 계좌(운영자 계좌)에서 토큰의 양이 +-되는 방식으로 코드를 작성 Issues &amp; Solutions Issue: payable의 사용여부에 대해 불확실함 Solution: 돈을 받거나 보내는 함수를 작성할 때는 항상 payable가 필요함. Code: 1234567891011121314151617181920212223// depositfunction deposit(address _from, uint256 _amount) payable returns (bool) &#123; if(balances[bankAddress] &gt;= _amount) &#123; balances[bankAddress] -= _amount; balances[_from] += _amount; return true; &#125; else &#123; return false; &#125;&#125;// withdrawfunction withdraw(address _from, uint256 _amount) payable returns (bool)&#123; //require(balances[msg.sender] &gt;= _amount); if(balances[_from] &gt;= _amount) &#123; balances[bankAddress] += _amount; balances[_from] -= _amount; return true; &#125; else &#123; return false; &#125;&#125; #2. CryptoCurrency History Chart 프로젝트 목표: Top 100개의 암호화폐의 가격을 쉽게 볼 수 있는 차트 페이지 개발(개인 프로젝트) 기간: 2018.09.24 ~ 2018.09.28 기술 스택: Angular, Typescript, Javascript, CSS, HTML 핵심 기능: 암호화폐 시가총액 및 가격 랭킹 테이블 암호화폐의 가격 차트 각 암호화폐의 기간별 가격 차트 활용한 라이브러리 및 API: coincap.io, chart.js 동영상 기능구현 1. 암호화폐 랭킹 테이블 목표 Top 100개의 암호화폐 시가총액 및 가격을 랭킹별로 보여주는 테이블 기능 구현 각 암호화폐를 클릭하면, 클릭한 암호화폐의 가격 차트를 보여주는 기능 구현 접근법 coincap.io API에서 모든 암호화폐에 대한 시가총액 및 가격을 가져옴. 암호화폐 랭킹 테이블에서 어떤 암호화폐를 클릭시, 클릭한 암호화폐에 대한 가격 차트를 보여주기 위해, coincap.io에서 각 암호화폐에 맞는 API를 가져와 사용 Issues &amp; Solutions #1 Issue: 암호화페 랭킹 테이블에서 어떤 암호화폐를 처음 클릭시, 처음에는 차트가 표시가 안된다. Solution: 원인은 httpclient로 서버에 요청을 보낼 때, 비동기이기 때문에 다른 코드가 먼저 실행된다. 그래서 서버에서 데이터를 받기 전에 차트가 표현되는 함수가 호출되어, 날짜(this.dates)가 undefined로 나타나게 되었기 때문에, 차트가 만들어지지 않게 되었다. 이를 해결하기 위해, httpclient에 subscribe안에서, 함수를 바로 호출하여 dates, prices 등을 가져왔고, 그럼으로써 dates가 만들어져 차트가 나타나게 구현되었다. Code: 12345678910111213141516171819202122232425262728293031323334353637383940// get a chart from api of coin clickedgetCoinChart() &#123; this.http.get(`http://coincap.io/history/$&#123;this.coinSymbol&#125;`).subscribe(element =&gt; &#123; this.convertDates(element); this.convertPrices(element); this.coinChart(this.coinName); &#125;, error =&gt; &#123; console.log(&apos;can\\&apos;t get all days data&apos;); &#125; );&#125;&lt;!-- dates가 있어야 차트가 나타난다. --&gt;// show a chart of the coin clicked after clicking the coin in the ranking tablecoinChart(crytoName: string) &#123; if (this.dates) &#123; // -- coin chart starts -- this.type = &apos;line&apos;; this.chartData = &#123; labels: [...this.dates], // ...this.dates datasets: [ &#123; label: `$&#123;crytoName&#125; price`, data: [...this.prices], // ...this.prices borderColor: &apos;rgb(255, 99, 132)&apos; &#125; ] &#125;; this.options = &#123; responsive: true, maintainAspectRatio: false, &#125;; // -- coin chart ends -- &#125; // if (this.dates)&#125; #2 Issue: 시가총액 및 가격에 대한 날짜 데이터를 가져왔지만, 날짜 형태가 아닌 숫자로 나와 있었음. Solution: 사람이 알아볼 수 있는 날짜 형태로 전환하기 위해, new Date()를 생성하고, Date 함수의 메소드를 이용해서 숫자를 날짜 형태로 전환함. Code: 123456convertDates(data: any) &#123; this.dates = data.price.map(element =&gt; &#123; const eachDate = new Date(element[0]); return `$&#123;eachDate.getFullYear()&#125;/$&#123;eachDate.getMonth()&#125;/$&#123;eachDate.getDay()&#125;`; &#125;);&#125; 2. 암호화폐 가격 차트 목표 암호화폐별, 그리고 각 암호화폐의 history를 보여줄 수 있는 기간별 기능 구현 접근법 chart.js 라이브러리를 활용하여 기간에 따른 가격을 보여주는 차트 기능 구현 Issues &amp; Solutions #1 Issue: 차트 라이브러리는 처음 사용해봐서 어떻게 사용해야 하는지 잘 몰랐음. Solution: chart.js docs를 보면서 최대한 간단한 차트 예제를 활용하여 적용함. Code: 12345678910111213141516171819202122232425coinChart(crytoName: string) &#123; if (this.dates) &#123; // -- coin chart starts -- this.type = &apos;line&apos;; this.chartData = &#123; labels: [...this.dates], // ...this.dates datasets: [ &#123; label: `$&#123;crytoName&#125; price`, data: [...this.prices], // ...this.prices borderColor: &apos;rgb(255, 99, 132)&apos; &#125; ] &#125;; this.options = &#123; responsive: true, maintainAspectRatio: false, &#125;; // -- coin chart ends -- &#125;&#125; #1. 야놀자 펜션 클론 프로젝트 목표: 야놀자 펜션 웹사이트의 핵심 기능 위주로 MVP 개발 기간: 2018.07.30 ~ 2018.08.23 기술 스택: Angular, Typescript, Javascript, CSS, HTML 협업 방식: 프론트엔드 개발자 3명과 백엔드 개발자 3명 프론트엔드 개발자끼리는 핵심 기능을 역할분담하여 정해진 각 기간에 따라 각자 구현하고 코드를 Git으로 합치면서 진행 백엔드 개발자와는 데이터를 서버와 잘 주고 받기 위해 협업하면서 진행 나의 역할: 야놀자 펜션의 펜션 룸을 예약하는 예약페이지 및 결제 방식에 따라 결제하는 결제페이지 구현 동영상 기능구현(예약페이지 &amp; 결제페이지) 1. Calendar 목표 오늘 날짜를 기준으로 이미 지난 날짜들은 Calendar에서 선택을 못하게 하는 기능 구현 선택한 날짜에 따라 그 날짜에 해당하는 펜션 룸 Table 정보를 보여줌으로써, 각 날짜의 각 펜션 룸들의 예약상태가 ‘예약가능’인지 ‘예약완료’인지 알 수 있게 하는 기능 구현 접근법 Angular Bootstrap에서 Datepicker API를 가져와 사용 Datepicker API “markDisabled” 문법에 따라, Calendar에 있는 모든 날짜와 오늘 날짜를 비교해서 오늘 보다 이전 날짜들에 대해 Calendar에서 선택을 못하게 하는 코드 작성 Calendar에서 날짜를 선택할 때마다, 함수를 호출하여 함수안에 매개변수를 선택한 날짜로 줘서, 그 선택한 날짜를 url로 서버에 요청하여 펜션 룸 Table에 펜션의 룸들의 예약상태를 그 선택한 날짜에 맞게 예약페이지에 보여주는 코드 작성 Issues &amp; Solutions #1 Issue: Datepicker API를 어떤식으로 가져와서 사용해야 할지 감이 안잡힘 Solution: Datepicker API 사이트의 어떤 1개의 Example Calendar를 그대로 가져와 그 Example에서 사용된 코드를 Datepicker API 문법을 보면서 전반적으로 이해하려고 노력하면서 감을 잡음 #2 Issue: Calendar에 있는 모든 날짜와 오늘 날짜를 비교하기 위해 Date 함수를 가지고 어떻게 날짜를 비교해야하는지 판단이 어려움 Solution: 처음에는 날짜의 year/month/day를 하나씩 비교해가면서 작성했으나 코드의 양이 너무 많아짐. 그래서 좀 더 간단히 비교할 수 있는 방법을 찾기 위해 Date 함수의 메소드를 찾다가 getTime() 메소드를 알게됨. 즉, 날짜를 비교할 때, milliseconds의 총합으로 비교하면 간단히 날짜를 비교할 수 있다는 것을 알게되어 이 메소드를 코드에 적용해서 해결함. Code: 12345678910111213141516171819// HTML// Use markDisabled in Datepicker&lt;ngb-datepicker #dp (select)=&quot;changeDate.emit($event)&quot; class=&quot;date-picker&quot; [firstDayOfWeek]=&quot;firstDayOfWeek&quot; [markDisabled]=&quot;isDisabled&quot; [dayTemplate]=&quot;t&quot;&gt;&lt;/ngb-datepicker&gt;// Javascript// Disable the dates bofre today &amp; the months that are NOT current monthisDisabled(date: NgbDateStruct, current: &#123;month: number&#125;) &#123; const eachDate = new Date(date.year, date.month - 1, date.day + 1); const todayDate = new Date().getTime(); return eachDate.getTime() &lt; todayDate || date.month !== current.month;&#125; #3 Issue: 선택한 날짜를 가지고 어떻게 url을 만들어서 서버와 통신할지에 대한 고민 Solution: 선택한 날짜의 year/month/day로 문자열을 만들어서 http client를 사용해 url로 코드를 작성 Code: 12345678910111213141516171819// HTML// Use event binding to get the date selected from calendar&lt;app-yapen-calendar(changeDate)=&quot;onDateSelection($event)&quot;[selectedDate]=&quot;selectedDate&quot;&gt;&lt;/app-yapen-calendar&gt;// Javascript// when selecting a date, change to the date selected and to room statusonDateSelection(date: NgbDateStruct) &#123; this.selectedDate = date; this.checkInDate = date; const calendarSelectedDate = `$&#123;date.year&#125;-$&#123;date.month&#125;-$&#123;date.day&#125;`; this.http.get&lt;Pension&gt;(`$&#123;this.urlDate&#125;/$&#123;this.pensionPk&#125;/$&#123;calendarSelectedDate&#125;/`) .subscribe(pension =&gt; this.rooms = pension.rooms);&#125; 배운점 개발할 때, 밑바닥부터 모든 것을 코딩하는 것이 아닌 필요한 기능들에 대한 API를 찾아보고, 실제로 어떻게 적용하는 것인지를 경험함. Date 함수를 이용해 날짜를 비교하는 방법을 알게됨. 서버와 어떻게 통신하여 데이터를 화면에 보여주는 방법을 알게됨. 2. 펜션 룸 Table 목표 선택한 펜션 룸에서 선택한 기간에 맞춰 전체 가격이 변경되는 기능 구현 성인, 아동, 유아의 총 인원수가 선택한 방의 최대 인원수보다 많을 경우 경고창을 보내는 기능 구현 추가되는 성인, 아동, 유아의 인원수마다 전체 가격이 추가되는 기능 구현 접근법 기간을 선택할 수 있는 select 박스에 선택한 기간을 값으로 하는 매개변수로 하는 함수를 호출하여 전체 가격을 계산하는 코드 작성 성인, 아동, 유아의 인원수를 선택할 수 있는 select 박스에 선택한 인원수를 값으로 하는 매개변수로 하는 함수를 호출한 후, 성인, 아동, 유아의 인원수의 총합과 선택한 방의 최대 인원수와 비교하는 코드를 작성 성인, 아동, 유아의 인원수를 선택할 수 있는 select 박스에서 선택한 인원수와 각 성인, 아동, 유아 추가 금액(extra charge)을 계산하여 전체 가격에 더해서 총 가격을 보여주는 코드 작성 Issues &amp; Solutions #1 Issue: 선택한 기간의 값은 함수의 매개변수로 전달받았으나, 모든 룸이 아닌 사용자가 선택한 펜션 룸만의 기본 가격을 어떻게 가져와야 하는지 고민 Solution: 모든 펜션 룸의 pk 중에서 선택한 룸의 pk와 같은 룸만을 filter하여 그 룸의 가격을 찾게 하도록 코드를 작성 Code: 123456789101112131415161718192021222324// HTML&lt;!-- for period --&gt;&lt;div class=&quot;stay-div&quot;&gt; &lt;select class=&quot;stay-select&quot; [attr.id]=&quot;room.pk&quot; class=&quot;selectStayBox&quot; [disabled]=&quot;!(room.pk===checkedPk)&quot; [class.disabled-select]=&quot;!(room.pk===checkedPk)&quot; (change)=&quot;selectPeriod($event.target.value)&quot; #selectStayNum&gt; &lt;ng-container *range=&quot;[1, 6] let stayNum;&quot;&gt; &lt;option [value]=&quot;stayNum&quot;&gt;&#123;&#123; stayNum &#125;&#125;박&lt;/option&gt; &lt;/ng-container&gt; &lt;/select&gt;&lt;/div&gt;&lt;!-- for period --&gt;// Javascript// When selecting a period(1박)selectPeriod(selectedStayNum: number) &#123; this.stayDayNum = selectedStayNum; const checkedRoom = this.rooms.filter(room =&gt; room.pk === this.checkedPk)[0]; this.totalPrice = checkedRoom.price * this.stayDayNum;&#125; 배운점 select 박스 등의 HTML에서 이벤트 바인딩을 통해 값을 전달하여 변경된 값을 화면에 보여주는 코드를 작성하는 방법을 배움. 3. 결제 Form 목표 예약자 정보 및 선택한 결제 방식(신용카드/무통장)에 맞는 결제 정보를 입력하는 폼 기능 구현 예약자 정보 및 각 결제 정보에 대한 유효성 검증을 하여, 맞지 않게 입력되면, 경고를 주는 폼 에러처리 기능 구현 접근법 Angular에서 제공하는 폼을 이용해서 폼 및 폼 에러처리 기능 코드 작성 Issues &amp; Solutions #1 Issue: Angular에서 제공하는 폼에 대한 이해 및 사용법을 숙지하는데 시간이 걸림 Solution: 한번에 모든 결제 정보의 에러처리 기능을 테스트하기 보다, 하나씩 결제 정보의 에러 기능을 테스트하며 구현함. Code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// HTML&lt;!-- 예약자 이름 --&gt;&lt;tr&gt; &lt;th scope=&quot;row&quot;&gt;예약자 이름&lt;/th&gt; &lt;td&gt; &lt;span&gt; &lt;input type=&quot;text&quot; formControlName=&quot;userName&quot; [style.border-color]=&quot;(isEmptyName ? &apos;rgb(255, 101, 89)&apos; : &apos;&apos;)&quot; #inputUserName&gt; &lt;span class=&quot;help&quot;&gt;예) 홍길동&lt;/span&gt; &lt;/span&gt; &lt;/td&gt;&lt;/tr&gt;&lt;!-- 예약자 이름 --&gt;&lt;!-- 휴대폰번호 --&gt;&lt;tr&gt; &lt;th scope=&quot;row&quot;&gt;휴대폰번호&lt;/th&gt; &lt;td&gt; &lt;span&gt; &lt;input type=&quot;text&quot; formControlName=&quot;userPhone&quot; [style.border-color]=&quot;(isEmptyPhone ? &apos;rgb(255, 101, 89)&apos; : &apos;&apos;)&quot; #inputUserPhone&gt; &lt;span class=&quot;empty-phone-number&quot; *ngIf=&quot;isEmptyPhone&quot;&gt; &#123;&#123; !inputUserPhone.value ? &apos;휴대폰번호가 입력되지 않았습니다.&apos; : &apos;휴대폰번호가 정확히 입력되지 않았습니다.&apos; &#125;&#125; &lt;/span&gt; &lt;span class=&quot;help&quot;&gt;예) 0101234567&lt;/span&gt; &lt;/span&gt; &lt;/td&gt;&lt;/tr&gt;&lt;!-- 휴대폰번호 --&gt;&lt;!-- pay button --&gt;&lt;div class=&quot;pay-btn&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary btn-lg&quot; (click)=&quot;userName.errors ? (userPhone.errors ? isDoubleEmpty() : isEmptyName = true) : (userPhone.errors ? isEmptyPhone = true : getUserInfo(inputUserName.value, inputUserPhone.value))&quot;&gt;결제하기&lt;/button&gt;&lt;/div&gt;&lt;!-- pay button --&gt;// Javascriptthis.userForm = this.fb.group(&#123; userName: [&apos;&apos;, Validators.required], userPhone: [&apos;&apos;, [ Validators.required, Validators.pattern(&apos;[0-9]&#123;11&#125;&apos;) ]]&#125;); 배운점 처음 사용해 보는 기능을 코드에 잘 적용하기 위해서는 사용하려는 기능에 대해 충분히 이해를 하고 하나씩 작은 단위로 테스트 해보면서 하는 것이 결국, 더 정확하게 빠르게 코딩을 할 수 있다는 것을 배움."},{"title":"categories","date":"2018-08-28T12:01:37.000Z","updated":"2018-08-28T12:02:33.051Z","comments":true,"path":"categories/index.html","permalink":"https://cheonmro.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-08-28T12:03:36.000Z","updated":"2018-08-28T12:03:49.565Z","comments":true,"path":"tags/index.html","permalink":"https://cheonmro.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Git으로 프로젝트 생성하는 방법","slug":"create-git-project","date":"2019-04-13T07:32:42.000Z","updated":"2019-04-13T07:32:42.181Z","comments":true,"path":"2019/04/13/create-git-project/","link":"","permalink":"https://cheonmro.github.io/2019/04/13/create-git-project/","excerpt":"","text":"Git으로 프로젝트 생성하여 다른 사람이 작업을 시작할 수 있게 하기 위한 초기 세팅 과정 1. Github/Gitlab 등에서 Repository 생성 Github/Gitlab 등에서 README.md 파일을 포함하여 Repository를 생성한다. 2. 로컬에서 clone 하기 로컬에서 git clone https://github.com/cheonmro/testgit.git 명령어를 실행하여, 원격 저장소를 clone 한다. 3. clone 한 폴더 안에서 프로젝트 폴더를 생성 리액트 프로젝트의 경우, create-react-app testgit 와 같이 새로운 프로젝트 폴더를 생성한다. 4. 원격으로 push 하기(master 브랜치 셋업) 다음과 같이, 원격 저장소로 로컬에 새로 생성한 프로젝트 폴더를 push한다. git add . git commit -m &quot;add create-react-app git push origin master 이렇게 하면, 원격 저장소와 로컬 저장소에 기본적인 리액트 프로젝트 폴더가 들어가게 세팅이 된다. 그러나, 실제 프로젝트 개발시에는 dev 브랜치를 이용해서 하기 때문에, master 브랜치는 여기까지만 생성하고, dev 브랜치를 이용해야 한다. 5. 로컬에서 dev 브랜치 생성 로컬에서 다음의 명령어로 dev 브랜치를 생성한다. git checkout -b dev checkout과 -b를 같이 사용하면, dev 브랜치를 생성하면서 동시에 dev 브랜치로 이동하게 된다. 6. 생성한 dev 브랜치에서 프로젝트를 위한 전반적인 폴더 구조 셋업 현재는 create-react-app으로 만들어진 기본적인 구조밖에 없다. 여기서 우리가 만들 프로젝트에 대한 전반적인 구조를 만들어야 한다. 7. 새롭게 셋업된 로컬의 dev 브랜치를 push 하기 새롭게 프로젝트를 만들었다면, 로컬의 dev 브랜치를 원격저장소에 push 해야한다. git add . git commit -m &quot;add project-structure git push origin dev 이렇게 하여, 본격적인 프로젝트를 시작하기 위한 dev 브랜치가 완성되었다. 이제부터는 각 팀원이 git clone을 하여 각 컴퓨터 로컬에 내려받고, 거기서 각자가 맡은 기능별로 브랜치를 새로 생성하여 개발을 시작하면 된다.","categories":[{"name":"Git","slug":"Git","permalink":"https://cheonmro.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://cheonmro.github.io/tags/Git/"}]},{"title":"How Ethereum Transaction Works","slug":"how-ethereum-transaction-works","date":"2019-04-06T05:42:11.000Z","updated":"2019-04-06T05:42:11.236Z","comments":true,"path":"2019/04/06/how-ethereum-transaction-works/","link":"","permalink":"https://cheonmro.github.io/2019/04/06/how-ethereum-transaction-works/","excerpt":"","text":"이더리움 트랜잭션 작동원리 EOA(사용자 계정)가 트랜잭션을 발생(발생한 트랜잭션에는 nonce/to/value/gasLimit/gasPrice/data 등이 들어감) 발생한 트랜잭션을 사용자가 가지고 있는 지갑의 pk로 전자서명(Sign)을 함(전자 서명 암호화 방식) Sign된 트랜잭션을 이더리움 네트워크의 노드들에게 보냄(트랜잭션을 브로드캐스트) 노드(채굴자)들은 해당 트랜잭션의 유효성 검증을 함 해당 트랜잭션이 문법에 맞게 구성되었는지 사용자의 공개 키를 사용하여 해당 전자 서명이 유효한지 사용자 어카운트에 있는 Nonce와 맞는지 해당 트랜잭션이 유효하면, 해당 트랜잭션은 트랜잭션 풀(Tx pool)에 보관됨 채굴자들은 수수료가 높은 순서대로 트랜잭션을 처리함 여러 트랜잭션이 블록에 포함되고 블록이 생성되면, 모든 노드들에게 신규 블록이 전달됨(신규 블록 브로드캐스트) Ethereum API를 활용한 트랜잭션 만드는 방법 Ethereum API를 활용해서 다음과 같은 기능을 만들어 보자. 이더리움 지갑 및 key 생성 balance 조회 transfer 토큰 정보 가져오기 위 기능들을 React에서 만들어 보자. 1. 이더리움 지갑 및 key 생성 이더리움의 지갑을 만들기 위해서는 이더리움에서 제공하는 ‘ethereumjs-wallet’ 라이브러리를 사용해야 한다. ‘ethereumjs-wallet’ 설치1npm install ethereumjs-wallet 리액트에서 코드는 다음과 같다. 123456789101112131415161718192021222324import Wallet from &apos;ethereumjs-wallet&apos;;class MultiWallets extends Component &#123; constructor(props) &#123; super(props); &#125; generateWallet = () =&gt; &#123; let wallet = Wallet.generate(); let address = &apos;0x&apos; + wallet.getAddress().toString(&apos;hex&apos;); let privKey = wallet.getPrivateKey().toString(&apos;hex&apos;); let pubKey = wallet.getPublicKey().toString(&apos;hex&apos;); &#125; render() &#123; return ( &lt;div className=&quot;MultiWallets&quot;&gt; &lt;button onClick=&#123;() =&gt; this.generateWallet()&#125;&gt;Generate a Wallet&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 위 코드는 button을 클릭하면, wallet과 wallet의 address, private key, 그리고 public key를 생성할 수 기능이다. generate() 함수를 사용하여, wallet을 생성한다. 생성한 wallet의 getAddress() 함수를 이용하여 주소값을 만드는데, 이더리움은 ‘0x’를 포함한 hex string으로 값을 만든다. 그래서, toString(‘hex’)와 앞에 ‘0x’를 붙여 address 값을 만든다. 생성한 wallet의 getPrivateKey() 함수와 getPublicKey() 함수를 이용해서 private key와 public key를 생성한다. 2. 지갑의 balance 조회 이더리움 지갑의 balance를 조회하기 위해서는 이더리움에서 제공하는 web3 라이브러리를 사용해야 한다. web3 설치 1npm install web3 리액트에서 코드는 다음과 같다. 1234567891011121314151617181920212223242526272829import Wallet from &apos;ethereumjs-wallet&apos;;import Web3 from &apos;web3&apos;;class MultiWallets extends Component &#123; constructor(props) &#123; super(props); &#125; componentWillMount() &#123; window.web3 = new Web3(new Web3.providers.HttpProvider(&apos;https://ropsten.infura.io/v3/API_KEY&apos;)) &#125; getBalance = () =&gt; &#123; // 여기서 account는 위에서 만든 address이다. const &#123; account &#125; = this.state; window.web3.eth.getBalance(account).then(console.log) window.web3.eth.getBalance(&apos;0xBF345977799290F574dB970366CF1712AdCd0632&apos;).then(console.log) &#125; render() &#123; return ( &lt;div className=&quot;MultiWallets&quot;&gt; &lt;button onClick=&#123;() =&gt; this.getBalance()&#125;&gt;Get Balance&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 위 코드는 버튼을 클릭하면, balance를 조회하는 기능이다. web3를 사용하기 위해서는 우선, new 연산자를 이용해 web3 인스턴스를 생성하고, HttpProvider를 이용해서 이더리움 네트워크와 연결해야 한다.(위 코드는 이더리움의 테스트넷인 Ropsten의 infura API를 사용하여 infura에서 얻은 API_KEY로 노드를 연결했다.) 만약, Private 블록체인으로 연결하고 싶다면, localhost:8545로 연결하면 된다. web3.eth의 getBalance() 함수를 이용해 내가 가진 지갑주소의 balance를 확인할 수 있다. *infura infura는 개발자가 API KEY만으로도 이더리움의 메인넷 또는 테스트넷에 접근을 가능하게 한다. infura를 로그인하면 API KEY와 ENDPOINT를 제공해준다. web3의 HttpProvider를 사용해서 이더리움 네트워크에 연결할 때, infura에서 제공하는 ENDPOINT를 사용하면 된다. 3. transfer transfer(송금) 기능을 만들기 위해서는, transaction을 생성하고, 서명하여 전송하면 된다. 리액트에서 코드는 다음과 같다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import Wallet from &apos;ethereumjs-wallet&apos;;import Web3 from &apos;web3&apos;;class MultiWallets extends Component &#123; constructor(props) &#123; super(props); &#125; componentWillMount() &#123; window.web3 = new Web3(new Web3.providers.HttpProvider(&apos;https://ropsten.infura.io/v3/API_KEY&apos;)) &#125; sendTransaction = () =&gt; &#123; const &#123; account &#125; = this.state; const sendAccount = &apos;0xBF345977799290F574dB970366CF1712AdCd0632&apos;; // 1. check the number of nonce window.web3.eth.getTransactionCount(sendAccount, (err, txCount) =&gt; &#123; // 2. create transaction const txObject = &#123; nonce: window.web3.utils.toHex(txCount), to: account, gasLimit: window.web3.utils.toHex(1000000), gasPrice: window.web3.utils.toHex(window.web3.utils.toWei(&apos;10&apos;, &apos;gwei&apos;)), value: window.web3.utils.toHex(window.web3.utils.toWei(&apos;0.01&apos;, &apos;ether&apos;)) &#125;; const tx = new Tx(txObject) // 3. Sign transaction // a private key of the sendAccount const privateKey = &apos;BE43625EA38CF1FA2D09D057F2E0AB36899E28338E2BCB698CFA6F066EDDF04C&apos;; const _privateKey = Buffer.from(privateKey, &apos;hex&apos;); tx.sign(_privateKey) // 4. Send transaction const serializedTx = &apos;0x&apos; + tx.serialize().toString(&apos;hex&apos;); window.web3.eth.sendSignedTransaction(serializedTx, function(err, txId) &#123; console.log(&apos;serializedTx:&apos;, serializedTx) if(!err) &#123; console.log(&apos;txId:&apos;, txId) &#125; else &#123; console.log(&apos;err:&apos;, err) &#125; &#125;) &#125;) &#125; render() &#123; return ( &lt;div className=&quot;MultiWallets&quot;&gt; &lt;button onClick=&#123;() =&gt; this.sendTransaction()&#125;&gt;Send Transaction&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 위 코드는 버튼을 클릭하면, transaction을 발생시키는 기능이다. transaction을 발생시키기 위한 단계는 다음과 같다. nonce 값 구하기 transaction 생성 transaction 서명 transaction 보내기 1. nonce 값 구하기 123window.web3.eth.getTransactionCount(sendAccount, (err, txCount) =&gt; &#123;&#125; getTransactionCount() 함수를 사용하여 nonce값을 구하는데, getTransactionCount() 함수 안에 인자 txCount가 nonce 값이다. nonce값이란, 해당 transaction을 발생시키는 account가 발생시킨 총 transaction의 수를 말한다. 2. transaction 생성 12345678910111213import Tx from &apos;ethereumjs-tx&apos;;// 1. transaction 생성에 필요한 txObject 생성const txObject = &#123; nonce: window.web3.utils.toHex(txCount), to: account, gasLimit: window.web3.utils.toHex(1000000), gasPrice: window.web3.utils.toHex(window.web3.utils.toWei(&apos;10&apos;, &apos;gwei&apos;)), value: window.web3.utils.toHex(window.web3.utils.toWei(&apos;0.01&apos;, &apos;ether&apos;))&#125;;// 2. &apos;ethereumjs-tx&apos; 라이브러리를 이용해 tx 인스턴스 생성const tx = new Tx(txObject) transaction을 생성하기 위해 필요한 txObject를 만들어야 하는데, 이 txObject에는 위와 같은 값들이 들어간다. web3의 utils에 있는 toHex() 함수를 이용해 값들을 hex 값으로 만들었는데, 위 코드의 값들은 예시로 작성한 것이다. 참고로, toWei() 함수는 인자로 들어간 값을 Wei 단위로 변환한다는 뜻이다. 예를 들어, window.web3.utils.toWei(‘10’, ‘gwei’)이면, 10 gwei 값을 wei 값으로 변환하라는 뜻이다. 위에서 만든 txObject를 가지고 transaction을 생성하기 위해서는 ethereumjs-tx 라이브러리를 사용해 tx를 생성한다. 3. transaction 서명 이더리움에서 transaction을 서명(=== 전자서명)할 때는, 수신자의 private key를 가지고 transaction을 서명한다. 1234// a private key of the sendAccountconst privateKey = &apos;PK&apos;;const _privateKey = Buffer.from(privateKey, &apos;hex&apos;);tx.sign(_privateKey) private key로 서명하기 위해서는 private key 값을 buffer 타입으로 변경하여 사용해야 한다. buffer 타입이란, Unit8Array 타입으로, 값들이 배열(‘[]’)에 들어가 있다. 처음에 generate() 함수로 wallet을 생성했을 때, 그 wallet 안에 들어있는 private key 값의 타입은 Unit8Array 타입으로 되어있다. 이 private key 값을 위에서 hex 값으로 변경해서 사용했었는데, 이 값을 다시 buffer 타입으로 변경해서 Sign 할 때 사용해야 한다. 4. transaction 보내기 서명된 transaction을 serialize하여 sendSignedTransaction() 함수를 이용해 transaction을 보낸다. 123456789101112// 1. serialize transactionconst serializedTx = &apos;0x&apos; + tx.serialize().toString(&apos;hex&apos;);// 2. send signed transactionwindow.web3.eth.sendSignedTransaction(serializedTx, function(err, txId) &#123; console.log(&apos;serializedTx:&apos;, serializedTx) if(!err) &#123; console.log(&apos;txId:&apos;, txId) &#125; else &#123; console.log(&apos;err:&apos;, err) &#125;&#125;) Serialization이란, 네트워크를 통해 데이터를 주고 받을 때, 서로간에 공유하는 규칙이 있는데, 이 규칙에 맞게 데이터를 출력하는 것을 말한다. sendSignedTransaction() 함수를 사용해 얻은 txId 값은, 이 transaction의 txHash값이 되고, 즉 transaction id가 된다. 이 txHash값으로 Ether Scan에서 이 transaction에 대한 거래내역을 확인할 수 있다. 참고: Serialization 4. 토큰 정보 가져오기 1234567891011121314151617181920212223242526272829303132333435import Web3 from &apos;web3&apos;;import &#123; erc20Abi &#125; from &apos;../constant/abi&apos;;import &#123; ethToken &#125; from &apos;../constant/ethToken&apos;class MultiWallets extends Component &#123; constructor(props) &#123; super(props); &#125; addToken = () =&gt; &#123; // Omisego token const tokenAddress = &apos;0xd26114cd6EE289AccF82350c8d8487fedB8A0C07&apos;; let token = window.web3.eth.Contract(erc20Abi, tokenAddress) // get token info const tokenInfo = ethToken.filter((token) =&gt; &#123; return token.address.toLowerCase() === tokenAddress.toLowerCase() &#125;); console.log(&apos;tokenInfo:&apos;, tokenInfo) console.log(&apos;symbol:&apos;, tokenInfo[0].symbol) console.log(&apos;decimal:&apos;, tokenInfo[0].decimal) &#125; render() &#123; return ( &lt;div className=&quot;MultiWallets&quot;&gt; &lt;button onClick=&#123;() =&gt; this.addToken()&#125;&gt;Add Token&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 위 코드는 addToken 버튼을 클릭하면, 해당 토큰의 정보를 가져올 수 있는 기능이다. 각 토큰은 토큰의 address를 가지고 있다. web3의 Contract() 함수를 사용하면 토큰의 정보를 가져올 수 있다.1new web3.eth.Contract(jsonInterface, address, options) Contract() 함수안에 jsonInterface는 abi 파일로써, contract가 인스턴스화하기에 필요한 json interface 파일이다.(abi 파일) 위 코드의 ethToken는 이더리움의 모든 토큰에 대한 정보를 모아놓은 파일이다. 즉, 선택한 토큰이 이 파일안에 있는 모든 이더리움 토큰과 비교해 해당 토큰을 찾아 그 토큰에 대한 정보를 가져오는 방식으로 코드를 작성했다.","categories":[{"name":"Ethereum","slug":"Ethereum","permalink":"https://cheonmro.github.io/categories/Ethereum/"}],"tags":[{"name":"Transaction","slug":"Transaction","permalink":"https://cheonmro.github.io/tags/Transaction/"},{"name":"Ethereum","slug":"Ethereum","permalink":"https://cheonmro.github.io/tags/Ethereum/"}]},{"title":"Ethereum State Transition Model(이더리움 상태 전이 모델)","slug":"ethereum-state-transition-model","date":"2019-04-01T17:09:26.000Z","updated":"2019-04-01T17:09:26.113Z","comments":true,"path":"2019/04/02/ethereum-state-transition-model/","link":"","permalink":"https://cheonmro.github.io/2019/04/02/ethereum-state-transition-model/","excerpt":"","text":"정의 이더리움 네트워크에서는 트랜잭션이 발생할 때마다, 이에 대한 신뢰 여부를 채굴자들의 합의하에 블록을 생성하여 모든 트랜잭션을 처리한다. 이렇게 트랜잭션을 처리하게 되면, 관련된 Account의 상태가 변화하게 된다. 즉, 이더리움은 이와 같이 상태가 변화하는 상태 전이 과정을 기반으로 작동한다. 트랜잭션 발생 -&gt; 블록 생성 -&gt; 관련된 Account의 상태 변화 모든 Account의 상태 정보는 블록과 블록 내에 연결된 머클 패트리시아 트리로 저장되고 관리된다. 상태 전이(State Transition) 상태 전이란, 특정 시점의 현재 상태 S가 상태 전이 함수(APPLY())에 의해 다른 상태(S’)로 전이되거나 전이에 실패하고 이전 상태로 복귀되는 것을 말한다.Account의 상태는 상태 전이 함수에 의해 전이된다. APPLY(S, TX) -&gt; S’[S: 현재 상태] -&gt; (APPLY: 상태 전이 함수) -&gt; [S’: 전이된 상태 또는 실패] 상태 전이 함수 개인 Account간의 송금 등에 의한 트랜잭션 이더리움 가상 머신에서 실행되는 프로그램인 스마트 컨트랙트에 의한 트랜잭션 출처: State Transition 이더리움 단일 상태 전이 이더리움의 상태(State)는 복수의 상태 변이를 갖지 못하고, 단 하나의 상태 변이만을 갖는다. 즉, Account의 특정 시점의 한 상태는 상태 전이 함수를 통해 단 하나의 상태(single state)로만 전이된다는 것이다. 만약, 하나의 상태가 여러 개의 상태로 전이된다면, 채굴자들은 어떤 상태가 맞는 것인지 판단하고 합의 할 수 없다. 출처: Ethereum Single State Transition 상태 전이 프로세스 기본 트랜잭션 형식 확인 Gas 값 수수료 계산 및 잔고 확인 기본 트랜잭션 형식 확인 트랜잭션의 형식이 맞는지 확인 서명이 유효한지 확인 Nonce가 발신처 Account의 Nonce와 일치하는지 확인 트랜잭션이 유효하지 않을 경우, Error를 반환 출처: Transaction fields Gas 값 수수료 및 잔고 확인 트랜잭션 수수료(=gasLimit * gasPrice) 계산 서명으로부터 발신처 주소를 결정 발신처 Account의 balance에서 계산한 트랜잭션 수수료를 빼고, 발신자 Nonce를 증가 발신처 balance가 충분하지 않으면, Error를 반환 GAS = gasLimit으로 초기화 한 후, 트랜잭션에서 사용된 byte에 대한 값을 지불하기 위해 byte 당 gas의 특정 양을 차감(트랜잭션의 총 byte 길이 * byte 당 gas 수수료) 발신처 Account에서 수신처 Account로 트랜잭션 값을 보냄 이때, 수신처 Account가 존재하지 않으면 새로 생성 만약, 수신처 Account가 컨트랙트면, 컨트랙트 코드를 끝까지 수행 이때, GAS가 모두 소모되면, 소모될 때까지만 수행 발신처의 balance가 전송할 값보다 적거나, 코드 수행시 GAS가 부족하면, 모든 상태 변경을 원상태로 돌려놓음 이때, 코드를 수행한 만큼의 GAS는 채굴자 Account로 더해지고, 나머지 GAS는 발신처 Account에 다시 돌려짐 수수료 트랜잭션 처리에 대한 수수료 스마트 컨트랙트 코드 실행 처리에 대한 수수료 상태 전이 예제 &lt;예제&gt; 트랜잭션은 다음과 같은 field를 가지고 전달된다고 가정 Value = 10 ether gasLimit = 2,000 gasPrice = 0.001 ether Data = 64 bytes(스마트 컨트랙트 호출에 필요한 parameter 값) 0-31 bytes까지는 숫자 2로 나타내고, 32-63 bytes는 CHARLIE 문자열로 나타냄) 트랜잭션의 총 길이 = 170 bytes, byte 당 GAS 수수료 = 5 gas (트랜잭션 처리에 대한 수수료 = 170 * 5 = 850 GAS) 스마트 컨트랙트 코드 실행시 GAS 수수료 = 187 GAS &lt;프로세스&gt; 트랜잭션의 형식과 서명이 유효한지 확인(기본 트랜잭션 형식이 맞는지 확인) 트랜잭션 발송처가 최소 2000 * 0.001 = 2 ether를 가지고 있는지 확인하고, 발송처의 Account에서 2 ether를 차감 발신처 balance가 2 ether 보다 적으면, Error를 반환 발신자 Nonce를 증가 GAS = 2,000으로 초기화 한 후, 트랜잭션 처리에 대한 수수료 850 GAS를 차감하면, 1150 GAS가 남음 발신처 Account에서 보내고자 하는 10 ether를 차감하고, 이것을 수신처 Account에 보냄 이때, 수신처 Account가 스마트 컨트랙트면, 컨트랙트 Account에 더함 스마트 컨트랙트의 코드를 실행하여 스마트 컨트랙트의 코드 실행 처리 수수료인 187 GAS를 차감하면, 963 GAS가 남음(1150 - 187 = 963) 963 * 0.001 = 0.963 ether를 송신처의 Account에 되돌려주고, 상태를 반환 만약, 코드 수행시에 GAS가 모두 소모되면, 소모될 때까지만 수행 코드 수행시, GAS가 부족하면, 모든 상태 변경을 원상태로 돌려놓음 이때, 코드를 수행한 만큼의 GAS는 채굴자 Account로 더해지고, 나머지 GAS는 발신처 Account에 다시 돌려짐 출처: State Transition Example","categories":[{"name":"Ethereum","slug":"Ethereum","permalink":"https://cheonmro.github.io/categories/Ethereum/"}],"tags":[{"name":"Ethereum","slug":"Ethereum","permalink":"https://cheonmro.github.io/tags/Ethereum/"},{"name":"State Transition","slug":"State-Transition","permalink":"https://cheonmro.github.io/tags/State-Transition/"}]},{"title":"ICON Data","slug":"icon-data","date":"2019-03-30T09:04:44.000Z","updated":"2019-03-30T09:04:44.941Z","comments":true,"path":"2019/03/30/icon-data/","link":"","permalink":"https://cheonmro.github.io/2019/03/30/icon-data/","excerpt":"","text":"ICONex에서 Transfer 할 때, 입력할 수 있는 Data 타입 ICONex에서 송금할 때, data를 입력할 수 있다. 여기서 말하는 data는 message를 말하는데, 전달할 message가 있다면 작성할 수 있고, 기본적으로 optional이다. 입력하는 data의 타입은 UTF-8과 HEX 2가지다. UTF-8 UTF-8이란, 어떤 언어의 문자든 유니코드(unicode)로 인코딩하는 방식으로, 여러 방식이 있으나 이 방식을 가장 많이 사용한다. 유니코드(unicode)란, 전 세계의 모든 문자를 컴퓨터에서 일관되게 표현하는 표준 코드를 말한다. 인코딩이란, ‘부호화하다’라는 의미로, 이를 컴퓨터 공학에서 정의하면, 입력 데이터를 컴퓨터속에서 사용하는 코드로 변환하는 것을 말한다. 즉, 문자나 기호들의 집합을 컴퓨터에 저장하거나 통신에 사용할 목적으로 부호화하는 방법이다. 디코딩이란, ‘복호화하다’라는 의미로, 부호화(Encoding)된 정보를 부호화되기 전으로 되돌리는 처리 방식을 말한다. 정보를 표현하기 위한 글자들의 집합을 문자집합(Character Set)이라고 하고, 다음의 2가지 종류가 대표적인 표준코드이다. ASCII코드 유니코드 ASCII코드는 영문 알파벳을 사용하는 대표적인 문자 인코딩된 표준 코드이다. 그러나, 한글 등 다른 모든 언어를 사용하기 위해서는 이 방식보다 다른 방식을 더 사용한다. 그것은 바로, 유니코드이다. 유니코드란, 전 세계의 모든 문자를 컴퓨터에서 일관되게 표현하고 다룰 수 있도록 설계된 산업 표준코드이다. 내가 제작하려고 하는 웹애플리케이션 또는 웹페이지에서 다국어를 지원하기 위해서는 사용된 문자를 유니코드로 인코딩 해야하고, 이때 인코딩하는 방식 중 UTF-8를 주로 사용한다. UTF-8를 사용하면, 전 세계 모든 문자를 표현할 수 있고, 한 문자를 표현하기 위해 1바이트에서 4바이트까지 사용한다. 웹 개발을 할 때, html에서 다음과 같이 작성한다.123&lt;head&gt;&lt;meta charset=UTF-8&quot; /&gt;&lt;/head&gt; 위와 같이 작성하면, html 문서의 문자는 UTF-8 방식으로 인코딩하여 유니코드로 변환한다는 뜻이다. 만약, 위와 같이 작성하지 않으면, html 문서를 브라우저에서 구현할 때 한글 등 다른 언어들이 깨져 보일 수가 있다. 참고: Encoding vs Decoding) Unicode How UTF-8 Works HEX HEX란, 0x를 접두어(prefix)로 사용한 16진수를 표현하는 방식으로, Hexadecimal의 줄임말이다. 예를 들어, 0x547261636b65722063656c6c20ed858cec8aa 와 같이 표현한다. Data 입력시 수수료 부과 ICONex에서 송금시에 트랜잭션에 사용될 기본적인 Step Limit이 default로 있고, Step Price는 고정되어 있다. 이 둘을 곱한 값이 총 수수료이다. 그런데, 만약 Data를 입력하게 되면, 입력한 Data의 양만큼의 추가 수수료가 부과된다. 이는 Data를 입력하는 양에 따른 Step Limit이 변경되어 최종 수수료가 변경되기 때문이다.","categories":[{"name":"ICON","slug":"ICON","permalink":"https://cheonmro.github.io/categories/ICON/"}],"tags":[{"name":"ICON Data","slug":"ICON-Data","permalink":"https://cheonmro.github.io/tags/ICON-Data/"}]},{"title":"ICON Unit","slug":"icon-unit","date":"2019-03-22T14:42:15.000Z","updated":"2019-03-30T06:57:41.058Z","comments":true,"path":"2019/03/22/icon-unit/","link":"","permalink":"https://cheonmro.github.io/2019/03/22/icon-unit/","excerpt":"","text":"Ether의 기본단위 이더리움의 가장 작은 단위는 wei 이다. Name Description 1 ether 110^18 wei(=== 1e^18 wei) 1 ether 110^9 Gwei(=== 1e^9 Gwei) 1 Gwei 110^9 wei(=== 1e^9 wei) 참고로, Gwei는 가스(이더리움 네트워크 거래 수수료) 비용을 계산할 때, 주로 사용한다. ICX의 기본단위 ICON도 이더리움과 비슷한 개념을 사용한다. ICON의 가장 작은 단위는 loop 이다. Name Description 1 icx 10^18 loop(=== 1*e^18 loop) 1 icx 10^9 Gloop(=== 1*e^9 Gloop) 1 Gloop 10^9 loop(=== 1*e^9 loop) 참고로, Gloop는 step(ICON 네트워크 거래 수수료) 비용을 계산할 때, 주로 사용한다. Ethereum Fee System 이더리움에서 어떤 1개의 트랜잭션을 실행하는 데 사용자가 지불해야하는 수수료를 최대 트랜잭션 실행 비용(Max Transaction Fee)이라고 한다. Max Transaction Fee(최대 트랜잭션 실행 비용) = Gas Limit(가스 총량) * Gas Price(가스 가격) Gas Limit(가스 총량)이란, 트랜잭션을 실행하는데 예상되는(추정되는) 총 가스량을 말한다. Gas Price(가스 가격)이란, 1 가스당 가격을 말한다. 즉, 어떤 사용자가 1개의 트랜잭션을 수행하려고 하면, 그 트랜잭션을 수행하는 것에 대한 수수료(최대 트랜잭션 실행 비용)를 지불해야 하는데, 그 수수료는 Gas Limit(가스 총량) * Gas Price(가스 가격)으로 계산되어진다. 이때, Gas Limit(가스 총량)은 각 트랜잭션에 필요한 총 가스량을 추정(estimated)해서 계산된 값이 나오고, Gas Price(가스 가격)은 1 가스당 가격으로 이 가격이 높을수록 마이너들이 보상을 많이 받기 때문에, 트랜잭션이 빨리 처리가 된다. 즉, 트랜잭션 실행 속도가 빠르게 된다. 출처: How Gas works 어떤 트랜잭션을 실행하려면, 사용자 어카운트에 있는 ether 잔액이 최대 트랜잭션 실행 비용보다 많아야 한다. 만약 적거나, 트랜잭션 실행 도중에 가스를 모두 사용하면, 해당 트랜잭션은 중단되고 이전 상태로 복귀되지만, 사용된 가스는 발신자에게 반환되지 않는다. 만약 ether 잔액이 충분하고, 트랜잭션이 성공적으로 실행이 되었는데, 가스가 남았다면 이 가스는 사용자에게 반납된다. ICON Fee System ICON의 step limit과 step price는 이더리움의 gas limit과 gas price 개념과 동일하다. Estimated Transaction Fee(최대 트랜잭션 실행 비용) = Step Limit(스텝 한도) * Step Price(스텝 가격) Step Limit(스텝 한도)이란, 트랜잭션을 실행하는데 예상되는(추정되는) 총 스텝양을 말한다. Step Price(스텝 가격)이란, 1 스텝당 가격을 말한다. 즉, 어떤 사용자가 1개의 트랜잭션을 수행하려고 하면, 그 트랜잭션을 수행하는 것에 대한 수수료(최대 트랜잭션 실행 비용)를 지불해야 하는데, 그 수수료는 Step Limit(스텝 한도) * Step Price(스텝 가격)으로 계산되어진다. ICON에서 송금 등의 트랜잭션 실행을 할 때, 기본적으로 Step Limit이 100000이다. 이 값은 default로 사용자가 Step Limit의 값을 변경할 수 있다. 그러나, Step Limit의 최대값과 최소값은 정해져 있어서 그 범위안에서만 변경이 가능하다. Step Price는 0.00000001 ICX (10 Gloop)로 고정되어있다. 어떤 트랜잭션을 실행하려면, 사용자 어카운트에 있는 icx 잔액이 최대 트랜잭션 실행 비용보다 많아야 한다. 만약 적거나, 트랜잭션 실행 도중에 step을 모두 사용하면, 해당 트랜잭션은 중단되고 이전 상태로 복귀되지만, 사용된 step은 발신자에게 반환되지 않는다. 만약 step limit을 잔액보다 높게 설정하더라도, 해당 트랜잭션에 필요한 step 만큼만 소진된다.","categories":[{"name":"ICON","slug":"ICON","permalink":"https://cheonmro.github.io/categories/ICON/"}],"tags":[{"name":"ICON Unit","slug":"ICON-Unit","permalink":"https://cheonmro.github.io/tags/ICON-Unit/"}]},{"title":"Redux-Saga","slug":"redux-saga","date":"2019-03-17T12:35:33.000Z","updated":"2019-03-17T12:35:33.062Z","comments":true,"path":"2019/03/17/redux-saga/","link":"","permalink":"https://cheonmro.github.io/2019/03/17/redux-saga/","excerpt":"","text":"Redux-Saga란 무엇인가? Redux-saga란, side effect를 관리하기 위한 middleware이다. Side effect란, 애플리케이션의 부작용들(데이터 요청 등의 비동기 작업/브라우저 캐시 같은 순수하지 않은 것들)을 말한다. middleware란, 액션이 dispatch 되어서 리듀서에서 이를 처리하기 전에 그 사이에서 중간자로써 지정된 특정 작업을 하는 것을 말한다. Redux-Saga를 왜 사용하는가? 비동기 처리 등 순수하게 액션만을 전달하는 것 이상으로 발생하는 상황들(side effects)을 다룰 때, 이 미들웨어를 사용한다. Redux-Thunk 대신에 Redux-Saga를 사용하는 이유는 무엇인가? redux-thunk를 사용하면, 비동기 처리를 Action Creator(액션 생성자 함수)에서 작성하게 되어, 로직이 복잡해진다. 기본적으로 Redux에서 Action Creator에서는 액션을 객체형태로 생성하여 dispatch 하는데, redux-thunk에서는 액션을 함수형태로 생성하여 dispatch 하여, Action Creator에 비동기처리 코드나 관련된 로직이 들어가게 된다. 그런데, Redux-saga는 비동기 처리를 기술하는 전용의 방식인 task로 쓰여있다. 즉, 비동기 처리를 각 saga(task)에서 명령을 내리고, 동작을 미들웨어에서 처리한다. 그래서, redux에서의 action creator에서 기존과 그대로 액션을 객체형태로 생성하여 dispatch 할 수가 있고, saga에서의 코드도 더 간단해진다. 결국, Action Creator는 본래의 모습을 되찾아, action 객체를 생성하여 돌려주는 순수한 상태로 돌아가게 된다. 결론적으로, Redux-Saga를 사용하게 되면, 비동기 처리를 액션 생성자로부터 분리하여 작성하기 때문에, 가독성도 좋고 콜백 처리 등에 더 수월하다. Redux-Saga Architecture 출처: Redux-Saga Architecture Redux-Saga Flow 출처: Redux-Saga Architecture) 위 Flow를 정리하면 다음과 같다. 어떤 비동기 액션이 dispatch 되면, Reducer에 먼저 도달한다. 정확하게는 액션이 Reducer로 지나가는 것을 본 후, Redux-Saga에 액션을 처리한다. Reducer는 순수 함수라는 규칙이 있기 때문에, 비동기 액션을 처리하지 못한다. 이 비동기 액션을 Redux-Saga에 있는 watcher saga가 보고 있다가, watcher saga에 등록되어 있는 task를 수행한다. 이 watcher saga의 역할은 어떤 비동기 액션이 dispatch 되면, 어떤 task를 수행하도록 등록하는 것이다. 이때, takeEvery라는 헬퍼 이펙트를 사용하는데, 이 이펙트는 여러개의 task를 동시에 시작할 수 있다. 즉, 1개 혹은 아직 종료되지 않은 task가 있더라도 새로운 task를 시작할 수 있다. 1234// INCREMENT_ASYNC 액션이 Dispatch 되면 `incrementAsync`를 수행하도록 등록한다.export function* watchIncrementAsync() &#123; yield takeEvery(INCREMENT_ASYNC, incrementAsync)&#125; incrementAsync를 수행하는데, 만약 task가 2초 마다 +1씩 증가하는 함수라고 한다면, 다음과 같이 작성한다. 1234function* incrementAsync(action) &#123; yield delay(2000) // 2초를 기다리고 yield put(&#123; type: INCREMENT &#125;) // INCREMENT 액션을 Dispatch한다.&#125; 위 task가 수행될 때, 먼저 첫번째 줄에 있는 delay(2000)이 yield 된다. delay는 설정된 시간 이후에 resolve를 하는 Promise 객체를 리턴하는 함수이다. 이 Promise가 미들웨어에 yield 될때, 미들웨어는 Promise가 끝날때까지 Saga를 일시정지 시킨다.(generator 함수의 특징) 즉, 이 부분은 동기적으로 동작한다. 2초후, Promise가 한번 resolve 되면, 미들웨어는 saga(task)를 다시 작동시키면서, 다음 yield까지 코드를 실행한다. 이런 방식으로 saga(task)에서 1개씩 yield되고, 그 yield 된 것이 미들웨어에 의해 동작이 완료되면, 그때 그 다음줄에 있는 객체가 yield된다. 어떤 객체를 yield할때, 앞에 오는 것들(put, call 등)을 이펙트라고 한다. 이펙트란, 미들웨어에 의해 수행되는 명령을 담고있는 간단한 자바스크립트 객체를 말한다. 미들웨어가 saga에 의해 yield 된 이펙트를 받을때, saga는 이펙트가 수행될때까지 정지되어 있다. saga에서 put을 통해 객체를 dispatch하면, 이 객체는 reducer로 가게된다. 두 saga를 모두 한번에 실행하게 해주기 위해, rootSaga를 이용해 사용한다. 1234567// 모든 Saga들을 한번에 시작하기 위한 단일 entry point 이다.export default function* rootSaga() &#123; yield all([ incrementAsync(), watchIncrementAsync() ])&#125; Redux-Saga 사용방법 Redux-Saga를 사용하는 방법은 다음과 같다. saga 미들웨어 작성(sagas.js) 비동기 처리를 위한 task 작성(제너레이터 함수) - worker saga 각각의 어떤 비동기 액션을 처리하기 위해 watch 함수를 작성하고, 그 안에 takeEvery 이펙트 펠어 함수를 사용 - watcher saga 모든 saga들을 한번에 실행하기 entry point 작성 - rootSaga 작성 rootSaga에 들어있는 두 saga가 호출된 결과의 배열을 yield 한다. 이것은 생성된 두 제너레이터가 병렬로 시작된다는 것을 의미. Saga 미들웨어를 Redux 스토어에 연결(main.js) applyMiddleware sagaMiddleware.run 등 작성 비동기 호출을 위한 이벤트 등록(Counter.js) saga 미들웨어 작성(sagas.js) 1234567891011121314151617181920212223// sagas.jsimport &#123; delay &#125; from &apos;redux-saga&apos;import &#123; put, takeEvery &#125; from &apos;redux-saga/effects&apos;// watcher sagaexport function* watchIncrementAsync() &#123; yield takeEvery(INCREMENT_ASYNC, incrementAsync)&#125;// worker sagafunction* incrementAsync(action) &#123; yield delay(2000) yield put(&#123; type: INCREMENT &#125;)&#125;// rootSagaexport default function* rootSaga() &#123; yield all([ incrementAsync(), watchIncrementAsync() ])&#125; Saga 미들웨어를 Redux 스토어에 연결(main.js) 123456789// main.jsimport &#123; createStore, applyMiddleware &#125; from &apos;redux&apos;import createSagaMiddleware from &apos;redux-saga&apos;import rootSaga from &apos;./sagas&apos;const sagaMiddleware = createSagaMiddleware()const store = ...sagaMiddleware.run(rootSaga) 비동기 호출을 위한 이벤트 등록(Counter.js) 1234567891011// Counter.jsconst Counter = (&#123; value, onIncrementAsync &#125;) =&gt; &lt;div&gt; &lt;button onClick=&#123;onIncrementAsync&#125;&gt; Increment after 2 second &lt;/button&gt; &lt;hr /&gt; &lt;div&gt; Counter: &#123;value&#125; times &lt;/div&gt; &lt;/div&gt; 비동기 호출을 처리하기 위해 Redux와 연결해주는 컨테이너 컴포넌트(CounterContainer.js) 12345678function render() &#123; ReactDOM.render( &lt;Counter value=&#123;store.getState()&#125; onIncrementAsync=&#123;() =&gt; action(&apos;INCREMENT_ASYNC&apos;)&#125; /&gt; )&#125;","categories":[{"name":"React","slug":"React","permalink":"https://cheonmro.github.io/categories/React/"}],"tags":[{"name":"Redux-Saga","slug":"Redux-Saga","permalink":"https://cheonmro.github.io/tags/Redux-Saga/"}]},{"title":"Redux","slug":"what-is-redux","date":"2019-03-16T09:16:43.000Z","updated":"2019-03-16T09:16:43.034Z","comments":true,"path":"2019/03/16/what-is-redux/","link":"","permalink":"https://cheonmro.github.io/2019/03/16/what-is-redux/","excerpt":"","text":"Redux란 무엇인가? Redux란, 상태관리에 대한 라이브러리로써, 애플리케이션의 모든 컴포넌트에 대한 중앙집중식 저장소 역할을 하며, 단순히 하나의 컴포넌트가 아닌 여러 개의 컴포넌트에 적용하는 상태들을 관리하는 곳이다. Redux를 왜 사용하는가? 리액트에서 기본적으로 부모 컴포넌트에서 상태를 관리하고, 자식으로 상태를 전달한다. 그러나, 앱 규모가 커지면, 데이터가 많고, 유지보수가 힘들다. Redux를 사용하면, 상태값을 컴포넌트에 종속시키지 않고, 상태 관리를 컴포넌트 바깥에서 관리가 가능하다. Redux 필수 개념 Action Action이란, 상태에 변화를 일으킬 때 참조할 수 있는 객체이다. Action 객체는 필수적으로 type 이라는 값을 가지고 있어야 한다. 예로, { type: ‘INCREMENT’ } 라는 객체를 전달 받으면, Redux Store는 ‘상태에 값을 더해줘야 하구나’라고 생각하고 Action을 참조하게 된다. type은 필수이고, 그 다음 값(예로 diff 등)은 option이다. Reducer Reducer란, 액션 객체를 받으면 액션의 타입에 따라 어떻게 상태를 업데이트 하는지, 업데이트 로직을 정의하는 함수이다. Redux Store에는 Reducer가 있다. Reducer에는 2개의 parameter가 존재한다. State: 현재 상태 Action: 액션 객체 상태가 변하면, 구독하고 있던 컴포넌트에게 알려서, 새로운 상태로 리렌더링함. Redux 3가지 규칙 각 애플리케이션에서는 단 1개의 Store를 사용한다. 상태는 읽기전용이다. 기존의 상태는 건들이지 않고, 새로운 상태를 생성하여 업데이트 해주는 방식으로 하면, 나중에 개발자 도구를 통해서 뒤로 돌릴 수도 있고, 다시 앞으로 돌릴 수도 있다. immutable.js를 사용하여 불변성을 유지하며 상태를 관리한다. 변화를 일으키는 함수, 즉, Reducer는 순수한 함수이다. 순수한 함수란, 동일한 인풋이라면 언제나 동일한 아웃풋이 나오는 함수이다. 즉, 똑같은 파라미터로 호출된 리듀서 함수는 언제나 똑같은 결과값을 반환해야 한다. 이전 상태는 안 건들이고, 변화를 일으킨 새로운 상태 객체를 만들어서 반환한다. 순수 하지 않은 것, 즉 실행 할 때마다 다른 결과값이 나오는 것들은 Reducer 함수가 아닌 바깥에서 처리해야 한다. 실행할 때마다 다른 결과값이 나오는 것들 New Date() 랜덤 숫자 생성 네트워크에 요청 Redux Architecture 출처: Redux Architecture Redux 파일 구조 Root.js - React 앱에 Redux 적용(최상위 컴포넌트) 컨테이너 컴포넌트(Store) CounterContainer.js - Redux와 연동하는 컴포넌트 프레젠테이셔널 컴포넌트(View) Counter.js - Counter 기능을 보여주는 View Store modules - 기능별로 액션 및 리듀서를 각 1개 파일에 작성(하나의 파일에 모두 작성하는 것을 Ducks 구조라고 한다.) counter.js - counter 기능과 관련된 액션 및 리듀서 index.js - 리듀서 합치는 파일 configure.js - Redux 스토어를 생성하는 함수를 모듈화하여 내보내는 파일 index.js - store를 생성하여 모듈화하여 내보내는 파일 이렇게 모듈화된 스토어는 브라우저 에서만 사용되는 스토어 서버사이드 렌더링을 하면, configure를 통하여 그때그때 만든다. 이렇게 모듈화된 스토어는 리액트 app을 초기설정할 때 사용 actionCreators.js 스토어를 불러오고, 각 모듈들에서 선언했던 액션 생성함수들을 불러와서 스토어의 dispatch와 미리 바인딩 작업을 한다. Redux Flow 출처: Redux Flow Redux 사용법 Redux install: npm install redux react-redux 리액트 앱에 Redux 적용하기(Root.js) 리액트 앱에 Redux를 적용할 때는, react-redux에 있는 Provider를 사용 기능을 보여줄 화면 구성(Counter.js) Counter 숫자화면 증가/감소 버튼 기능과 관련된 action과 reducer 작성(modules/counter.js) 액션 타입 정의 액션 생성 함수(ActionCreator) -&gt; createAction 사용 모듈의 초기 상태 정의 Reducer 정의: switch문 -&gt; handleActions 사용 여러 reducer가 있을 경우, 하나로 합치기(modules/index.js) store를 만드는 함수 configure 만들어서 내보내기(store/configure.js) Const store = createStore(modules) 위에서 만든 configure 함수를 사용하여 스토어를 만들고 내보내기(store/index.js) Redux와 연동할 컨테이너 컴포넌트 만들고, 그 안에 프레젠테이셔널 컴포넌트인 counter.js를 리턴해서 화면에 보여주기(containers/CounterContainer.js) 이 컴포넌트를 App에 불러와 화면에 보여주기(components/App.js) 컨테이너 컴포넌트를 Redux에 연결하기(containers/CounterContainer.js) mapStateToProps: props 값으로 넣어 줄 상태를 정의 컴포넌트에 state로 넣어줄 props를 반환 컴포넌트에 넣어줄 액션 함수들을 반환 mapDispatchToProps: props 값으로 넣어 줄 액션 함수들을 정의 Connect(): 컴포넌트를 Redux와 연동 할 때 사용","categories":[{"name":"React","slug":"React","permalink":"https://cheonmro.github.io/categories/React/"}],"tags":[{"name":"Redux","slug":"Redux","permalink":"https://cheonmro.github.io/tags/Redux/"}]},{"title":"Web Worker","slug":"webworker","date":"2019-03-10T13:08:23.000Z","updated":"2019-03-10T13:08:23.021Z","comments":true,"path":"2019/03/10/webworker/","link":"","permalink":"https://cheonmro.github.io/2019/03/10/webworker/","excerpt":"","text":"Web Worker란 무엇인가? Web Worker란, script 실행을 main thread(UI thread)가 아니라 background thread에서 실행할 수 있도록 해주는 API이다. *thread란, 어떤 프로그램 내에서 실행되는 흐름의 단위로, 보통 한 프로그램이 하나의 thread를 가지고 있다. 하나의 thread를 갖는다는 의미는, 어떤 이벤트(행위)가 발생했을 때, 그 하나의 이벤트를 처리할 때까지 다른 일은 못하게 된다는 뜻이다. 즉, 한번에 하나씩 처리한다는 뜻이다. 둘 이상의 thread를 동시에 실행하는 방식을 multi thread라고 한다. 웹 브라우저상의 javascript는 싱글 thread이기 때문에, 한번에 하나의 일 밖에 처리를 못한다. 그래서, 웹페이지에서 script가 실행되면, 해당 웹 페이지는 실행 중인 script가 종료될 때까지 응답 불가 상태, 즉 다른 일을 처리할 수가 없다. 이때, Web Worker를 사용하면, 시간이 오래 걸리는 javascript 작업 등을 background에서 처리하게 하여, 사용자의 UI를 방해하지 않고, 작업을 수행할 수 있다. 즉, script의 multi thread가 가능하게 된다. Web Worker를 왜 사용하는가? Web Worker를 사용하는 이유는, script 작업이 복잡하여 시간이 오래 걸리는 경우에도, 사용자의 다른 UI 작업에 방해를 주지 않기 위한 multi thread가 가능하기 때문이다. Web Worker의 활용 사용자의 UI 작업(UI thread)에 방해 없이 계속 수행해야하는 작업이 있을 경우 background에서 오랜시간 동안 작업해야 하는 경우 원격에 있는 리소스에 대한 액세스 작업(localstorage를 액세스 하는 경우)이 있을 경우 복잡한 수학적 계산 작업이 있을 경우 Web Worker를 사용하기 예전 상황 스크립트가 수행을 하는데 오랜 시간이 걸릴 때, 브라우저는 무반응 스크립트에 대한 경고를 보여줌 webworker를 이용한 이후에는 이 문제 해결 Web Worker를 어떻게 사용하는가? How Web Worker works 기본적인 사용방법 How Web Worker Works 출처: How Web Worker Works Main script가 실행되는 HTML 파일(웹페이지)과 background script가 실행되는 Worker가 있다. HTML 파일(웹페이지)과 Worker간의 데이터를 서로 주고 받으면서, script가 실행되는 방식이다. 이때, 데이터를 송신할 때는 postMessage 메서드를 사용하고, 데이터를 수신할 때는 onmessage 이벤트 핸들러를 사용한다. HTML 파일(웹페이지)에서 데이터를 송신하거나 수신할 수 있고, Worker에서도 데이터를 송신하거나 수신할 수 있다. postMessage는 다수의 window 창간의 정보교환을 목적으로 사용한다. workers는 DOM에 대한 접근 권한이 없어서 직접 웹페이지를 조작이 불가능하다. Web Worker의 기본적인 사용방법 코드상으로 Web Worker를 사용하기 위해서는 다음과 같이 해야한다. Worker 실행 파일(worker.js) 작성 Worker를 호출할 HTML 파일(웹페이지)에서 Worker를 호출 Worker 종료 Worker 실행 파일(worker.js) 작성 Worker가 실행할 script, 즉 javascript(worker.js) 파일을 만들고 작성한다. 이때, on message 이벤트 핸들러와 postMessage 메서드를 같이 작성한다. 왜냐하면, HTML 페이지로부터 전달 받을 데이터를 onmessage 이벤트 핸들러로 수신받아 처리한 후, postMessage 메서드로 다시 HTML 페이지에 전달해줘야 하기 때문이다. 123456789101112// worker.js//웹페이지로부터 메세지를 수신하여 시간이 오래 걸리는 작업 등을 처리onmessage = function(e)&#123; var receiveData = e.data; //워커를 호출한 곳(웹페이지)으로 결과 메시지를 전송 if(receiveData) &#123; var sendData = &quot;I&apos;m working for you&quot; postMessage(sendData) &#125;&#125; Worker를 호출할 HTML 파일(웹페이지)에서 Worker를 호출 New 연산자와 Worker 생성자 함수를 이용해 worker 인스턴스를 생성한다. 생성한 worker 인스턴스를 사용해서, Worker(worker.js)에 보낼 데이터를 postMessage 메서드를 이용해 작성하고, 후에, Worker(worker.js)에서 처리된 후 받을 데이터를 on message 이벤트 핸들러를 이용해 작성한다. 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script type=&quot;text/javascript&quot;&gt; var worker; function callWorker()&#123; if(!!window.Worker)&#123; //브라우저가 웹 워커를 지원하는지 확인 if(worker) worker.terminate(); //워커가 이미 존재하면 종료시킴 worker = new Worker(&quot;worker.js&quot;); //새로운 워커(객체)를 생성 //워커로부터 전달되는 메시지를 받음 worker.onmessage = function(e)&#123; alert(e.data); &#125;; //워커에게 메시지를 전달 worker.postMessage(&quot;What does Worker do?&quot;); &#125; else&#123; alert(&quot;The current browser does not support web worker api&quot;) &#125; &#125; function stopWorker()&#123; if(worker)&#123; worker.terminate(); alert(&quot;web worker has terminated&quot;); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;callWorker()&quot;&gt;Call web worker&lt;/button&gt; &lt;button onclick=&quot;stopWorker()&quot;&gt;Stop web worker&lt;/button&gt; &lt;br&gt; &lt;input type=&quot;text&quot;&gt; &lt;/body&gt;&lt;/html&gt; Worker 종료 Worker 인스턴스는 생성되고 종료될 때까지 계속해서 데이터를 받을 준비를 한다. 그래서, 브라우저나 컴퓨터의 자원을 돌려주기 위해 terminate() 메서드를 사용하여, worker를 반드시 종료해야 한다. 1worker.terminate();","categories":[{"name":"API","slug":"API","permalink":"https://cheonmro.github.io/categories/API/"}],"tags":[{"name":"Web Worker","slug":"Web-Worker","permalink":"https://cheonmro.github.io/tags/Web-Worker/"}]},{"title":"Ethereum Wallet 및 Keystore 파일 생성 및 암호화 원리","slug":"ethereum-keystore","date":"2019-03-09T16:03:55.000Z","updated":"2019-03-09T16:03:55.880Z","comments":true,"path":"2019/03/10/ethereum-keystore/","link":"","permalink":"https://cheonmro.github.io/2019/03/10/ethereum-keystore/","excerpt":"","text":"지갑이 생성되는 과정, 그리고 Keystore 파일 지갑을 생성하게 되면, 지갑의 비밀번호(pw), private key(pk), 그리고 지갑을 백업할 수 있는 keystore 파일을 받게된다. 지갑을 import 하는 등 지갑에 대한 본인 인증을 할 때는 2가지 방법 중 하나로 한다. pk를 이용하여 지갑에 대한 본인 인증을 한다. 문제는 pk(64 hex 문자열)를 기억하기 쉽지 않고, 관리 이슈도 있다. Keystore 파일과 pw를 이용하여 지갑에 대한 본인 인증을 한다. Keystore 파일은 pk의 암호화된 버전이다. pk를 pw와 암호화 알고리즘을 이용해 암호화하여 keystore 파일로 만드는 것이다. 이 방법이 더 좋은 2가지 이유가 있다. 안전성: 만약 사용자가 pk만 사용할 경우, 해커는 그 pk만 알아내면 사용자의 지갑은 해킹당하게 된다. 그런데, keystore 파일을 사용하면 해커는 추가로 pw까지 알아야 하므로 더 안전하다. 사용성: 복잡한 pk 대신 사용자들에게 익숙한 pw와 파일로 쉽게 지갑을 사용할 수 있다. keystore 파일 데이터 구조 keystore 파일의 데이터 구조는 다음과 같다. 123456789101112131415161718192021222324&#123; &quot;version&quot;: 3, &quot;id&quot;: &quot;4c07993f-ded2-405a-b83d-3b627eebe5cd&quot;, &quot;address&quot;: &quot;e449efddf8c9b174bbd40a0e0e1902d6eee72068&quot;, &quot;Crypto&quot;: &#123; &quot;cipher&quot;: &quot;aes-128-ctr&quot;, &quot;cipherparams&quot;: &#123; &quot;iv&quot;: &quot;7d416faf14c88bb124486f6cd851fa88&quot; &#125;, &quot;ciphertext&quot;:&quot;e99f6d0e37f33124ee3020fad01363d9d7500efce 913aede8a8119229b7a5f2e&quot;, &quot;kdf&quot;: &quot;scrypt&quot;, &quot;kdfparams&quot;: &#123; &quot;dklen&quot;: 32, &quot;salt&quot;: &quot;c47f395c9031233453168f01b5a9999a06ec97c829 a395ecd16e1ad37102ec7f&quot;, &quot;n&quot;: 8192, &quot;r&quot;: 8, &quot;p&quot;: 1 &#125;, &quot;mac&quot;: &quot;82078437ee94331c69125eef4001ff4b78b481e909a6 2a9ac25aa916237b70be&quot; &#125;&#125; 위 구조 중, Crypto 객체가 keystore 파일 암호화에 대한 정보이다. pw를 이용해 pk를 암호화/복호화하여 keystore 파일을 생성하는 원리 pw 암호화 출처: pw 암호화 과정 Pk를 암호화하기 위해 pw를 사용하는데, 이 pw를 직접 암호화키로 사용하지 않고, 이 pw를 암호화하여 암호화한 값을 암호화 키로 사용해서 pk를 암호화한다. 이때, pw를 암호화하는 알고리즘은 Scrypt인데, 비밀번호는 특성상 복호화할 필요가 없기 때문에 단반향 알고리즘 중 하나인 Scrypt를 사용한다. Keystore 파일에 들어갈 때는, kdf: ‘Scrypt’ 이런식으로 들어가는데, kdf는 암호화 알고리즘 이름을 말하고, Scrypt 알고리즘을 사용한다는 뜻이다. 참고로, kdfparams 들어가는 것 중, n은 CPU/memory 비용을 말한다. 즉, 값이 클수록 암호화 파워가 증가한다. pk 암호화 출처: pk 암호화 과정 Pk를 암호화하기 위해서는 좀 전에 pw를 암호화한 값을 암호화키로 사용하고, AES 알고리즘을 사용해서 pk를 암호화한다. pk는 복호화할 필요가 있으므로(pk는 거래를 할 때, 사용되므로) 양방향 알고리즘인 AES를 사용한다. Keystore 파일에 들어갈 때는, cipher: ‘aes-128-ctr’ 이런식으로 들어가는데, cipher는 암호화 알고리즘의 이름이고 aes-128-ctr 알고리즘을 사용한다는 뜻이다. Mac Mac은 keystone 파일을 사용할 때, 사용자가 입력한 pw의 일치여부를 확인하고, pk를 복호화해도 되는지 확인 용도로 사용한다. *참고로, 이더리움 wallet 만들어지는 순서 Pk로 public key 생성 Public key로 address 생성","categories":[{"name":"Ethereum","slug":"Ethereum","permalink":"https://cheonmro.github.io/categories/Ethereum/"}],"tags":[{"name":"Ethereum","slug":"Ethereum","permalink":"https://cheonmro.github.io/tags/Ethereum/"},{"name":"Keystore","slug":"Keystore","permalink":"https://cheonmro.github.io/tags/Keystore/"}]},{"title":"Lifecycle API","slug":"react-lifecycle-api","date":"2019-03-08T14:49:53.000Z","updated":"2019-03-08T14:49:53.408Z","comments":true,"path":"2019/03/08/react-lifecycle-api/","link":"","permalink":"https://cheonmro.github.io/2019/03/08/react-lifecycle-api/","excerpt":"","text":"Lifecycle API란 무엇인가? Lifecycle API란, 컴포넌트가 브라우저에서 생성될 때/업데이트 될 때/제거될 때, 호출되는 API이다. React 컴포넌트의 lifecycle은 다음과 같다. 출처: React 컴포넌트의 lifecycle React lifecycle API 3단계 Mounting: React 컴포넌트의 인스턴스가 생성되고, DOM에 삽입되는 과정의 lifecycle constructor componentWillMount render componentDidMount Updating: prop 또는 state의 변경으로 해당 컴포넌트가 re-rendering 되는 경우의 lifecycle componentWillReceiveProps(props가 변경될 때만) shouldComponentUpdate componentWillUpdate render componentDidUpdate Unmounting: 컴포넌트가 제거되는 과정의 lifecycle componentWillUnmount Mounting React 컴포넌트의 인스턴스가 생성되고, DOM에 삽입되는 과정의 lifecycle constructor 우선, lifecycle API 전에 컴포넌트가 새로 만들어질 때마다 제일 먼저 호출되는 것이 바로, constructor(컴포넌트 생성자 함수)이다. 참고로, 컴포넌트에서 state를 정의할 때는 2가지 방법 중 하나를 사용하면 된다. Class fields 문법 Constructor 사용 Class fields 문법 12345class InvestContainer extends Component &#123; state = &#123; number: 0 &#125;&#125; Constructor 사용 12345678class InvestContainer extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; number: 0 &#125; &#125;&#125; super(props)를 호출한 이유: ES6 class의 constructor에서 super 메소드를 사용하는 이유는, 자식 클래스에서 super 메소드를 사용함으로써 자식 class의 constructor 내부에서 부모 클래스의 constructor를 호출한다. 즉, 부모 클래스의 인스턴스를 생성해서, this를 사용할 수 있게 된다. 만약 super 키워드를 사용하지 않으면, this에 대한 참조 에러가 발생한다. 다시 말하면, super 메소드를 호출하기 이전에는 this를 참조할 수 없다는 것을 의미한다. 리액트에서 컴포넌트를 class형으로 만들때는, 모두 기본적으로 리액트에 있는 ‘Component’라는 부모 클래스로부터 상속받아 자식 클래스로 시작하게 된다. 그래서 자식 클래스에서는 super 메소드를 사용해서 , 부모 클래스(Component)의 constructor를 호출, 즉 Component 클래스의 인스턴스를 생성해서 this를 사용할 수 있게 되는 것이다. 그 다음에, this를 이용해 프로퍼티를 초기화할 수 있다. 이 방법이 더 복잡하므로, class fields 문법으로 주로 사용하는 것이 더 편리! componentWillMount 컴포넌트가 브라우저에 나타나기 전(화면에 나가기 전)에 호출되는 API이다. 사용 이유 mount 직전에 하고 싶은 것들(i.e. 방문자가 어떤 페이지를 방문했는지 Google Anlaytics에 신호할 때)이 있을 경우 사용 루트 컴포넌트에서 APP과 관련된 외부 API를 설정할 때 사용 React v16.3 이후부터는 해당 API가 deprecated 되어서, 사용하면 안된다.기존에 이 API에서 하던 것들을 constructor와 componentDidMount에서 처리 가능하다. componentDidMount 컴포넌트가 화면에 나타나게 됐을 때, 호출되는 API이다. 즉, 컴포넌트가 생성되어 DOM까지 render가 다 된 후, 실행된다. 사용 이유 DOM에 대한 접근이 필요한 모든 설정을 수행할 때 사용(DOM의 속성을 읽거나 직접 변경하는 작업 등) 해당 컴포넌트에서 필요로하는 데이터를 요청하기 위해 사용(axios, fetch 등을 통한 ajax 요청) 외부 라이브러리 연동 Updating 컴포넌트의 업데이트는 props 또는 state의 변화에 따라 결정된다. componentWillReceiveProps 컴포넌트가 새로운 props를 받게됐을 때 호출되는 API이다. 즉, 새로운 props로 어떠한 작업을 수행하기 전에, 이 새로운 props를 인자로하여 이 API가 호출된다. 새로 받게될 props는 nextProps로 조회 가능하고, this.props는 현재의 props를 말한다. 사용 이유 props를 받아서 state를 변경해야 하는 경우 유용하다. 다음과 같이 작성할 수 있다.12345componentWillReceiveProps(nextProps) &#123; if (this.props.percent !== nextProps.percent) &#123; this.setUpPercent(nextProps.percent); &#125;&#125; 이 API는 초기 렌더링시에는 호출되지 않는다. shouldComponentUpdate 컴포넌트 업데이트 직전에 호출되는 API이다. 사용 이유 컴포넌트를 최적화하는 작업에 사용 즉, 해당 컴포넌트의 re-rendering를 제어할 때 사용 이 API는 항상 boolean(true 또는 false)을 반환한다. 즉, 해당 컴포넌트를 re-rending할지 말지를 결정하는 API이다. 컴포넌트를 최적화하기 위해서는, 필요없는 re-rending을 막아야 하고, 그러기 위해서는 props 또는 state가 변경되었을 때만, re-rendering 하게끔 이 API안에서 코드를 작성하면 된다. 예를 들어, 다음과 같이 작성하면 된다.1234shouldComponentUpdate(nextProps, nextState) &#123; return this.props.engagement !== nextProps.engagement || nextState.input !== this.state.input;&#125; componentWillUpdate 이 API는 update가 발생하기 전 어떤 작업이 필요한 경우 사용하는 API로써, shouldComponentUpdate에서 true를 반환했을 때만, 호출되는 API이다. shouldComponentUpdate가 이미 사용되고 있는 컴포넌트에서 componentWillReceiveProps를 대신 사용한다. 이 API가 호출되고 난 다음에는 render() 함수가 호출된다. 사용 이유 애니메이션 효과르 초기화할 때 사용 이벤트 리스너를 없앨 때 사용 이 API에서는 this.setState()를 사용하면 무한 루프가 일어나게 되므로 사용하면 안된다. componentDidUpdate componentWillUpdate 이후, render() 함수가 호출된 뒤에 호출되는 API이다.이 시점에서는 this.props와 this.state가 새로 변경되었고, 대신에 이전 값들인 prevProps와 prevState를 조회할 수 있다. 사용 이유 props 또는 state에 따라서 DOM을 업데이트 할 때 사용 Unmounting componentWillUnmount 컴포넌트가 소멸된 시점에(DOM에서 삭제된 후) 실행되는 API이다.컴포넌트 내부에서 타이머나 비동기 API를 사용하고 있을 때, 이를 제거하기에 유용하다. 사용 이유 등록했었던 이벤트 제거 컴포넌트 내부에서 타이머나 비동기 API를 사용하고 있을 때, 이를 제거하기에 유용하다. setTimeout 함수를 사용했다면, clearTimeout을 통하여 제거 React v16.3 이후에 변경된 부분 몇개 lifecycle API가 변경된 부분이 있다. 아래의 링크에서 확인해보자. 출처: React v16.3 이후의 lifecycle","categories":[{"name":"React","slug":"React","permalink":"https://cheonmro.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://cheonmro.github.io/tags/React/"},{"name":"Lifecycle API","slug":"Lifecycle-API","permalink":"https://cheonmro.github.io/tags/Lifecycle-API/"}]},{"title":"Modules","slug":"modules","date":"2019-01-01T15:05:11.000Z","updated":"2019-01-01T15:05:11.846Z","comments":true,"path":"2019/01/02/modules/","link":"","permalink":"https://cheonmro.github.io/2019/01/02/modules/","excerpt":"","text":"Module이란 무엇인가? 모듈이란, 애플리케이션을 구성하는 개별적 요소로서, 재사용이 가능한 코드 조각을 말한다. 모듈은 세부 사항을 캡슐화하고, 공개가 필요한 API만을 외부에 노출한다. 일반적으로, 각 모듈은 파일 단위로 분리되어 있고, 애플리케이션은 필요에 따라 모듈을 로드하여 재사용한다. 즉, 모듈은 애플리케이션에 분리되어 개별적으로 존재하다가 애플리케이션의 로드에 의해 비로소 애플리케이션의 로드에 의해 비로소 애플리케이션의 일원이 된다. 모듈은 기능별로 분리되어 작성되므로, 코드의 단위를 명확히 분리하여 애플리케이션을 구성할 수 있고, 재사용에 좋기 때문에, 개발을 효율적으로 할 수 있고, 유지보수 또한 좋다. ES6에서 모듈을 사용할 때, export와 import 두 개의 키워드를 사용한다. Module 사용의 이점 Javascript 애플리케이션을 여러 개의 파일로 분할하여 작성할 수 있다. 재사용이 가능한 코드를 작성하기 때문에, 개발 효율과 유지보수에 좋다. Export 모듈은 기본적으로 독립적인 스코프를 가지고 있어서, 모듈안에 선언된 모든 것들은 해당 모듈 내에서만 참조 할 수 있다. 어떤 모듈안에서 선언한 항목(변수/함수/클래스 등)을 외부에 공개하여 다른 모듈들이 사용할 수 있게 하려면, export를 해야한다. 이때, 선언된 변수, 함수, 그리고 클래스 모두를 export 할 수 있고, 키워드는 export를 사용한다. 123456789101112131415// module.js// 변수의 공개export const num = 10;// 함수의 공개export function square(x) &#123; return x * x;&#125;// 클래스의 공개export class Person &#123; constructor(name) &#123; this.name = name; &#125;&#125; 각 선언문(변수/함수/클래스) 앞에 export를 붙이는 대신, export 대상을 하나의 객체로 구성하여, 한번에 export를 할 수 있다.123456789101112131415// module.jsconst num = 10;function square(x) &#123; return x * x;&#125;class Person &#123; constructor(name) &#123; this.name = name; &#125;&#125;// 변수, 함수 클래스를 하나의 객체로 구성하여 공개export &#123; num, square, Person &#125;; Import 다른 모듈에서 어떤 export된 모듈을 가져와 사용하려면, 키워드 import를 사용해 로드하여 사용할 수 있다.1234567// main.js// 같은 폴더 내의 module.js 모듈을 로드. 확장자 js는 생략 가능.import &#123; num, square, Person &#125; from &apos;./module&apos;;console.log(num); // 10console.log(square(10)); // 100console.log(new Person(&apos;Lee&apos;)); // Person &#123; name: &apos;Lee&apos; &#125; 각각의 이름을 지정하지 않고 하나의 이름으로 한꺼번에 import할 수도 있다. 이때 import되는 항목은 as 뒤에 지정한 이름의 변수에 할당된다.1234567// main.js// lib라는 이름으로 임포트import * as lib from &apos;./module&apos;;console.log(module.num); // 10console.log(module.square(10)); // 100console.log(new module.Person(&apos;Lee&apos;)); // Person &#123; name: &apos;Lee&apos; &#125; 이름을 변경하여 import할 수도 있다.123456// main.jsimport &#123; num as n, square as sq, Person as P &#125; from &apos;./module&apos;;console.log(n); // 10console.log(sq(2)); // 4console.log(new P(&apos;Kim&apos;)); // Person &#123; name: &apos;Kim&apos; &#125; 모듈에서 하나만을 export할 때는 default 키워드를 사용할 수 있다. 다만, default를 사용하는 경우, var, let, const는 사용할 수 없다.123456// lib.jsfunction (x) &#123; return x * x;&#125;export default; 위 코드를 아래와 같이 축약 표현할 수 있다.1234// module.jsexport default function (x) &#123; return x * x;&#125; default 키워드와 함께 export한 모듈은 {} 없이 임의의 이름으로 import한다.1234// main.jsimport square from &apos;./module&apos;;console.log(square(3)); // 9 Vue에서의 Modules 사용하는 방법","categories":[{"name":"ES6","slug":"ES6","permalink":"https://cheonmro.github.io/categories/ES6/"}],"tags":[{"name":"Modules","slug":"Modules","permalink":"https://cheonmro.github.io/tags/Modules/"}]},{"title":"Arrow Function","slug":"arrow-function","date":"2019-01-01T13:41:36.000Z","updated":"2019-01-01T13:41:36.535Z","comments":true,"path":"2019/01/01/arrow-function/","link":"","permalink":"https://cheonmro.github.io/2019/01/01/arrow-function/","excerpt":"","text":"화살표 함수(Arrow Function)란 무엇인가? 화살표 함수는 기존의 function 키워드 대신 화살표(=&gt;)를 사용하여, 보다 간단히 함수를 선언하는 방식이다. 문법은 다음과 같다.12345678910111213141516// 매개변수 지정 방법 () =&gt; &#123; ... &#125; // 매개변수가 없을 경우 x =&gt; &#123; ... &#125; // 매개변수가 한 개인 경우, 소괄호를 생략할 수 있다.(x, y) =&gt; &#123; ... &#125; // 매개변수가 여러 개인 경우, 소괄호를 생략할 수 없다.// 함수 몸체 지정 방법x =&gt; &#123; return x * x &#125; // single line blockx =&gt; x * x // 함수 몸체가 한줄의 구문이라면 중괄호를 생략할 수 있으며 암묵적으로 return된다. 위 표현과 동일하다.() =&gt; &#123; return &#123; a: 100 &#125;; &#125;() =&gt; (&#123; a: 100 &#125;) // 위 표현과 동일하다. 객체는 반환할 때, 소괄호를 사용한다.() =&gt; &#123; // multi line block. const x = 100; return x * x;&#125;; 화살표 함수의 호출 화살표 함수는 익명 함수로만 사용할 수 있기 때문에, 화살표 함수를 호출하기 위해서는 함수 표현식을 사용해야 한다.1234567// ES5var pow = function (x) &#123; return x * x; &#125;;console.log(pow(5)); // 25// ES6const pow = x =&gt; x * x;console.log(pow(5)); // 25 콜백함수에서도 화살표 함수를 사용할 수 있다.12345678910111213// ES5var arr = [2, 4, 6];var pow = arr.map(function (x) &#123; // x는 요소값 return x * x;&#125;);console.log(pow); // [ 4, 16, 36 ]// ES6const arr = [2, 4, 6];const pow = arr.map(x =&gt; x * x);console.log(pow); // [ 4, 16, 36 ] 화살표 함수와 function으로 생성한 함수의 차이점 두 방식의 가장 큰 차이점은 this 이다. function 함수: 생성자 함수와 객체의 메소드를 제외한 모든 함수(내부 함수, 콜백 함수 포함) 내부의 this는 전역 객체를 가리킨다. 화살표 함수: 언제나 상위 스코프의 this를 가리킨다. function 키워드로 생성한 함수의 this Javascirpt에서의 this는 함수를 호출할 때 함수가 어떻게 호출되었는지에 따라 this에 바인딩할 객체가 동적으로 결정된다. Javascript에서의 this를 참고한다. 생성자 함수와 객체의 메소드를 제외한 모든 함수(내부 함수, 콜백 함수 포함) 내부의 this는 전역 객체를 가리키기 때문이다. 즉, 콜백 함수 내부의 this는 전역 객체 window를 가리킨다.12345678910111213function Prefixer(prefix) &#123; this.prefix = prefix;&#125;Prefixer.prototype.prefixArray = function (arr) &#123; // (1) return arr.map(function (x) &#123; return this.prefix + &apos; &apos; + x; // (2) &#125;);&#125;;var pre = new Prefixer(&apos;Hi&apos;);console.log(pre.prefixArray([&apos;Ro&apos;, &apos;Park&apos;])); 위치에 따라 this의 값은 달라진다. (1): 여기서, this는 생성자 함수 Prefixer가 생성한 객체, 즉 생성자 함수의 인스턴스(위 예제의 경우 pre)이다. (2): 여기서, this는 전역 객체 window를 가리킨다. 콜백 함수 내부의 this가 메소드를 호출한 객체(생성자 함수의 인스턴스)를 가리키게 하는 3가지 방법이 있다. that = this map(func, this) bind(this) that = this 12345678910111213function Prefixer(prefix) &#123; this.prefix = prefix;&#125;Prefixer.prototype.prefixArray = function (arr) &#123; var that = this; // this: Prefixer 생성자 함수의 인스턴스 return arr.map(function (x) &#123; return that.prefix + &apos; &apos; + x; &#125;);&#125;;var pre = new Prefixer(&apos;Hi&apos;);console.log(pre.prefixArray([&apos;Lee&apos;, &apos;Kim&apos;])); map(func, this) 123456789101112function Prefixer(prefix) &#123; this.prefix = prefix;&#125;Prefixer.prototype.prefixArray = function (arr) &#123; return arr.map(function (x) &#123; return this.prefix + &apos; &apos; + x; &#125;, this); // this: Prefixer 생성자 함수의 인스턴스&#125;;var pre = new Prefixer(&apos;Hi&apos;);console.log(pre.prefixArray([&apos;Lee&apos;, &apos;Kim&apos;])); bind(this) 123456789101112function Prefixer(prefix) &#123; this.prefix = prefix;&#125;Prefixer.prototype.prefixArray = function (arr) &#123; return arr.map(function (x) &#123; return this.prefix + &apos; &apos; + x; &#125;.bind(this)); // this: Prefixer 생성자 함수의 인스턴스&#125;;var pre = new Prefixer(&apos;Hi&apos;);console.log(pre.prefixArray([&apos;Ro&apos;, &apos;Park&apos;])); 화살표 함수의 this 화살표 함수의 this는 언제나 상위 스코프의 this를 가리킨다.1234567891011function Prefixer(prefix) &#123; this.prefix = prefix;&#125;Prefixer.prototype.prefixArray = function (arr) &#123; // this는 상위 스코프인 prefixArray 메소드 내의 this를 가리킨다. return arr.map(x =&gt; `$&#123;this.prefix&#125; $&#123;x&#125;`);&#125;;const pre = new Prefixer(&apos;Hi&apos;);console.log(pre.prefixArray([&apos;Ro&apos;, &apos;Park&apos;])); 화살표 함수는 call, applay, bind 메소드를 사용하여 this를 변경할 수 없다.123456window.x = 1;const normal = function () &#123; return this.x; &#125;;const arrow = () =&gt; this.x;console.log(normal.call(&#123; x: 10 &#125;)); // 10console.log(arrow.call(&#123; x: 10 &#125;)); // 1 화살표 함수를 사용하면 안되는 경우 화살표 함수는 Lexical this를 지원하므로 콜백 함수로 사용하기 편리하지만, 화살표 함수를 사용하지 말아야 하는 경우도 있다. 메소드 메소드를 정의할 때는, 화살표 함수를 사용하면 안된다.123456const person = &#123; name: &apos;Ro&apos;, sayHi: () =&gt; console.log(`Hi $&#123;this.name&#125;`)&#125;;person.sayHi(); // Hi undefined 위와 같이, sayHi라는 메소드를 정의할 때 화살표 함수를 사용하게 되면, 화살표 함수 내부의 this는 상위 컨택스트인 전역 객체 window를 가리킨다. ES6의 축약 메소드 표현을 사용하면, 다음과 같이 작성할 수 있다.12345678const person = &#123; name: &apos;Ro&apos;, sayHi() &#123; // === sayHi: function() &#123; console.log(`Hi $&#123;this.name&#125;`); &#125;&#125;;person.sayHi(); // Hi Ro prototype prototype에 할당하기 위한 메소드를 정의할 때는, 화살표 함수를 사용하면 안된다.1234567const person = &#123; name: &apos;Ro&apos;,&#125;;Object.prototype.sayHi = () =&gt; console.log(`Hi $&#123;this.name&#125;`);person.sayHi(); // Hi undefined prototype에 메소드를 할당하는 경우, 일반 함수를 사용해야 한다.123456789const person = &#123; name: &apos;Ro&apos;,&#125;;Object.prototype.sayHi = function() &#123; console.log(`Hi $&#123;this.name&#125;`);&#125;;person.sayHi(); // Hi Ro 생성자 함수 생성자 함수를 사용할 때는, 화살표 함수를 사용하면 안된다. 생성자 함수는 prototype 프로퍼티를 가지며 prototype 프로퍼티가 가리키는 프로토타입 객체의 constructor를 사용한다. 그러나, 화살표 함수는 prototype 프로퍼티를 가지고 있지 않다.123456const Foo = () =&gt; &#123;&#125;;// 화살표 함수는 prototype 프로퍼티가 없다console.log(Foo.hasOwnProperty(&apos;prototype&apos;)); // falseconst foo = new Foo(); // TypeError: Foo is not a constructor addEventListener 함수의 콜백 함수 addEventListener 함수의 콜백 함수를 사용할 때는, 화살표 함수를 사용하면 안된다. 만약, addEventListener 함수의 콜백 함수를 화살표 함수로 정의하면, 화살표 함수 내의 this는 상위 컨택스트인 전역 객체 window를 가리킨다.123456var button = document.getElementById(&apos;myButton&apos;);button.addEventListener(&apos;click&apos;, () =&gt; &#123; console.log(this === window); // =&gt; true this.innerHTML = &apos;Clicked button&apos;;&#125;); 그래서, addEventListener 함수의 콜백 함수를 사용할 때는, 일반 함수인 function 키워드를 사용해야 한다. 일반 함수로 정의된 addEventListener 함수의 콜백 함수 내부의 this는 이벤트 리스너에 바인딩된 요소(currentTarget)를 가리킨다.123456var button = document.getElementById(&apos;myButton&apos;);button.addEventListener(&apos;click&apos;, function() &#123; console.log(this === button); // =&gt; true this.innerHTML = &apos;Clicked button&apos;;&#125;); Vue에서 화살표 함수 사용방법 Vue에서 화살표 함수는 기본적으로 ES6에서의 화살표 함수와 동일하다. 화살표 함수의 사용 여부에 대한 대표적인 경우는 2가지이다. 메소드를 정의할 때 콜백함수를 정의할 때 Vue에서 메소드를 정의할 때 Vue에서 메소드를 정의할 때는, 화살표 함수를 사용하면 안된다. 즉, function 키워드를 사용하는 일반 함수로 정의해야 한다.12345678910111213141516171819&lt;template&gt; &lt;div&gt; &lt;input type=&quot;text&quot; v-model=&quot;newTodo&quot;&gt; &lt;button v-on:click=&quot;addTodo&quot;&gt;add&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data: () =&gt; (&#123; newTodo: &apos;&apos; &#125;), methods: &#123; addTodo: function () &#123; console.log(this.newTodo); // input에서 입력한 값을 가져옴 &#125; &#125;&#125;&lt;/script&gt; methods에서 addTodo를 정의할 때, function 키워드를 사용하면, 이 함수내의 this는 Vue 인스턴스를 가리킨다. 그래서, this.newTodo의 값을 가져올 수 있다. 만약, 화살표 함수로 addTodo를 정의하면 어떻게 될까?12345678910111213141516171819&lt;template&gt; &lt;div&gt; &lt;input type=&quot;text&quot; v-model=&quot;newTodo&quot;&gt; &lt;button v-on:click=&quot;addTodo&quot;&gt;add&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data: () =&gt; (&#123; newTodo: &apos;&apos; &#125;), methods: &#123; addTodo: () =&gt; &#123; console.log(this.newTodo); // undefined &#125; &#125;&#125;&lt;/script&gt; 화살표 함수로 addTodo를 정의하면, 이 함수내의 this는 전역객체 window를 가리킨다. 그래서 값이 undefined가 된다. 대신, ES6의 축약 메소드 표현을 사용하면, 다음과 같이 작성할 수 있다.12345methods: &#123; addTodo () &#123; console.log(this.newTodoItem) // input에서 입력한 값을 가져옴 &#125;&#125; Vue에서 콜백 함수를 정의할 때 Vue에서 콜백 함수를 정의할 때, 화살표 함수를 사용하면, 정의된 콜백 함수내의 this는 Vue의 인스턴스를 가리킨다.123456789101112131415161718&lt;script&gt;export default &#123; data: &#123; size: &apos;small&apos;, items: [ &#123; size: &apos;small&apos; &#125;, &#123; size: &apos;large&apos; &#125; ] &#125;, computed: &#123; filterBySize() &#123; return this.items.filter((item) =&gt; &#123; return item.size === this.size; // this는 Vue의 인스턴스를 가리킴 &#125;); &#125; &#125;&#125;&lt;/script&gt; 만약, 콜백 함수를 정의할 때, function 키워드를 사용하면, 정의된 콜백 함수내의 this는 상위 컨택스트, 즉 전역 객체 window를 가리킨다.12345678910111213141516171819&lt;script&gt;export default &#123; data: &#123; size: &apos;small&apos;, items: [ &#123; size: &apos;small&apos; &#125;, &#123; size: &apos;large&apos; &#125; ] &#125;, computed: &#123; filterBySize() &#123; let size = this.size // 여기서 this는 Vue 인스턴스를 가리키기 때문에, 미리 size라는 변수에 위 data의 size의 값을 할당 return this.items.filter(function(item) &#123; return item.size === size; &#125;); &#125; &#125;&#125;&lt;/script&gt; 결론: Vue에서의 화살표 함수 및 일반 함수 사용 방법 메소드를 정의할 때는, 일반 함수를 사용한다. 이때, funtion 키워드르 안쓰고 싶다면, ES6의 축약 메소드 표현을 사용해서, 간단히 작성하면 된다. 콜백 함수를 정의할 때는, 화살표 함수를 사용한다. 이때, 정의된 콜백 함수내의 this는 해당 컨택스트, 즉 정의된 콜백 함수를 가지고 있는 Vue 인스턴스를 가리킨다.","categories":[{"name":"ES6","slug":"ES6","permalink":"https://cheonmro.github.io/categories/ES6/"}],"tags":[{"name":"Arrow Function","slug":"Arrow-Function","permalink":"https://cheonmro.github.io/tags/Arrow-Function/"}]},{"title":"Computed vs. Methods vs. Watch","slug":"computed-methods","date":"2019-01-01T11:26:03.000Z","updated":"2019-01-01T11:26:03.785Z","comments":true,"path":"2019/01/01/computed-methods/","link":"","permalink":"https://cheonmro.github.io/2019/01/01/computed-methods/","excerpt":"","text":"Computed vs. Methods 핵심은 캐싱(값의 저장)이 있냐 없냐에 차이다. 공통점: 둘 다 인스턴내에서 함수를 정의하는 부분이고, 데이터가 변동됨에 따라 안에 있는 함수를 재호출하게 된다.차이점: 데이터가 변동되지 않는다고 가정했을 때이다. Computed: 종속 대상의 값이 저장(캐싱) 되어, 이미 계산되어진 값을 가져온다. 종속된 대상이 변경될 때만, 함수를 실행하고, 종속 대상이 변경되지 않으면, computed를 여러번 요청해도 계산을 다시 하지 않고, 계산되어 있는(computed) 결과를 즉시 반환한다. 데이터 변동이 없는 상태에서, 이전의 계산된 값을 캐시해 두었다가 함수 호출시 재사용한다. methods: 렌더링을 다시 할때마다, 항상 함수를 실행하여 함수의 로직에 결과물을 반환한다. 사용할때마다, 함수의 계산을 다시 한다. 캐싱이 왜 필요할까? computed의 속성이 계산이 많이 걸리는 함수라고 하자. 만약, 캐싱을 하지 않으면, computed의 속성의 getter 함수를 꼭 필요한 것보다 더 많이 실행하게 된다. 그래서, 캐싱을 원하지 않으면, methods를 사용한다. 결론 데이터가 자주 변동되지 않으면, 비용적인 면에서는 computed가 좋다. 데이터가 수시로 없데이트 되면, 계속해서 캐시를 저장하는 computed보다 methods가 더 좋다. 그래서, html에서는 computed는 변수처럼 쓰이고, methods는 함수처럼 쓰인다.예) parse 함수 Computed: parse를 그대로 사용한다. Methods: parse() 이런식으로 사용한다. Computed vs. Watch Watch: 감시할 데이터를 지정하고 그 데이터가 바뀌면 이런 함수를 실행하라는 방식으로 소프트웨어 공학에서 이야기하는 ‘명령형 프로그래밍’ 방식 Computed: 계산해야 하는 목표 데이터를 정의하는 방식으로 소프트웨어 공학에서 이야기하는 ‘선언형 프로그래밍’ 방식 Computed/Watch는 언제, 왜 사용해야 할까?","categories":[{"name":"Vue","slug":"Vue","permalink":"https://cheonmro.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://cheonmro.github.io/tags/Vue/"},{"name":"Computed","slug":"Computed","permalink":"https://cheonmro.github.io/tags/Computed/"},{"name":"Methods","slug":"Methods","permalink":"https://cheonmro.github.io/tags/Methods/"}]},{"title":"Vue에서 Routing 사용하는 방법","slug":"vue-routing","date":"2019-01-01T10:37:12.000Z","updated":"2019-01-01T10:37:12.175Z","comments":true,"path":"2019/01/01/vue-routing/","link":"","permalink":"https://cheonmro.github.io/2019/01/01/vue-routing/","excerpt":"","text":"Routing(라우팅)이란 무엇인가? 라우팅이란, 웹 페이지간의 이동 방법을 말하며, 웹 앱의 형식 중 하나인 SPA에서 주로 사용한다. 라우팅의 장점은 화면 간의 전환이 매끄러워, UX를 향상 시킬 수 있다. 일반적인 웹(MPA)에서는 특정 행동(링크 클릭, 또는 특정 이벤트)를 한 후, 페이지를 이동하게 되면, 흰색의 빈 페이지가 깜박거린 후, 이동된 화면이 나타나게 된다. 이런 부분들을 라우팅으로 처리하면 깜빡러미 없이 매끄럽게 화면이 전환될 수 있다. Vue에서의 라우팅 Vue 라우터는 Vue에서 라우팅을 할 수 있도록 지원하는 공식 라이브러리이다. Vue에서 라우팅 설치 및 등록 &lt;설치&gt; Npm install vue-router &lt;등록&gt; 123Import VueRouter from ‘vue-router’Vue.use(VueRouter) 기본적인 Vue Routing 사용법 Vue 라우터 라이브러리를 사용하면, 2개의 tag를 사용한다. &lt;router-link to=“url&quot;&gt;: 페이지 이동 태그로, 화면에서는 &lt;a&gt;로 표시되며 클릭하게되면, to속성에 입력한 URL로 이동 &lt;router-view&gt;: 페이지 표시 태그로, 변경되는 URL에 따라 해당 컴포넌트를 출력해주는 영역 기본적인 라우팅을 만들어보자. 위에 버튼 두개가 있는데, 왼쪽은 todo 페이지로 이동, 오른쪽은 user 페이지로 이동하는 라우팅을 만들어 보자. (1) vue-router를 설치하고, router.js를 만들어 다음과 같이 작성한다.123456789101112131415161718// router.jsimport Vue from &apos;vue&apos;import VueRouter from &apos;vue-router&apos;import Todo from &apos;./components/Todo.vue&apos;import User from &apos;./components/User.vue&apos;Vue.use(VueRouter)const router = new VueRouter(&#123; mode: &apos;history&apos;, routes: [ &#123; path: &apos;/&apos;, component: Todo &#125;, &#123; path: &apos;/user&apos;, component: User, &#125; ]&#125;) Todo와 User 컴포넌트를 만들고, import 한뒤, router 인스턴스를 생성하고, path와 path에 맞는 컴포넌트를 맵핑한다. ‘History’ mode는 기본적으로 url에 #이 들어가 있는데, 이를 제거해 준다. (2) main.js에 등록하여, 전역에서 사용할 수 있게 한다.12345678910111213// main.jsimport Vue from &apos;vue&apos;import App from &apos;./App.vue&apos;import store from &apos;./store&apos;import router from &apos;./router&apos;Vue.config.productionTip = falsenew Vue(&#123; store, router, render: h =&gt; h(App),&#125;).$mount(&apos;#app&apos;) (3) App.vue에 라우터 링크를 추가한다.123456789101112// App.vue&lt;section&gt; &lt;div&gt; &lt;router-link to=&quot;/&quot;&gt;&lt;button&gt;Go to Todo page&lt;/button&gt;&lt;/router-link&gt; &lt;br&gt; &lt;router-link to=&quot;/user&quot;&gt;&lt;button&gt;Go to User page&lt;/button&gt;&lt;/router-link&gt; &lt;/div&gt;&lt;/section&gt;&lt;br&gt;&lt;router-view&gt;&lt;/router-view&gt; 이렇게 되면, 각 버튼을 클릭하면, 각 버튼에 해당하는 path로 이동하여, path에 맵핑된 컴포넌트를 화면에 뿌려준다. Nested 라우팅 Nested(중첩된) 라우터는 라우터로 페이지를 이동할 때, 최소 2개 이상의 컴포넌트를 화면에 나타내는 것을 말한다.상위 컴포넌트 1개와 하위 컴포넌트 N개로 구성할 수 있다. 예를 들어, User 페이지에서 url에 따라, User의 Profile과 User의 Post를 각각 보여주는 라우터를 만들어보자. (1) 두 개의 컴포넌트 UserProfile과 UserPost를 만들고, 상위 컴포넌트인 User에 그 하위 컴포넌트로 UserProfile과 UserPost를 라우팅으로 등록한다.123456789101112131415161718192021222324252627282930// router.jsimport Vue from &apos;vue&apos;import VueRouter from &apos;vue-router&apos;import Todo from &apos;./components/Todo.vue&apos;import User from &apos;./components/User.vue&apos;import UserProfile from &apos;./components/UserProfile.vue&apos;import UserPost from &apos;./components/UserPost.vue&apos;Vue.use(VueRouter)const router = new VueRouter(&#123; mode: &apos;history&apos;, routes: [ &#123; path: &apos;/&apos;, component: Todo &#125;, &#123; path: &apos;/user&apos;, component: User, children: [ &#123; path: &apos;userProfile&apos;, component: UserProfile &#125;, &#123; path: &apos;userPost&apos;, component: UserPost &#125; ] &#125; ]&#125;) (2) 상위 컴포넌트인 User.vue에 다음과 같이 링크를 추가한다. 이때, 상위 컴포넌트에 &lt;router-view&gt;&lt;/router-view&gt;를 추가하여, 상위 컴포넌트내에서 그 하위 컴포넌트들이 화면에 보이게 한다.123456789101112131415161718// User.vue&lt;template&gt; &lt;div class=&quot;user&quot;&gt; &lt;p&gt;This is User page.&lt;/p&gt; &lt;br&gt; &lt;router-link to=&quot;/user/userProfile&quot;&gt;UserProfile 컴포넌트로 이동&lt;/router-link&gt; &lt;br&gt; &lt;router-link to=&quot;/user/UserPost&quot;&gt;UserPost 컴포넌트로 이동&lt;/router-link&gt; &lt;br&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; 동적 라우팅 동적 라우팅이란, 일정한 패턴의 URI 경로를 하나의 컴포넌트에 연결하는 방법이다. 일정한 패턴의 URI란, 예를 들어, projects 페이지에서 각 페이지별로 상세하게 보고 싶은데, 이때 URI를 projects/1, projects/2 이런식으로 각 프로젝트를 id로 구별하는 것을 말한다. 이를 하나의 컴포넌트(Projects.vue)로 연결하여 사용한다. 하나의 메인 페이지에서 어떤 링크(버튼 등)를 클릭하면, projects 페이지가 나오고, 그 projects 페이지에는 여러개의 프로젝트들이 보여진다. 그리고, 각 프로젝트를 클릭하면, 각 프로젝트에 대한 상세 정보가 나오게 한다. 이때, 클릭 시 라우팅의 URI는 projects/1 이런식으로 지정하여 만든다. (1) 우선, store.js에서 dummy 데이터를 만들자.1234567891011121314151617181920212223242526272829// store.jsimport Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;import axios from &apos;axios&apos;import VueAxios from &apos;vue-axios&apos;Vue.use(Vuex);Vue.use(VueAxios, axios);export default new Vuex.Store(&#123; state: &#123; projects: [ &#123; id: 1, text: &apos;vue&apos;, completed: false &#125;, &#123; id: 2, text: &apos;react&apos;, completed: false &#125; ] &#125;, actions: &#123; &#125;, mutations: &#123; &#125;&#125;) (2) router.js에서 Projects에 대한 path를 등록하고, 이에 대한 children으로써, Project에 대한 path를 등록한다. 이때, path는 ‘:id’로 등록한다.1234567891011121314151617181920212223242526// router.jsimport Vue from &apos;vue&apos;import VueRouter from &apos;vue-router&apos;import Projects from &apos;./components/Projects.vue&apos;import Project from &apos;./components/Project.vue&apos;Vue.use(VueRouter)const router = new VueRouter(&#123; mode: &apos;history&apos;, routes: [ &#123; path: &apos;/projects&apos;, component: Projects, children: [ &#123; name: &apos;project&apos;, path: &apos;:id&apos;, component: Project &#125; ] &#125; ]&#125;)export default router (3) App.vue에서 Projects 페이지로 이동하는 라우터 링크를 작성한다. 그리고, 링크 클릭 시, Projects 페이지의 정보를 보여주기 위해, router-view를 아래에 작성한다.123456789101112// App.vue&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt;This is main page&lt;/p&gt; &lt;router-link to=&quot;/projects&quot;&gt;&lt;button&gt;Go to Project page&lt;/button&gt;&lt;/router-link&gt; &lt;br&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; (4) Projects 페이지는 프로젝트가 나열되어 나오게 한다. 그리고, 각 프로젝트에 라우터 링크를 걸어, 그 링크를 클릭시, 클릭한 프로젝트에 대한 상세 정보가 나오는 Project 페이지가 나오게 한다. 이때, router-link에는 name과 params를 같이 넣어 주는데, 이는 router.js에서 등록한 그대로 작성하면 된다.1234567891011121314151617181920212223242526// Projects.vue&lt;template&gt; &lt;div&gt; &lt;p&gt;Projects page&lt;/p&gt; &lt;div v-for=&quot;project in projects&quot; :key=&quot;project.id&quot;&gt; &lt;router-link :to=&quot;&#123; name: &apos;project&apos;, params: &#123; id: project.id &#125; &#125;&quot;&gt; [ID: &#123;&#123;project.id&#125;&#125;] &#123;&#123;project.text&#125;&#125; &lt;/router-link&gt; &lt;/div&gt; &lt;br&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; computed: &#123; projects () &#123; return this.$store.state.projects &#125; &#125;&#125;&lt;/script&gt; (5) 위에서 어떤 하나의 프로젝트를 클릭하면, 그 프로젝트 컴포넌트에서 작성한 화면을 보여준다.(Project.vue). 이때, this.$route.params.id로 id에 접근할 수 있다.12345678910111213// Project.vue&lt;template&gt; &lt;div&gt; &lt;p&gt;Project each view: &#123;&#123; this.$route.params.id &#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export defualt &#123;&#125;&lt;/script&gt; Named 라우팅 Named 라우팅이란, 각 화면의 영역을 각각 용도, 모듈별로 구분할 수 있는데, 이때, 이름으로 구분하는 것을 말한다. 일반적인 웹 앱에서는 header, footer, body로 나누어 화면을 구성한다. (1) App.vue에서 각 화면별로 이름을 지정하여 화면의 영역을 나눈다.1234// App.vue&lt;router-view name=&quot;header&quot;&gt;&lt;/router-view&gt;&lt;router-view&gt;&lt;/router-view&gt;&lt;!-- name을 지정하지 않으면, default --&gt;&lt;router-view name=&quot;footer&quot;&gt;&lt;/router-view&gt; (2) 각 화면에 대한 컴포넌트로 만든 뒤, router.js로 import 한다. 그리고, routes에 다음과 같이 지정한다.12345678910111213141516171819202122// router.jsimport Vue from &apos;vue&apos;import VueRouter from &apos;vue-router&apos;import Body from &apos;./components/Body.vue&apos;import Header from &apos;./components/Header.vue&apos;import Footer from &apos;./components/Footer.vue&apos;Vue.use(VueRouter)const router = new VueRouter(&#123; mode: &apos;history&apos;, routes: [ &#123; path: &apos;/&apos;, components: &#123; default: Body, header: Header, footer: Footer &#125; &#125; ]&#125;) ‘Components’ 속성에 Key(router-view 이름)-Value(컴포넌트)로 등록하면, 컴포넌트에서 &lt;router-view&gt;에 각 컴포넌트의 화면이 보여진다. 이런 컴포넌트 구조는(Header-Body(default)-Footer) 모든 페이지의 기본형식이기 때문에, path를 ‘/‘로 사용하여, 기본페이지로 사용할 수 있다.","categories":[{"name":"Vue","slug":"Vue","permalink":"https://cheonmro.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://cheonmro.github.io/tags/Vue/"},{"name":"Routing","slug":"Routing","permalink":"https://cheonmro.github.io/tags/Routing/"}]},{"title":"Vue에서 Axios 사용하는 방법","slug":"axios-and-vue","date":"2018-12-27T12:39:31.000Z","updated":"2018-12-27T12:39:31.599Z","comments":true,"path":"2018/12/27/axios-and-vue/","link":"","permalink":"https://cheonmro.github.io/2018/12/27/axios-and-vue/","excerpt":"","text":"Axios란 무엇인가? axios란, Pormise 기반의 http 통신을 위한 클라이언트 라이브러리이다. vue에는 vue-resource라는 것이 있으나, 2016년 9월 이후 업데이트가 되어있지않고, Evan You(Vue 만든사람) 또한, 공식적으로 추천하지 않고, axios 쓰는 것을 추천한다. Axios 설치하기 npm으로 axios를 설치한다. npm install axios vue-axios Axios 등록하기 Vue 애플리케이션을 개발할 때, Vuex(store.js)의 actions에서 axios를 사용하므로, store.js에 axios를 등록한다.1234567891011// store.jsimport Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;// axios &amp; vue-axios를 importimport axios from &apos;axios&apos;import VueAxios from &apos;vue-axios&apos;Vue.use(Vuex);// axios &amp; vue-axios를 등록Vue.use(VueAxios, axios); Axios 사용하기 1. JSON server 만들기 가상의 서버에서 데이터를 만들어 사용하기 위해, 프론트엔드 개발자가 직접 JSON server를 구축하여, axios 통신을 테스트할 수 있다. npm install -g json-server 2. JSON server 만들기 JSON server에 가상 데이터를 만들기 위해, db.json 파일을 src 폴더 아래에 만들고, 다음과 같이 데이터를 추가한다.12345678910111213141516171819202122232425// db.json&#123; &quot;todos&quot;: [ &#123; &quot;id&quot;: &quot;1&quot;, &quot;text&quot;: &quot;vue&quot;, &quot;completed&quot;: false &#125;, &#123; &quot;id&quot;: &quot;2&quot;, &quot;text&quot;: &quot;react&quot;, &quot;completed&quot;: false &#125;, &#123; &quot;id&quot;: &quot;3&quot;, &quot;text&quot;: &quot;angular&quot;, &quot;completed&quot;: true &#125;, &#123; &quot;id&quot;: &quot;4&quot;, &quot;text&quot;: &quot;python&quot;, &quot;completed&quot;: false &#125; ] &#125; 3. JSON server 띄우기(Running) json-server --watch src/db.json --port 4000 4. Vuex(store.js)의 actions에 메소드 등록하기 actions에 등록하고, 등록할 때, mutations를 commit하여 변경된 상태를 추적가능하게 하면 된다. 서버와 통신을 할 때, CRUD라는 것이 있는데, todo 앱과 비교하면 다음과 같다. Create: addTodo Read: getTodo Update: changeTodo(toggle) Delete: deleteTodo Vuex(store.js)의 actions에 메소드 등록할 때, 위에 4가지로 나눠서 코드를 작성해보자. . Create: addTodo Create는 클라이언트단에서 데이터를 새로 생성하여, 서버에 추가하는 것이다. todo 앱에서는 addTodo가 된다. Vuex(store.js)의 actions에 메소드 등록할 때, axios의 post를 사용한다.1234567891011121314151617181920// store.jsactions: &#123; addTodo: function(context, payload) &#123; // post를 사용할 때는, 요청할 uri에 보낼 데이터를 같이 요청한다. axios.post(&apos;http://localhost:4000/todos&apos;, &#123; id: 4, text: payload, completed: false &#125;) // 요청이 성공하면, mutations에 commit을 하여, 원래 데이터에 요청한 데이터를 추가한다. .then((res) =&gt; &#123; console.log(res); context.commit(&apos;addTodo&apos;, res.data) &#125;) // 요청이 실패하면, 에러에 대한 조치를 취한다. .catch((err) =&gt; &#123; console.log(err); &#125;) &#125;&#125; actions에서 commit한 mutations에 로직을 작성한다.12345mutations: &#123; addTodo (state, todo) &#123; state.todoList = [...state.todoList, todo] &#125;&#125; . Read: getTodo Read는 클라이언트단에서 데이터를 서버에 요청하여, 데이터를 받는 것이다. todo 앱에서는 getTodo가 된다. Vuex(store.js)의 actions에 메소드 등록할 때, axios의 get을 사용한다.12345678910111213141516// store.jsactions: &#123; getTodo: function(context) &#123; // get을 사용할 때는, 요청할 uri를 작성한다. axios.get(&apos;http://localhost:4000/todos&apos;) // 요청이 성공하면, mutations에 commit을 하여, 원래 데이터에 요청받은 데이터를 할당한다. .then((res) =&gt; &#123; console.log(res); context.commit(&apos;getTodo&apos;, res.data) &#125;) // 요청이 실패하면, 에러에 대한 조치를 취한다. .catch((err) =&gt; &#123; console.log(err); &#125;) &#125;&#125; actions에서 commit한 mutations에 로직을 작성한다.12345mutations: &#123; getTodo (state, data) &#123; state.todoList = data; &#125;&#125; . Update: changeTodo(toggle) Update는 클라이언트단에서 기존에 있던 데이터를 서버에 요청하여, 데이터를 변경하는 것이다. todo 앱에서는 toggle이 된다. Vuex(store.js)의 actions에 메소드 등록할 때, axios의 patch를 사용한다.123456789101112131415// store.jsactions: &#123; toggle: function(context, payload) &#123; // patch를 사용할 때는, 요청할 uri에 변경할 데이터의 uri를 붙여서 보낸다. 예를 들어, /todos/id가 올 수 있다. axios.patch(`http://localhost:4000/todos/$&#123;payload&#125;`) // 요청이 성공하면, mutations에 commit을 하여, 특정 데이터가 변경된 상태로 데이터가 변경된다. .then((res) =&gt; &#123; console.log(res); context.commit(&apos;toggle&apos;, payload) &#125;) .catch((err) =&gt; &#123; console.log(err); &#125;) &#125;,&#125; actions에서 commit한 mutations에 로직을 작성한다.123456mutations: &#123; toggle (state, id) &#123; const index = state.todolist.findIndex((item)=&gt;item.id === id); state.todolist[index].completed = !this.todolist[index].completed; &#125;,&#125; . Delete: deleteTodo Update는 클라이언트단에서 기존에 있던 데이터를 서버에 요청하여, 데이터를 변경하는 것이다. todo 앱에서는 toggle이 된다. Vuex(store.js)의 actions에 메소드 등록할 때, axios의 patch를 사용한다.123456789101112131415// store.jsactions: &#123; deleteTodo: function(context, payload) &#123; // delete를 사용할 때는, 요청할 uri에 제거할 데이터의 uri를 붙여서 보낸다. 예를 들어, /todos/id가 올 수 있다. axios.delete(`http://localhost:4000/todos/$&#123;payload&#125;`) // 요청이 성공하면, mutations에 commit을 하여, 특정 데이터가 지워진 상태로 데이터가 변경된다. .then((res =&gt; &#123; console.log(res); context.commit(&apos;deleteTodo&apos;, payload) &#125;)) .catch((err) =&gt; &#123; console.log(err); &#125;) &#125;&#125; actions에서 commit한 mutations에 로직을 작성한다.1234567mutations: &#123; deleteTodo (state, id) &#123; state.todoList = state.todoList.filter((t) =&gt; &#123; return t.id !== id &#125;) &#125;&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://cheonmro.github.io/categories/Vue/"}],"tags":[{"name":"Axios","slug":"Axios","permalink":"https://cheonmro.github.io/tags/Axios/"},{"name":"Vue","slug":"Vue","permalink":"https://cheonmro.github.io/tags/Vue/"}]},{"title":"Vuex 사용법","slug":"how-to-use-vuex","date":"2018-12-27T11:34:01.000Z","updated":"2018-12-27T11:34:01.940Z","comments":true,"path":"2018/12/27/how-to-use-vuex/","link":"","permalink":"https://cheonmro.github.io/2018/12/27/how-to-use-vuex/","excerpt":"","text":"State란 무엇인가? state는 컴포넌트 간에 공유할 data를 말한다. 각 컴포넌트에서의 data 속성과 동일하기 때문에, 각 컴포넌트의 인스턴스에서 data() 속성을 사용하는 대신, Vuex에 state로 등록하여 사용한다. State 등록하기 store.js에 state(데이터)를 등록한다.123456789101112// store.jsimport Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;Vue.use(Vuex);export default new Vuex.Store(&#123; // state안에 데이터를 등록 state: &#123; value: 10 &#125;&#125;); State 사용하기 가져와서 사용할 각 컴포넌트에서 Vuex의 state에 접근하여 사용한다.1234567// App.vue&lt;template&gt; &lt;div id=&quot;app&quot;&gt; // store.js의 state에 있는 데이터(value)에 접근하여 가져와서 사용 &#123;&#123; this.$store.state.value &#125;&#125; &lt;/div&gt;&lt;/template&gt; 위와 같은 방식으로, 어떤 컴포넌트든 Vuex(store.js)에 접근하여 state를 가져와 사용할 수 있다. 그러나, Template의 표현식은 최대한 간소화해야 한다. 다음과 같이 computed를 사용해서 state에 접근할 수 있다. 123456789101112131415&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &#123;&#123; getValue &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; computed: &#123; getValue() &#123; return this.$store.state.value &#125; &#125;&#125;&lt;/script&gt; Getters란 무엇인가? Getters는 인스턴스의 computed(계산된 속성)과 같은 역할을 한다. 인스턴스에서 computed는 이미 어떤 값이 캐싱되어 있어, 종속된 값이 변경되지 않으면, 이미 계산되 값이 바로 나오고, 종속된 값이 변경된 경우에만 다시 재계산되어 나온다. 그래서, Getters를 사용하면 여러 컴포넌트에서 같은 로직을 비효율적으로 사용하는 것을 막는다. 즉, 각 컴포넌트에서는 수행 로직을 호출만 하면, Vuex의 Getters를 보내주어, 코드의 가독성과 성능이 좋아진다. Getters 등록하기 store.js에 getters를 등록한다.123456789101112131415161718192021// store.jsimport Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;Vue.use(Vuex);export default new Vuex.Store(&#123; state: &#123; todos: [ &#123; id: 1, text: &apos;vue&apos;, complete: true &#125;, &#123; id: 2, text: &apos;react&apos;, complete: false &#125;, &#123; id: 3, text: &apos;angular&apos;, complete: true &#125; ] &#125;, // todos의 complete가 true인 데이터만 필터 getters: &#123; doneTodos: state =&gt; &#123; return state.todos.filter(todo =&gt; todo.complete) &#125; &#125;&#125;); Getters 사용하기 12345678910111213141516171819// App.vue&lt;template&gt; &lt;div id=&quot;app&quot;&gt; // doneTodos를 화면에 보여줌 &#123;&#123; doneTodos &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; // store.js의 getters에 있는 doneTodos에 접근하여 사용 computed: &#123; doneTodos() &#123; return this.$store.getters.doneTodos &#125; &#125;&#125;&lt;/script&gt; mapGetters 사용하기 Vuex에 내장된 helper 함수 중, mapGetters를 사용하여, 좀 더 간단하게 작성할 수 있다.12345678910111213141516171819202122232425// App.vue&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &#123;&#123; doneTodos &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// mapGetters를 importimport &#123; mapGetters &#125; from &apos;vuex&apos;// computed에서 mapGetters를 사용export default &#123; // Vuex 의 Getters 메서드 명과 App.vue 메서드 명이 동일할 때, [] 사용 computed: mapGetters([ &apos;doneTodos&apos;]), // Vuex 의 Mutations 메서드 명과 App.vue 메서드 명을 다르게 매칭할 때, &#123;&#125; 사용 computed: mapGetters(&#123; // 앞 doneTodos 해당 컴포넌트의 메서드를, 뒤 &apos;doneTodos&apos;는 Vuex의 getters를 의미 doneTodos: &apos;doneTodos&apos; &#125;)&#125;&lt;/script&gt; Mutations란 무엇인가? Mutations(변이)란, Vuex의 데이터, 즉 state 값을 변경하는 로직들을 의미한다. Vuex 저장소에서 실제로 상태를 변경하는 유일한 방법이다. Mutations 특징 모든 state의 변화를 추적해야 하기 때문에, 순차적, 즉 동기적으로 일을 처리한다. 컴포넌트의 인스턴스에서는 methods에서 사용하여, Vuex의 mutations에 접근한다. 이때, 인자를 받아서 Vuex로 보낼 수 있다. Getters와의 차이점 인자를 받아서 Vuex에 넘겨줄 수 있다. methods에서 사용(Getters는 computed에서 사용) Actions와의 차이점 mutations: 동기적 로직 actions: 비동기적 로직 만약, 여러 개의 컴포넌트에서 같은 state 값을 동시에 제어하게 되면, state 값이 어느 컴포넌트에서 호출해서 어떻게 변경된지를 추적하기가 어렵기 때문에, mutations에서는 동기적으로 하나씩 일을 처리하여, 상태의 변화를 정확하게 추적할 수 있다. Mutations 등록하기 먼저 Vuex(store.js)에 mutations를 등록해야 한다.1234567891011121314// store.jsexport default new Vuex.Store(&#123;mutations: &#123; getTodo (state, payload) &#123; state.todoList = payload; &#125;, // function을 같이 써줘도 된다. addTodo: function(state, payload) &#123; state.todoList = [...state.todoList, payload]; &#125;,&#125;,&#125;) mutations는 getters와 다르게, 인자를 받아서 Vuex에 넘겨줄 수 있다. 첫번째 인자: state로, store.js에 있는 state를 의미한다. 두번째 인자: payload로, 컴포넌트에서 보내주는 데이터이다.(만약 데이터가 없다면, 생략 가능) Mutations 사용하기 컴포넌트의 인스턴스에서는 methods에서 사용하여, commit으로 Vuex(store.js)의 mutations에 접근한다.123456789101112131415161718192021222324252627282930// App.vue&lt;template&gt; &lt;section&gt; &lt;div class=&quot;row justify-content-center mt-4&quot;&gt; &lt;input v-model=&quot;inputField&quot; v-on:keyup.enter=&quot;addTodo&quot; class=&quot;mr-1&quot; placeholder=&quot;Todo Item&quot; /&gt; &lt;button @click=&quot;addTodo&quot; class=&quot;btn btn-primary&quot;&gt;Add Todo&lt;/button&gt; &lt;/div&gt; &lt;/section&gt;&lt;/template&gt;&lt;script&gt;export default &#123; // store.js에서의 mutations 중 &apos;getTodo&apos;에 접근 mounted() &#123; this.$store.commit(&apos;getTodo&apos;) &#125;, // store.js에서의 mutations 중 &apos;addTodo&apos;에 접근 methods: &#123; addTodo: function() &#123; if(this.inputField) &#123; // &apos;addTodo&apos;는 mutations에 있는 &apos;addTodo&apos;, this.inputField는 Vuex(store.js)에 넘겨줄 데이터 this.$store.commit(&apos;addTodo&apos;, this.inputField); this.inputField = &apos;&apos;; &#125; &#125;, &#125;&#125;&lt;/script&gt; 참고로, main.js에 전역 인스턴스에 store를 등록했기 때문에, this.$store를 사용할 수 있다. mapMutations 사용하기 Vuex에 내장된 helper 함수 중, mapMutations를 사용하여, 좀 더 코드 가독성을 높일 수 있다.123456789101112131415// App.vue// mapMutations를 import 해야함import &#123; mapMutations &#125; from &apos;vuex&apos;methods: &#123; // Vuex 의 Mutations 메서드 명과 App.vue 메서드 명이 동일할 때, [] 사용 ...mapMutations([ &apos;addTodo&apos; ]), // Vuex 의 Mutations 메서드 명과 App.vue 메서드 명을 다르게 매칭할 때, &#123;&#125; 사용 ...mapMutations(&#123; addTodo: &apos;addTodo&apos; // 앞 addTodo는 해당 컴포넌트의 메서드를, 뒤 &apos;addTodo&apos;는 Vuex의 mutations를 의미 &#125;)&#125; Actions란 무엇인가? actions란, Vue에서 비동기적으로 처리되야 하는 것들을 관리하기 위한것이다. 즉, 서버와의 http 통신이나 setTimeout() 등과 같이, 결과를 받아올 타이밍이 예측되지 않은 로직을 actions에 선언하고 처리한다. 대표적으로 비동기인 다음의 2가지를 actions에서 주로 사용한다. http통신 setTimeout() http 통신: axios 사용 Actions 등록하기 먼저 Vuex(store.js)에 actions를 등록해야 한다.123456789101112131415161718192021// store.jsexport default new Vuex.Store(&#123; actions: &#123; addTodo: function(context, payload) &#123; axios.post(&apos;http://localhost:4000/todos&apos;, &#123; id: 4, text: payload, completed: false &#125;) .then((res) =&gt; &#123; // 상태(state)가 변경된 것을 추적하기 위해, mutations의 메소드를 호출(commit) context.commit(&apos;addTodo&apos;, res.data) &#125;) .catch((err) =&gt; &#123; console.log(err); &#125;) &#125;, &#125;&#125;) Mutations 등록하기 actions에 등록을 했어도, 상태가 변경된 것을 추적하기 위해서는 mutations의 메소드를 호출(commit) 해야한다. 그리고, mutations에 actions에 등록한 메소드를 작성한다.12345mutations: &#123; addTodo (state, todo) &#123; state.todoList = [...state.todoList, todo] &#125;,&#125; Actions 사용하기 actions를 호출할 때는 dispatch를 사용한다. 1234567// App.vuemethods: &#123; addTodo() &#123; // &apos;addTodo&apos;는 actions에 있는 &apos;addTodo&apos;, this.inputField는 Vuex(store.js)에 넘겨줄 데이터 this.$store.dispatch(&apos;addTodo&apos;, this.inputField); &#125;&#125;, mapActions 사용하기 Vuex에 내장된 helper 함수 중, mapActions를 사용하여, 좀 더 간단하게 작성할 수 있다. 1234567891011121314151617// App.vueimport &#123;mapActions&#125; from &apos;vuex&apos;;export default &#123; methods: &#123; // Vuex 의 Actions 메서드 명과 App.vue 메서드 명이 동일할 때, [] 사용 ...mapActions([ &apos;addTodo&apos;, &apos;getTodo&apos; ]) // Vuex 의 Actions 메서드 명과 App.vue 메서드 명을 다르게 매칭할 때, &#123;&#125; 사용 ...mapActions(&#123; addTodo: &apos;addTodo&apos; // 앞 addTodo는 해당 컴포넌트의 메서드를, 뒤 &apos;addTodo&apos;는 Vuex의 actions를 의미 &#125;) &#125;,&#125; setTimeout() 사용 Actions 등록하기 먼저 Vuex(store.js)에 actions를 등록해야 한다.12345678910// store.jsexport default new Vuex.Store(&#123; delayTime: function (context, payload) &#123; return setTimeout(function () &#123; commit(&apos;addTodo&apos;, payload); // mutations에 있는 &apos;addTodo&apos; 호출 &#125;, 5000); &#125;&#125;) Mutations 등록하기 actions에 등록을 했어도, 상태가 변경된 것을 추적하기 위해서는 mutations의 메소드를 호출(commit) 해야한다. 그리고, mutations에 actions에 등록한 메소드를 작성한다.12345mutations: &#123; addTodo (state, todo) &#123; state.todoList = [...state.todoList, todo] &#125;,&#125; Actions 사용하기 actions를 호출할 때는 dispatch를 사용한다.1234// App.vueaddTime(time) &#123; this.$store.dispatch(&apos;delayTime&apos;, time); &#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://cheonmro.github.io/categories/Vue/"}],"tags":[{"name":"Vuex","slug":"Vuex","permalink":"https://cheonmro.github.io/tags/Vuex/"}]},{"title":"Vuex란 무엇인가?","slug":"what-is-vuex","date":"2018-12-26T11:16:20.000Z","updated":"2018-12-26T11:26:48.395Z","comments":true,"path":"2018/12/26/what-is-vuex/","link":"","permalink":"https://cheonmro.github.io/2018/12/26/what-is-vuex/","excerpt":"","text":"Vuex란 무엇인가? Vuex란, 상태관리 패턴에 대한 라이브러리로써, 애플리케이션의 모든 컴포넌트에 대한 중앙집중식 저장소 역할을 하며, 예측 가능한 방식으로 상태를 변경할 수 있다. Vuex는 왜 사용하는가? Vuex는 상태관리(State Management)를 위해 사용한다. 여기서 말하는 상태(State)란, 데이터를 말하며, 컴포넌트간에 데이터 통신 및 전달을 효율적으로 관리를 쉽게 하기 위해 Vuex를 사용한다. Vuex는 중대형 규모의 앱 컴포넌트들을 관리할 때 좋은데, 일반적으로 앱의 규모가 커지면 다음과 같은 문제가 생긴다. 단순 부모-자식간의 데이터 통신이 아닌, 그 중간에 많은 컴포넌트들이 있을 경우, 데이터 통신 방식이 복잡해짐 EventBus를 사용하여 상하위 관계가 아닌 컴포넌트들간의 통신시에 관리가 안됨 이런 문제를 해결하기 위해, Vuex를 사용하여 모든 데이터(State)를 한 곳에서 중앙 집중식으로 관리한다. 즉, Vuex는 공통의 상태를 공유하는 여러 컴포넌트가 있을 경우, 이를 Vuex 한 곳(전역)에서 집중적으로 관리하는 역할을 한다. 그러나, 만약 공통으로 공유하는 것이 아닌, 개별의 로컬 컴포넌트에서 사용하는 경우에는, 꼭 Vuex에 저장할 필요가 없다. Vuex Architecture 위에서, Vuex는 상태관리 패턴에 대한 라이브러리라고 했다. 즉, 상태관리 패턴이란, 상태를 관리하기 위한 하나의 패턴방식을 말한다. Vuex에서의 패턴방식은 단반향 데이터 흐름을 따른다. 출처: Vuex One-Way Data Flow 상태관리는 3가지로 구성되어 있다. state: 컴포넌트간에 공유하는 data view: data가 보여지는 template actions: 사용자의 입력에 따라 반응하는 methods 123456789101112131415161718192021new Vue(&#123; // state data () &#123; return &#123; msg: &apos;hello world&apos; &#125; &#125;, // view template: ` &lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt; `, // actions methods: &#123; changeMsg () &#123; this.msg = &apos;world hello&apos; &#125; &#125;&#125;) Vuex Architecture 전체적인 Vuex Architecture는 다음과 같다. 출처: Vuex Architecture Vuex 설치 및 등록 npm을 이용해서 설치한다. 1npm install vuex Vuex를 등록할 js 파일을 새로 생성하는데, 보통 관례로 store.js로 만든다. 123456789// store.jsimport Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;Vue.use(Vuex);export default new Vuex.Store(&#123; //&#125;); Vuex를 전역에서 사용하기 위해, main.js에 등록한다. 12345678910111213// main.jsimport Vue from &apos;vue&apos;import App from &apos;./App.vue&apos;// store를 importimport store from &apos;./store&apos;Vue.config.productionTip = falsenew Vue(&#123; // store를 루트(전역) 인스턴스에 등록 store, render: h =&gt; h(App),&#125;).$mount(&apos;#app&apos;) 루트 인스턴스에 store 옵션을 제공함으로써 저장소는 루트의 모든 하위 컴포넌트에 주입되고, 하위 컴포넌트에서 this.$store로 사용할 수 있다. (루트 인스턴스: main.js에 있는 최상단의 인스턴스)","categories":[{"name":"Vue","slug":"Vue","permalink":"https://cheonmro.github.io/categories/Vue/"}],"tags":[{"name":"Vuex","slug":"Vuex","permalink":"https://cheonmro.github.io/tags/Vuex/"}]},{"title":"Vue Architecture","slug":"vue-architecture","date":"2018-12-23T11:57:29.000Z","updated":"2018-12-23T11:57:29.995Z","comments":true,"path":"2018/12/23/vue-architecture/","link":"","permalink":"https://cheonmro.github.io/2018/12/23/vue-architecture/","excerpt":"","text":"Component 단위로 개발하는 Vue Vue는 컴포넌트 단위로 개발할 수 있다. 컴포넌트(Component)란, html, css, javascript를 1개의 파일 단위로 나눠서 개발하는 것을 말한다. Vue에서는 이를 싱글 파일 컴포넌트라고 하는데, UI 단위로 나눠서 개발하여, 코드의 재사용 측면에서 좋다. 즉, Vue.js는 컴포넌트를 조합해 전체 애플리케이션을 만든다. 이때, 컴포넌트들은 부모-자식 관계를 갖는 트리구조로 작성할 수 있다. Vue 프로젝트를 생성하게 되면, 다양한 파일이 만들어진다. index.html index.html: 어플리케이션 전체의 뼈대가 되는 html 파일이다.1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt; &lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;&gt; &lt;title&gt;what&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;noscript&gt; &lt;strong&gt;We&apos;re sorry but what doesn&apos;t work properly without JavaScript enabled. Please enable it to continue.&lt;/strong&gt; &lt;/noscript&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;!-- built files will be auto injected --&gt; &lt;/body&gt;&lt;/html&gt; main.js main.js: Vue 인스턴스를 생성해주는 파일이다.12345678import Vue from &apos;vue&apos;import App from &apos;./App.vue&apos;Vue.config.productionTip = falsenew Vue(&#123; render: h =&gt; h(App),&#125;).$mount(&apos;#app&apos;) 이 자바스크립트 파일은 new 연산자를 사용해서 Vue 인스턴스를 생성해준다. Vue는 기본적으로 인스턴스를 생성하여 개발을 하는데, 컴포넌트 단위로 개발을 할 경우, main.js에서 new 연산자로 Vue 인스턴스를 생성하게 해주고, 각 컴포넌트에서 각 UI에 맞게 인스턴스를 활용해서 컴포넌트를 개발한다. render에서 h() 안에 있는 ‘App’은 첫 화면에 뿌려질 Vue 컴포넌트를 의미한다.1render: h =&gt; h(App) $mount() 안에 있는 ‘#app’은 id를 ‘app’으로 가지고 있는 html 태그를 의미한다. 이 태그로 마운트한다는 것인데, 마운트한다는 것은 위 App 컴포넌트를 이 html 태그(id를 ‘app’으로 가지고 있는 태그)에 연결시킨다는 의미이다.1$mount(&apos;#app&apos;) 즉, 위 index.html에 있는 &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; 안으로 App 컴포넌트를 연결(넣는다)한다는 뜻이다. component.vue component.vue: 재사용성을 고려해 UI 단위로 개발하는 vue 파일이다.12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt; &lt;HelloWorld msg=&quot;Welcome to Your Vue.js App&quot;/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import HelloWorld from &apos;./components/HelloWorld.vue&apos;export default &#123; name: &apos;app&apos;, components: &#123; HelloWorld &#125;&#125;&lt;/script&gt;&lt;style&gt;#app &#123; font-family: &apos;Avenir&apos;, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;&lt;/style&gt; component는 위와 같이 3가지로 구성되어 있다. template script style Vue의 MVVM 패턴에 따라 나누면 다음과 같은 3가지로 구성되어 있다. ViewModel View Model 1. ViewModel Vue.js에서 모든 Vue 인스턴스는 ViewModel인데, 이 ViewModel은 Model과 View 사이에서 양방향 데이터 바인딩을 해줌으로써, 동기화 역할을 한다. ViewModel은 Vue 생성자 혹은 하위 클래스들에 의해 인스턴스화된다.1var vm = new Vue(&#123; /* options */ &#125;) 2. View Vue.js는 DOM 기반의 템플릿을 사용하는데, View의 실제 돔(DOM)은 Vue instance에 의해 관리된다. 각 Vue 인스턴스는 해당 DOM 요소에 연관된다. Vue 인스턴스가 생성되면 필요한 데이터 바인딩을 설정하는 동안 루트 요소의 모든 자식 노드를 반복적으로 탐색한다. 뷰가 컴파일이 되면 데이터 변경에 반응할 수 있게 된다.123456&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt; &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; 즉, 해당 HTML 컴포넌트 범위(해당 DOM 요소가 담긴 템플릿)를 Vue 인스턴스의 vm.$el에 설정한다. 뷰는 Vue 인스턴스가 생성 될 때, 컴파일 되며 뷰모델의 다양한 동작 기능들이 바인딩 된다. 그렇게 됨으로써 뷰의 변경이 감지되면 뷰모델이 이를 감지하여 반응할 수 있게된다. 또한, 뷰의 변경은 집단적으로, 비동기로 실행되기 때문에 높은 성능을 발휘한다. 3. Model Vue.js에서 모델은 단순히 자바스크립트 객체 혹은 데이터 객체로 표현할 수 있다. 데이터 객체의 프로퍼티를 조작하면 이를 관찰하는 뷰 인스턴스가 변경을 알린다. Vue.js는 ES5 getter/setters로 데이터 객체의 프로퍼티를 변환한다. 그렇기에 뷰를 변경하기 위해 Vue에 명시적으로 신호를 보낼 필요가 없다. 그리고, 각 뷰 인스턴스는 데이터 객체에 있는 모든 프로퍼티들을 프록시한다.123456789101112export default &#123; name: &apos;app&apos;, components: &#123; HelloWorld &#125;, // Model data: function() &#123; return &#123; msg: &apos;hello&apos; &#125; &#125;&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://cheonmro.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://cheonmro.github.io/tags/Vue/"},{"name":"Architecture","slug":"Architecture","permalink":"https://cheonmro.github.io/tags/Architecture/"}]},{"title":"package.json, node_modules, 그리고 package-lock.json간의 관계","slug":"package-json","date":"2018-12-22T15:13:46.000Z","updated":"2018-12-22T15:13:46.421Z","comments":true,"path":"2018/12/23/package-json/","link":"","permalink":"https://cheonmro.github.io/2018/12/23/package-json/","excerpt":"","text":"npm이란 무엇인가? npm(node package manager)은 노드 패키지 매니저의 약자로써, 모듈(패키지) 관리(설치, 업데이트, 삭제)를 하기위한 매니저이다. 노드의 정의는 크게 2가지로 나눌 수 있다. 서버: 네트워크를 통해 클라이언트에 정보나 서비스를 제공하는 컴퓨터 또는 프로그램을 말한다. 자바스크립트 런타임: 자바스크립트 프로그램을 컴퓨터에서 실행할 수 있게 하는 환경을 말한다. npm에서의 노드는 자바스크립트 런타임을 의미한다. 즉, 대부분의 자바스크립트 프로그램은 패키지라는 이름으로 npm에 등록되어 특정 기능을 하는 패키지가 필요하면, npm에서 찾아 설치하면 된다. npm에 업로드된 노드 모듈(자바스크립트 기반으로 만들어진 프로그램 파일)을 패키지라고 부른다. 그래서, npm을 자바스크립트 패키지 매니저라고도 부른다. 모듈이 다른 모듈을 사용할 수 있는 것처럼, 어떤 패키지가 다른 패키지를 사용할 수 있다. 이런 관계를 의존 관계(dependencies)라고 부른다. 이런 패키지 매니저가 npm 말고도, 페이스북에서 만든 yarn도 있다. npm은 왜 사용하는가? npm에는 약 60만 개(2018년 6월 기준)의 패키지가 등록되어 있는데, 이는 대부분 오픈소스로 등록되어 있어 웹개발을 할 때 많은 도움이 된다. 또한, 새로운 모듈(패키지)를 설치하거나 관리를 위해, npm은 npm cli를 제공해서 cli 명령어로 설치, 업데이트 및 삭제를 쉽게 할 수 있다. package.json이란 무엇인가? package.json이란, 생성한 프로젝트의 메타정보와 이 프로젝트가 의존하고 있는(설치한) 모듈들에 대한 정보들을 json 형태로 모아놓은 파일이다. package.json 파일내에 있는 각 속성들에 대해서는 다음 링크를 참고하면 좋을 것 같다.package.json에 대한 자세한 설명 package.json은 왜 사용하는가? 만약 이 package.json 파일을 사용하지 않을 경우 다음과 같은 문제가 발생할 수 있다. 프로젝트에서 사용하는 외부 모듈들이 많아지게 되면, 관리하기가 어려워진다. 각 패키지들은 고유한 버전이 있기 때문에, 따로 기록해 두어야 한다. 왜냐하면, 패키지의 버전도 빈번하게 업데이트가 되기 때문이다. 새로운 프로젝트를 진행할 때, 필요한 모듈들이 많다면 매번 npm 명령으로 설치해야 하는 번거로움이 있다. 이런 경우, 필요한 패키지들의 목록을 파일로 정리해놓고, 목록 파일을 이용하여 단 한번의 명령어로 필요한 패키지들을 모두 설치할 수 있다. 이러한 패키지 정의 파일을 package.json 파일이라고 한다. 즉, package.json은 프로젝트에 대한 메타정보, 그리고 설치한 패키지의 의존성 및 버전을 관리하는 파일이다. vue cli로 Vue 프로젝트를 생성하면, 자동으로 package.json 파일이 만들어 지지만, npm init을 사용하면, package.json 파일을 직접 만들 수도 있다. 그리고, 팀 내에서 동일한 개발환경을 구축하려고 할 때, 이미 작성된 package.json 파일이 있다면, 팀 내에 배포하여 동일한 개발환경을 빠르게 구축할 수 있다. node_modules란 무엇인가? Vue 프로젝트를 생성하면, package.json 파일 뿐만 아니라, node_modules 디렉토리가 같이 생성된다. package.json에는 프로젝트가 의존하고 있는 모듈들에 대한 정보가 나와있고, node_modules 디렉토리에는 package.json에 있는 모듈 뿐만 아니라, package.json에 있는 모듈이 의존하고 있는 모듈 전부를 포함하고 있다. 그래서 node_modules 디렉토리안에는 정말 많은 모듈들이 들어가 있다. npm으로 새로운 모듈(패키지)를 설치하게 되면, package.json과 node_modules에 추가된다. 참고로, git에 커밋할 때, node_modules을 제외해도 된다. 왜냐하면, node_modules가 없어도, package.json에 설치한 패키지들이 모두 있기 때문에, npm install로 node_modules를 언제든지 설치가 가능하기 때문이다. package-lock.json이란 무엇인가? package-lock.json은 이 package-lock.json이 생성되는 시점의 의존성 트리(node_modules)에 대한 정보를 가지고 있는 파일을 말한다. 의존성 트리는 package.json에 등록된 모듈과 그 모듈들이 의존하고 있는 모듈 전부를 포함하고 있기 때문에, 결국 package-lock.json도 이 모든 모듈들을 가지고 있다. npm을 사용해서 node_modules나 package.json을 수정하게 되면, package-lock.json 또한 자동으로 업데이트가 된다. package-lock.json은 왜 사용하는가? package.json 파일에는 의존성 모듈(dependencies)의 version range가 사용된다. version range란, 특정 버전이 아닌, 버전의 범위를 의미한다. 예를 들어, npm install express로 express를 설치하면, package.json에는 ‘^4.10.3’(Caret Ranges)과 같이 버전 범위가 추가된다. 이 버전의 express가 추가된 package.json을 가지고 npm install을 실행하면, 현재는 4.10.3 버전이 설치되지만, express의 버전이 업데이트된 상태로 publish가 된 후에, 동일한 package.json 파일로 npm install을 실행했을 경우, 원래 버전이 아닌, 새로 업데이트된 버전으로 express가 변경된다. 이럴 경우, 기존에 가지고 있던 node_modules(의존성 트리)에 있던 모듈의 버전과 충돌이 일어나, 오류를 발생시킬 수 있다. 이 문제를 해결하기 위해, package-lock.json을 사용하는 것이다. package-lock.json은 node_modules(의존성 트리)에 대한 정보를 가지고 있는데, package-lock.json이 업데이트가 되는 시점에 node_modules(의존성 트리)을 재생성할 수 있다. 그래서, package-lock.json 파일이 있다면, npm install로 package.json과 package-lock.json에 있는 모듈이 새로 업데이트되는 동시에, node_modules(의존성 트리)가 새로 생성되어, 각 파일이 가지고 있는 모듈의 버전을 동일하게 맞출 수가 있게 된다. 즉, package.json에 있는 모듈의 버전은 npm install을 수행하는 시점에 따라 달라진다. 이 말은, npm install을 수행하는 시점에 publish 되어있는 모듈의 버전으로 업데이트가 된다는 뜻이다. 이렇게 되면, package.json과 package-lock.json에 있는 모듈이 같은 버전으로 업데이트가 되고, 이때 package-lock.json 때문에 node_modules(의존성 트리)가 재생성되어, 3개의 파일에 있는 모듈이 모두 같은 버전으로 맞춰지게 되어 오류가 안나게 된다. 이런 이유로, git에 커밋할 때, package.json 파일 뿐만 아니라, packge-lock.json 파일 또한 같이 커밋을 해야 한다. 패키지 version 노드 패키지들의 버전은 세 자리로 되어있는데, 이는 SemVer 방식의 버전 넘버링을 따르기 때문이다. SemVer는 Semantic Versioning(유의적 버전)의 약어인데, 이는 버전을 구성하는 세 자리가 모두 의미가 있다는 뜻이다. 서비스를 개발하다 보면, 정말 많은 패키지들을 사용하게 되는데, 이런 많은 패키지들이 서로 얽히다 보면 문제가 생길 수 있다. 예를 들어, 어떤 패키지의 버전을 업그레이드 했는데, 그것을 사용하는 다른 패키지에서 에러가 발생한다면 문제가 된다. 따라서 버전 번호를 어떻게 정하고, 올려야 하는지를 명시하는 규칙을 만들었는데, 이것이 바로 SemVer 이다. 버전은 세 자리로 구성되어 있다. major 버전: 하위 호환이 안될 정도로 패키지의 내용이 수정되었을 때 올린다. 주 버전이 0이면, 초기 개발 중이라는 뜻이다. 1부터는 정식 버전이다. 만약, 1.7.1에서 2.0.0으로 올렸다면, 1.7.1 버전 패키지를 사용하고 있던 사람들이 2.0.0으로 업데이트 했을 때, 에러가 발생할 확률이 크다. minor 버전: 하위 호환이 되는 업데이트 시에 올린다. 만약, 1.7.1에서 1.8.0으로 올렸다면, 1.7.1 사용자가 1.8.0으로 업데이트 했을 때, 아무 문제가 없어야 한다. patch 버전: 새로운 기능이 추가되었다기 보다는, 기존 기능에 문제가 있어 수정한 것을 내놓았을 때, patch 버전을 올린다. 1.7.0에서 1.7.1으로 올렸다면, 업데이트 후 문제가 없어야 한다. 새 버전을 배포한 후에는, 그 버전의 내용을 절대 수정하면 안된다. 만약, 수정 사항이 생기면, major버전, minor 버전, patch버전 중 하나를 의미에 맞게 올려서 새로운 버전으로 배포해야 한다. 버전의 숫자마다 의미가 부여되어 있기 때문에, 다른 패키지를 사용할 때도 버전만 보고 에러 발생 여부를 판단할 수 있다. 만약, 의존하는 패키지의 major 버전이 업데이트 되었다면, 기존 코드와 호환이 되지 않을 확률이 크기 때문에, 미리 주의를 기울여야 한다. 만약, minor나 patch 버전으로 업데이트 되었다면, 상대적으로 안심하고 버전을 올리 수 있다. package.json에는 버전 말고도, 다른 기호(‘^’, ‘~’ 등)들이 있다. 이런 기호들은 버전에는 포함되지 않지만, 설치 또는 업데이트 시 어떤 버전의 범위를 설치해야 하는지 알 수 있다. ^(캐럿): minor 버전까지만 설치 또는 업데이트한다. 예를 들어, npm install express@^1.7.1 이라면, 1.7.1 &lt;= 버전 &lt; 2.0.0까지 설치가 되고, 2.0.0은 설치되지 않는다. ~(틸트): patch 버전까지만 설치 또는 업데이트한다. npm install express@~1.7.1 이라면, 1.7.1 &lt;= 버전 &lt; 1.8.0까지 설치가 된다. ~ 보다 ^가 많이 사용되는 이유는, minor 버전까지는 하위 호환이 되기 때문이다. npm semver calculator에 방문하면, 패키지 별로 버전 표기법을 사용하여, 업데이터 버전 범위를 확인 가능하다. 참고로, npm install 명령어의 패키명 뒤에 @버전을 추가하면 패키지 버전을 지정하여 설치할 수 있다. nodemon이란? nodemon은 프로젝트 폴더의 파일들을 모니터링하고 있다가, 파일이 수정될 경우 자동으로 서버를 재시작을 해준다. nodemon을 위해서 소스에 다른 설정을 추가할 필요도 없기 때문에 상당히 편리하게 사용할 수 있습니다. –save와 –dev npm install 모듈명 --save 을 입력하면, 설치하는 모듈을 package.json에 등록할 수 있다.(npm@5 부터는 –save는 기본옵션이다.)그래서, npm@5 부터는 –save 옵션을 사용하지 않더라도, 모든 install 명령은 package.json의 dependencies에 설치되어 관리된다.그리고, npm install 모듈명 --save --dev을 입력하면, 설치하는 모듈을 package.json에 등록할 수 있을 뿐만 아니라, –dev 때문에, package.json 파일에서 devDepencies에 등록된다. devDepencies에서 관리하는 모듈들은 개발용 모듈들이고, depencies에서 관리하는 모듈들은 배포용 모듈들이다. package.json에 명시된 모든 의존 패키지를 한번에 설치하기 위해서는, npm install 명령어를 사용하면 된다. 자주 사용하는 npm 명령어 목적 npm 명령어 package.json 생성 npm init 패키지 로컬 설치 npm install package-name 패키지 전역 설치 npm install -g package-name 패키지 개발 설치 npm install –save –dev package-name package.json의 모든 패키지 설치 npm install package.json의 모든 패키지 설치 npm install 로컬/개발 패키지 제거 npm uninstall package-name 전역 패키지 제거 npm uninstall -g package-name 패키지 업데이트 npm update package-name 버전 확인 npm -v npm 명령어 설명 참조 npm help","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://cheonmro.github.io/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://cheonmro.github.io/tags/Node-js/"},{"name":"Package.json","slug":"Package-json","permalink":"https://cheonmro.github.io/tags/Package-json/"}]},{"title":"Vue 프로젝트 Directory 구조","slug":"vue-project","date":"2018-12-22T08:23:03.000Z","updated":"2018-12-22T08:23:03.604Z","comments":true,"path":"2018/12/22/vue-project/","link":"","permalink":"https://cheonmro.github.io/2018/12/22/vue-project/","excerpt":"","text":"Vue 프로젝트 Directory 구조 생성 Vue 프로젝트를 vue-cli 명령어로 입력해서 프로젝트 구조를 생성한다.1vue create &lt;project name&gt; vue-cli 2.x 버전에서는 프로젝트 생성시, 선택가능한 템플릿(simple, webpack 등)이 있었으나, vue-cli 3 버전부터는 기본적인 프로젝트를 먼저 생성하고, 필요한 플러그인을 그때마다 추가하여 자신이 원하는 구조로 프로젝트를 변경할 수 있게 되었다. 플러그인 설치 기본적으로, 프로젝트를 생성할 때 pre-installed 플러그인을 추가하여 설치할 수 있다. 이후, 필요한 플러그인이 있을 때마다 다음과 같은 명령어로 이미 생성된 프로젝트에 플러그인을 추가할 수 있다.1vue add @vue/eslint @vue/eslint 명령어는 @vue/cli-plugin-eslint 명령어의 약어다. 플러그인 중에서 vue-roter와 vuex는 특별한 케이스로 다음과 같이 설치한다.12vue add routervue add vuex Vue 프로젝트 파일과 구조 Vue 프로젝트 생성시, 생성되는 파일과 구조는 다음과 같다. Directory/File Description dist Production용으로 빌드를 하면, 최종 결과물이 나오는 Directory public 공용으로 접근 가능한 Directory public/index.html 어플리케이션의 뼈대가 되는 html 파일 public/favicon.io 웹브라우저 주소창에 표시되는 웹사이트를 대표하는 아이콘 src 애플리케이션의 소스코드가 있는 Directory src/main.js Vue 인스턴스를 생성하는 javascript 파일 src/App.vue Vue 애플리케이션의 가장 최상위 컴포넌트 src/assets 이미지 등 static assets이 모여 있는 Directory src/components Vue 컴포넌트들이 모여 있는 Directory src/router.js Vue Router로 설정한 라우팅 정보 src/views 화면을 전체 구성하는 View와 관련된 파일(라우팅과 관련된 컴포넌트들이 모여 있는 Directory) test 테스트 관련된 코드가 있는 Directory babel.config.js babel을 위한 설정 파일 node_modules yarn 또는 npm으로 설치한 의존성 모듈들이 있는 Directory package.json Vue 프로젝트의 메타 정보와 해당 프로젝트에서 사용하는 패키지(모듈)(의존성관련 정보)들의 정보가 저장되는 파일 package-lock.json node_modules(의존성 트리) Directory에 대한 모든 정보를 가지고 있는 파일","categories":[{"name":"Vue","slug":"Vue","permalink":"https://cheonmro.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://cheonmro.github.io/tags/Vue/"}]},{"title":"Vue & MVVM Pattern","slug":"what-is-vue","date":"2018-12-20T15:32:39.000Z","updated":"2018-12-20T15:32:39.704Z","comments":true,"path":"2018/12/21/what-is-vue/","link":"","permalink":"https://cheonmro.github.io/2018/12/21/what-is-vue/","excerpt":"","text":"What is Vue? Vue.js 공식사이트에서는 Vue.js를 ‘점진적인 JavaScript 프레임워크’(The Progressive JavaScript Framework)라 소개한다. Vue.js의 코어 라이브러리는 React와 유사하게 데이터 바인딩과 컴포넌트에만 집중한다. 그러나 복잡한 대규모 애플리케이션을 개발하려면 라우팅, 상태 공유, 컴포넌트 간의 통신 등을 위해 별도의 수많은 도구가 필요해진다. Ember나 Angular는 이런 도구를 프레임워크에 내재하는 형태로 접근한다. React는 도구를 제공하는 역할을 커뮤니티를 통한 생태계에 맡기고 있다. Vue.js는 중간적인 형태로 접근을 한다. 코어는 최소한의 기능만 제공하고, 필요한 다른 도구는 별도로 제공한다. Vue.js의 도구는 모두 공식적으로 관리되고 완성도 높은 문서가 함께 제공된다. 출처: Vue 위에서 Vue.js는 프레임워크라고 말했지만, ‘점진적인’ 말에 주목해야 한다. 즉, Vue.js는 작은 화면단 라이브러리 역할부터 큰 규모의 웹 애플리케이션 개발을 돕는 프레임워크 역할까지 점진적으로 적용할 수 있는 프론트엔드 프레임워크를 말한다. Vue.js는 MVVM 패턴에서 View와 Model을 연결해주는 ViewModel 계층에 초점을 둔 프레임워크이다. 뷰모델을 통해서 양방향 데이터 바인딩이 가능하게 해주며, 뷰 계층을 좀 더 간단하고 유연하게 디자인하게 해준다. 즉, 모델과 뷰의 동기화 역할을 한다. MVVM Pattern MVVM 패턴이란, Mode - View - ViewModel의 줄임말로, 로직과 UI의 분리를 위해 설계된 패턴이다. 웹페이지는 돔과 자바스크립트로 만들어지게 되는데 돔이 View 역할을 하고, 자바스크립트가 Model 역할을 한다. 뷰모델이 없는 경우에는 직접 모델과 뷰를 연결해야 한다. 그러나 뷰모델이 중간에서 연결해 주는 것이 MVVM 모델이다. 출처: MVVM Pattern 사용자 인터페이스에 해당하는 뷰(View)와 뷰에 표시되는 데이터(Model) 그리고 뷰(View)와 모델(Model) 사이에서 여러 비즈니스 로직을 처리하는 뷰-모델(View-Model)로 분리하여, 유지보수를 쉽게하고 뷰(View) 처리에 다양한 기능을 사용할 수 있게 되었다. MVVM Pattern을 총 3개로 나눌 수 있다. Model (비즈니스 규칙, 데이터 접근, 모델 클래스) View (사용자 인터페이스) ViewModel (모델과 뷰 사이의 인터페이스) 뷰모델(ViewModel)은 모델(Model)과 뷰(View)사이에 인터페이스 역할을 한다.뷰모델은 모델의 데이터를 뷰에 바인딩하고, 명령어를 사용하여 모든 UI의 동작들을 다룬다.뷰는 뷰모델의 프로퍼티에 제어값을 바인딩하며 차례대로 모델 객체에 있는 데이터를 노출시킨다. 예를 들어 사용자가 뷰에 있는 계산기 프로그램을 사용하여 결과값을 요청하는 버튼을 클릭했을 때, 뷰모델이 요청받은 동작을 수행한다. 뷰모델의 연산 기능을 담당하는 명령어는 연산 후 모델의 데이터 값을 변경시킨다. 만약 뷰모델의 속성값이 변경되면(모델의 데이터 값이 변경되면) 새로운 속성 값들은 데이터 바인딩(data binding)과 알림(notification)을 통해 자동적으로 뷰에 적용된다. 간단한 코드로 보면 다음과 같다.123456789101112131415161718192021&lt;template&gt;// View&lt;div id = “app” &#123;&#123;message&#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;// Modelvar model = &#123; message : “뷰 생성&quot;&#125;// ViewModel new Vue(&#123; el : ‘#app’, data : model&#125;)&lt;/script&gt; 출처: MVVM Pattern Todo 앱으로 MVVM Pattern으로 개발하기 먼저, 부모 역할을 하는 Todolist.vue가 있는데, 여기서 Todo List App을 클릭하면, 라우터를 통해 홈(‘/‘)으로 이동한다. 12345678910111213141516171819&lt;template&gt; &lt;div id=&quot;todolistapp&quot;&gt; &lt;div id=&quot;header&quot; class=&quot;header&quot;&gt; &lt;router-link to=&apos;/&apos;&gt;&lt;h2&gt;Todo List App&lt;/h2&gt;&lt;/router-link&gt; &lt;router-link to=&apos;/note&apos;&gt;&lt;p&gt;Note&lt;/p&gt;&lt;/router-link&gt; &lt;/div&gt; &lt;br&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script type=&quot;text/javascript&quot;&gt;export default &#123; name : &apos;todo-list&apos;,&#125;&lt;/script&gt; 아래는, Todo를 추가할 수 있는 Todo.vue인데, 여기서는 InputTodo.vue와 List.vue를 보여준다. 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;input-todo /&gt; &lt;br&gt; &lt;br&gt; &lt;list&gt;&lt;/list&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import InputTodo from &apos;./InputTodo&apos;;import List from &apos;./List&apos;;export default &#123; name : &apos;todo&apos;, components : &#123; InputTodo, List &#125;&#125; 아래는, InputTodo.vue이다. 12345678910111213141516171819202122232425262728&lt;template&gt; // View &lt;div&gt; &lt;input class=&quot;input&quot; type=&quot;text&quot; id=&quot;task&quot; v-model=&quot;todo&quot; placeholder=&quot;입력 후 엔터!&quot; v-on:keyup.enter=&quot;addTodo&quot;&gt; &lt;span class=&quot;addbutton&quot; v-on:click=&quot;addTodo&quot;&gt;추 가&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script type=&quot;text/javascript&quot;&gt;import eventBus from &apos;../EventBus&apos;// ViewModelexport default &#123; name : &apos;input-todo&apos;, // Model data : function() &#123; return &#123; todo : &quot;&quot; &#125; &#125;, methods : &#123; addTodo : function() &#123; console.log(this.todo); eventBus.$emit(&apos;add-todo&apos;, this.todo); this.todo = &quot;&quot;; &#125; &#125;&#125;&lt;/script&gt; 아래는, List.vue이다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;template&gt; // View &lt;ul id=&quot;todolist&quot;&gt; &lt;li v-for=&quot;a in todolist&quot; :key=&quot;a.id&quot; :class=&quot;checked(a.done)&quot; @click=&quot;doneToggle(a.id)&quot;&gt; &lt;span&gt;&#123;&#123; a.todo &#125;&#125;&lt;/span&gt; &lt;span v-if=&quot;a.done&quot;&gt; (완료)&lt;/span&gt; &lt;span class=&quot;close&quot; v-on:click.stop=&quot;deleteTodo(a.id)&quot;&gt;&amp;#x00D7;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script type=&quot;text/javascript&quot;&gt;import eventBus from &apos;../EventBus&apos;// ViewModelexport default &#123; created : function() &#123; eventBus.$on(&apos;add-todo&apos;, this.addTodo); &#125;, // Model data : function() &#123; return &#123; todolist : [ &#123; id:1, todo : &quot;vue&quot;, done:false &#125;, &#123; id:2, todo : &quot;react&quot;, done:true &#125;, &#123; id:3, todo : &quot;python&quot;, done:false &#125;, &#123; id:4, todo : &quot;java&quot;, done:false &#125;, ] &#125; &#125;, methods : &#123; checked : function(done) &#123; if(done) return &#123; checked:true &#125;; else return &#123; checked:false &#125;; &#125;, addTodo : function(todo) &#123; if (todo !== &quot;&quot;) &#123; this.todolist.push( &#123; id:new Date().getTime(), todo : todo, done:false &#125;); &#125; &#125;, doneToggle : function(id) &#123; var index = this.todolist.findIndex((item)=&gt;item.id === id); this.todolist[index].done = !this.todolist[index].done; &#125;, deleteTodo : function(id) &#123; var index = this.todolist.findIndex((item)=&gt;item.id === id); this.todolist.splice(index,1); &#125; &#125;&#125;&lt;/script&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://cheonmro.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://cheonmro.github.io/tags/Vue/"},{"name":"MVVM","slug":"MVVM","permalink":"https://cheonmro.github.io/tags/MVVM/"}]},{"title":"What Is Stablecoin?","slug":"what-is-stablecoin","date":"2018-12-18T13:59:50.000Z","updated":"2018-12-18T13:59:50.947Z","comments":true,"path":"2018/12/18/what-is-stablecoin/","link":"","permalink":"https://cheonmro.github.io/2018/12/18/what-is-stablecoin/","excerpt":"","text":"What Stablecoin Is A stablecoin is cryptocurrency with stable prices. It is pegged to another stable assets such as gold or U.S dollar in order to minimize volatility. For instance, because Tether(USDT) is pegged to the U.S dollar, it is traded for $1 USD, which is a blockchain based asset. Functions of Stablecoin There are three functions of stablecoin: Medium of exchange: the ability to trade goods and services without bartering Store of value: means of maintaining wealth over time Unit of account: measurement unit to define and compare market values How Stablecoin Works Stablecoin holds collateral of some type and manages the supply to help incentivize the market to trade the coin for no more or less than $1. For Tether or TrueUSD, the concept is to hold actual dollars in reserve that are redeemable for the token. For others, like Dai, they hold crypto assets in reserve and have a lending system. Stablecoin Market Map 출처: Stablecoin Market Map","categories":[{"name":"Blockchain(Market)","slug":"Blockchain-Market","permalink":"https://cheonmro.github.io/categories/Blockchain-Market/"}],"tags":[{"name":"Stablecoin","slug":"Stablecoin","permalink":"https://cheonmro.github.io/tags/Stablecoin/"},{"name":"Cryptocurrency","slug":"Cryptocurrency","permalink":"https://cheonmro.github.io/tags/Cryptocurrency/"}]},{"title":"암호화폐는 화폐 혁명을 이루어 낼것인가?","slug":"cryptocurrency-revolution","date":"2018-11-19T07:21:03.000Z","updated":"2018-11-19T07:21:03.895Z","comments":true,"path":"2018/11/19/cryptocurrency-revolution/","link":"","permalink":"https://cheonmro.github.io/2018/11/19/cryptocurrency-revolution/","excerpt":"","text":"인류사에 혁명적인 사건, 화폐의 발명 인류사에 있어서 화폐의 발명은 가장 중요한 사건 중 하나다.화폐는 대부분 진보의 근원이었다. 이를 통해, 교환과 분업과 협력이 가속화되어 문명이 발전했다. 화폐의 발명이후 그 형태는 지속적으로 변화해왔다. 지폐가 디지털화되어 가상화폐가 등장했고, 2009년에는 드디어 탈중앙화 암호화폐가 선보였다. 암호화폐가 만들어진 배경에는 기존화폐가 해결하지 못하는 문제가 있었고, 암호화폐는 결국 필요에 의해 나온 것이다. 기존화폐의 문제점 그럼, 기존화폐의 문제는 무엇인가? 그것은 바로 인플레이션의 위험이다. 그리스와 로마제국을 포함해 끝나지 않을 것 같던 강대한 문명들을 망하게 한 것이 인플레이션이었다. 화폐를 무분별하게 발행하고, 화폐 가치를 절하시키면서 결국 초인플레이션을 초래했다. 마침내 화폐는 신뢰를 잃고 결국 그 문명은 붕괴되었다. 그러나, 정부의 재정수입 원천으로서 인플레이션은 항상 매력적인 선택이었다. 경기침체 시 중앙은행의 무리한 금리인하와 신용창출은 경기의 단기적 회복을 위해 인플레이션의 리스크를 감수하는 꼴이다. 더 나아가 민간 중앙은행이 시행하는 국가의 통화정책은 금융세력들의 이익에 따라 휘둘리고 있다. 또 민간 중앙은행은 금융세력들의 이득을 위해 유동성을 무책임하게 늘림으로써 세계 경제를 잠재적 위험에 빠트리고, 이로 인해 각 나라마다 피곤한 환율전쟁을 치르고 있다. 게다가 미국은 그간 달러의 패권을 이용해 다른 나라들을 상대로 많은 횡포를 벌여왔다. 이런 상황을 참다못해 나온 것이 암호화폐다. 암호화폐는 중앙집권을 타파하고, 임의로 발행량을 늘리는 인플레이션의 위험을 총 발행량 사전 설정을 통해 원천 차단했다. 하지만, 미국의 화폐 역사에서 봤듯이, 다수 민간은행들의 화폐 발행으로 인한 화폐의 범람 역시 많은 문제를 노출했다. 암호화폐 또한 이 문제에서 자유롭지 않다. 중앙은행 존재 자체가 문제가 잘못된 것은 아니다. 많은 대안 중 최선책으로써, 중앙은행의 화폐 발행과 은행들의 부분지급준비제도는 경제 발전을 촉진하고, 특히 경제위기 시 침체된 경기를 활성화시키는 순기능이 있어 경제사에서 중요한 역할을 했다는 사실은 인정해야 한다. 그렇다면 문제는 무엇인가? 문제는 필요 이상으로 과도한 화폐 발행과 신용창출을 할 수밖에 없는 사회정치적 구조다. 금융세력은 적절한 수준의 화폐 발행과 신용창출로는 만족하지 않으며, 끝없는 부의 창출을 위해 지속적으로 통화량을 늘리려 한다. 오늘날 미국의 금권정치 구조에서는 정부가 금융세력에 휘둘릴 수밖에 없다. 암호화폐의 출현 이러한 상황에서 암호화폐의 탄생은 그 의미가 크다. 이제 정부 주도의 화폐에만 의존하지 않고 인플레이션의 위험이 없는 민간화폐도 함께 사용할 수 있게 되었다. 사람들에게 선택권을 주어 두 종류의 화폐가 서로 견제와 균형을 이루고, 서로의 장단점을 상호보완할 수 있는 구조가 마련되었다. 더 크게는 기존 화폐로 인한 인플레이션이 발생할 경우 이에 대한 대안이 생긴 것이다. 화폐는 애초에 중앙집권의 통제 없이 생겨났다. 화폐 발행량, 유동량, 환율이 모두 시장의 보이지 않는 손에 의해 결정되었다. 이후 사회가 성장함에 따라 정부의 손으로 넘어갔다. 화폐가 경제의 힘에서 정치의 힘으로 넘어간 것이다. 이 체제에 도전해 혁명을 일으킨 게 암호화폐다. 기존 화폐를 조절하는 기득권자들의 이익을 위해 감행하던 인플레이션이 감소하고, 더 나아가 소득과 부의 불평등이 완화될 단초도 마련했다. 이 두 과제가 현대사회가 안고 있는 가장 심각한 문제임을 감안할 때 암호화폐의 의미를 파악할 수 있다. 이런 해결책을 가진 암호화폐가 화폐혁명을 이루기 위해, 어떤식으로 접근하면서 기존 화폐의 문제점을 보완할 수 있을까?","categories":[{"name":"Blockchain(Market)","slug":"Blockchain-Market","permalink":"https://cheonmro.github.io/categories/Blockchain-Market/"}],"tags":[{"name":"Cryptocurrency","slug":"Cryptocurrency","permalink":"https://cheonmro.github.io/tags/Cryptocurrency/"},{"name":"Finance","slug":"Finance","permalink":"https://cheonmro.github.io/tags/Finance/"},{"name":"Cryptocurrency Revolution","slug":"Cryptocurrency-Revolution","permalink":"https://cheonmro.github.io/tags/Cryptocurrency-Revolution/"}]},{"title":"금융의 새로운 패러다임, 암호화폐(성숙기)","slug":"cryptocurrency-maturity-stage","date":"2018-11-19T06:36:41.000Z","updated":"2018-11-19T06:36:41.119Z","comments":true,"path":"2018/11/19/cryptocurrency-maturity-stage/","link":"","permalink":"https://cheonmro.github.io/2018/11/19/cryptocurrency-maturity-stage/","excerpt":"","text":"암호화폐 성숙기 성숙기에는 암호화폐가 과연 어떤 역할을 하고 있을까?과연 달러를 제치고 세계 기축통화가 될 것인가? 이에 대한 답을 얻기 위해서는 과거와 현재, 그리고 미래의 달러를 보자. 미국은 지난 37년간 한번도 무역흑자를 낸 적이 없고, 재정수지도 지난 40년간 4년을 제외하곤 계속 적자 행진이다. 무역적자와 재정적자를 합쳐 ‘쌍둥이 적자’라고 하는데, 미국은 이 쌍둥이 적자를 겪고 있는 듯 하다. 1985년 플라자 합의를 통해 무역경쟁국인 일본의 엔화와 독일의 마르크화를 절상시켰음에도, 미국은 수출상품의 경쟁력 회복에 실패했다. 이러한 과도한 무역적자의 누적은 국제 금융 시스템과 세계 경제의 안전성까지 위협하고 있는 실정이다. 증대하는 미국의 부채 대규모 재정적자의 원조는 레이건 대통령이다. 레이건은 집권하자마자 부자들의 세율을 50%나 삭감했다.레이건이 감세와 재정적자의 원조였다면, 부시 부자는 이를 집대성하고 완성했다. 미국의 다양한 부채와 주정부 등 지방자치단체가 발행한 지방채도 많이 있다. 트럼프가 대규모 감세안 통과로 세수로 매년 1000억 달러 정도 줄어드는 상황에서 예산까지 늘면서 2018년 2월 현재 미국의 국가부채는 21조 달러에 달하고 있다. 달러는 태생적으로 트리핀 딜레마를 갖고 있어 부채가 영원히 지속될 수 없다. 미국이 지금은 겉으로는 강해 보이지만, 국가부채가 계속 늘어나면 과거의 제국들처럼 쇠락의 전철을 밟을 수밖에 없다. 드디어, 암호화폐의 시대가 온다 이렇게 위태로운 달러가 암호화폐의 성숙기가 되면 어떻게 될까? 성숙기에 암호화폐는 더 이상 새로운 기술이 아니며 각국 정부에서도 이를 적극 활용하게 될 것이다. 이 시대에는 종이화폐가 사라지고 전적으로 디지털 화폐의 시대가 된다. 예로, 2010년 30%였던 우리나라 스타벅스의 현금 결제율이 2018년에 20%로 떨어졌고, 사무실 지역에서는 3%가 채 안된다. 암호화폐의 중요도가 증가하고, 시세가 오랜 기간 안전성을 유지함에 따라 국제무역에 있어서 암호화폐가 패권을 쥐게 될 것이다. 대부분의 국가는 무역을 할 때 어느 한 곳에 속박되지 않은 중립적인 화폐로 하는 것을 좋아한다. 또한 세계 각국의 준비통화에서도 암호화폐의 비중이 높아진다. 이렇게 되면 세계 경제는 바야흐로 ‘달러 스탠다드’에서 ‘암호화폐 스탠다드’로 넘어갔다고 볼 수 있다. 성숙기에 가장 화두로 떠오르는 경제 주제는 세계화폐다. 각국의 정부는 극도로 밀접하게 움직이고, 점차 세계정부와 같은 하나의 단합된 조직을 형성한다. 국가간 무역과 금융거래가 날로 증가하면서 환전의 번잡함과 비효율성이 대두되고 세계화폐의 필요성이 제기 될 것이다. 19개의 유럽 국가들은 하나의 화폐인 유로화를 사용하면서 국가 간 무역과 각국의 경제 운영이 단일화폐로도 문제없이 돌아감을 입증했다. 세계화폐는 유로화의 범주를 유럽에서 세계로 넓히는 개념일 뿐이다. 암호화폐, 과연 세계화폐가 될 것인가? 세계화폐라는 개념을 통해 안정된 국제 통화체제를 생각한 것은 경제학자인 케인즈였다. 1944년에 케인즈가 세계화폐에 대한 제안한 내용은 다음과 같다. 국제청산동맹이 각 가맹국의 국제무역 비중을 고려해 일정 한도의 방코르를 배정한다. 각 가맹국의 수입초과가 누적되면 방코르가 부족해지는데, 이때는 벌금(이자)을 물고 방코르에 대한 자국의 화폐 가치를 내려야 한다. 그렇게 되면, 해외자본이 유입돼 적자분을 채울 수 있다. 반대로 수출이 많아 방코르가 쌓일 경우에도 일정액 이상이 쌓이면 해당하는 금액에 대해 벌금을 물고 화폐 가치를 올려야 한다. 그렇게 되면 자본이 유출된다. 케인즈는 이 시스템으로 불균형 자본유출, 변동성, 부족한 총 수요, 불 필요한 실업사태가 나타나는 현상을 줄이고 국제무역의 균형을 유지할 수 있다고 여겼다. 국제무역 불균형으로 인한 무역분쟁과 환율전쟁을 막으려 했던 케인즈의 취지를 살리려면 다양한 환율정책을 수용하고 각국 관료들의 자유 재량권을 일정 수준 제한하는 규칙을 마련해 새로운 국제청산동맹을 만들어야 한다. 2008년 글로벌 금융위기를 맞아 세계 금융 시스템에 경종이 울리자 케인즈가 설계했던 세계화폐를 디지털 화폐로 실행하자고 주장하는 사람이 있는데, 그는 전 그리스 재무장관인 야니스 바루파키스다. 그에 따르면, 케인즈가 제안했던 세계화폐 방코르는 국제교역량에 따라 수급을 조정하는 알고리즘을 갖춘 디지털 화폐로 대체하고, 그 발행과 관리 책임을 IMF가 지도록 하면 된다. 세계 경제의 불균형을 막는다는 취지를 살리기 위해 중요한 것은 두 가지다. 첫째, 무역불균형에 대한 과세다. 가맹국의 디지털 화폐 계정에 무역수지 적자와 흑자를 반영해, 수입 누적이나 수출 누적에 따라 국제청산동맹에 추가부담금을 내도록 하는 것이다. 둘째, 자본 유출입 비중에 따라 각국의 민간 금융기관 역시 국제청산동맹에 같은 비중으로 부담금을 내도록 하는 것이다. 무역불균형에 대한 부담금 부과는 무역흑자국 정부가 내수활성화에 더 힘을 쏟도록 하고, 무역적자국이 흑자국에 대해 수출을 늘리는 원동력이 될 수 있다. 외국환시장 참가자들은 무역수지 불균형에 대응하기 위해 더 빠르게 환율조정에 나설 것이며, 만성 무역수지 불균형의 주요 원인이돼온 자본유출 문제도 어느 정도 해결될 것이다. 케인즈의 제안이 제대로 이뤄지려면 오늘날과 같은 ‘디지털 기술’과 ‘외환시장’이 필요했다. 지금은 모든 요건이 갖춰졌다. 바루파키스에 따르면, 달러가 기축통화의 짐을 내려놓을 때, 그 뒤를 잇는 건 세계화폐이자 디지털 화폐인 암호화폐가 될 것이다. 라고 했다. 과연 언제쯤 달러가 기축통화인 시대가 막을 내릴 것인가? 참고: 화폐혁명","categories":[{"name":"Blockchain(Market)","slug":"Blockchain-Market","permalink":"https://cheonmro.github.io/categories/Blockchain-Market/"}],"tags":[{"name":"Cryptocurrency","slug":"Cryptocurrency","permalink":"https://cheonmro.github.io/tags/Cryptocurrency/"},{"name":"Finance","slug":"Finance","permalink":"https://cheonmro.github.io/tags/Finance/"},{"name":"Maturity Stage","slug":"Maturity-Stage","permalink":"https://cheonmro.github.io/tags/Maturity-Stage/"}]},{"title":"금융의 새로운 패러다임, 암호화폐(성장기)","slug":"cryptocurrency-growth-stage","date":"2018-11-18T08:25:22.000Z","updated":"2018-11-18T08:25:22.363Z","comments":true,"path":"2018/11/18/cryptocurrency-growth-stage/","link":"","permalink":"https://cheonmro.github.io/2018/11/18/cryptocurrency-growth-stage/","excerpt":"","text":"암호화폐 성장기 2018년 2월 기준으로 거래소에 상장된 암호화폐가 약 1500개가 넘고, 모든 암호화폐의 시가총액은 400조원을 웃돌고 있다. 암호화폐가 너무나도 많다. 그러나, 이 수많은 암호화폐 중 결국 극소수만이 살아남아 세상에 영향력을 미칠 것이다. 20년전 인터넷 붐이 일어나던 시절에 수많은 닷컴 기업들이 출현했지만, 결국 극소만만 살아남아 세계를 지배하고 있듯이, 암호화폐 시장도 마찬가지가 될 것이다. 암호화폐 통합과 독과점 암호화폐 시장의 이러한 치열한 경쟁이 가져올 결과는 어떤 모습일까?–&gt; 분화된 시장의 통합과 독과점으로 귀결될 공산이 크다. 전 골드만삭스 대표이자 전 백악관 국가경제위원장 게리 콘(Gary Cohn)은 암호화폐의 미래에 대해 ‘언젠가 전 세계에서 통용될 수 있는 단일 암호화폐가 등장할 것’이라는 긍정적 전망을 했다. 채굴비용이나 전기세와 무관한 글로벌 암호화폐를 사용하게 될 것이라고 밝혔다. 비트코인과 같이 지나치게 많은 자원을 소모하는 암호화폐 대신 좀 더 효율적이고 대중적인 암호화폐가 나올 것이라고 전망했다. 검색엔지 시장에서는 구글이, 소셜미디어 시장에서는 페이스북이 최고가 되었다. 그럼, 암호화폐 시장에서는 어떤 기업이 최고가 될 것인가? 인터넷의 본질적인 힘이 확장성인 만큼 잘되는 서비스는 국경을 넘어 전 세계로 확장되면서 독과점의 형태로 발전할 것이다. 지금껏 IT업계에서는 1세대의 실수를 보완한 2세대 기업이 시장을 장악하는 경우가 많았듯, 암호화폐 역시 1세대의 문제점을 보완한 2세대가 주인공이 될 가능성이 크다. 현재 비트코인의 후속주자로 나오고 있는 새로운 암호화폐들을 보면 두 종류다. 라이트코인처럼, 비트코인을 보완하러 나온 보완재 비트코인과 공생하기 위한 게 아니라 기존 암호화폐의 기술적 한계점을 해결한 업그레이드된 대체재 다양한 대안이 존재하는 상황에서 궁극적인 선택은 암호화폐의 사용자들이 내릴 것이다. 현재 암호화폐 사용자들은 기술력과 활용 가능성이 아닌 가치 상승 가능성을 기준으로 코인을 선택하고 있다. 하지만, 장기적으로는 화폐 자체의 활용성과 확장성을 기준으로 삼을 것으로 보인다. 화폐의 존재 목적은 투자용 상품이 아니라 교환매체와 가치저장의 수단이기 때문이다. 암호화폐 독과점의 이득과 위험 한두 개 화폐가 독과점을 한다는 것은 무슨 의미를 가질까? 이는 우선 ‘대중화’를 뜻한다.수많은 암호화폐 가운데 시장이 어느 한 가지 화폐를 선택하게 되면, 그것은 암호화폐를 진정으로 대중화시킬 것이다. 암호화폐 독과점의 이득 1. 해당 암호화폐는 그것으로 무엇이든 살 수 있을 정도로 널리 활용될 것이다. 편의점에서 아침을 사 먹고, 택시를 타고 출근하고, 서점에 책 사고하는 이 모든 것을 그 암호화폐 하나로 가능해질 것이다. 원하면, 월급도 해당 화폐로 받을 수 있다. 또한, 해당 화폐를 더욱 안전하게 보관할 수 있는 암호화폐 전문은행들이 생길 것이다. 세계 어디를 가든 이 화폐 하나만 있으면 환전할 필요가 없으며, 지금 종이화폐로 할 수 있는 모든 것을 암호화폐가 대체하게 될 것이다. 2. 이 화폐가 장기적으로 시장을 독점할 것이라는 신뢰가 생기면 화폐 가치가 치솟을 것이다. 현재 가장 유명한 암호화폐는 비트코인이지만, 비트코인은 기술적인 한계로 인해 1초에 네 건의 거래만 처리할 수 있고, 또 갈수록 비싸지는 채굴비용으로 인해 장기적 활용 가능성에 대해 의문점이 많은 상황이다. 그럼에도 비트코인의 시가총액은 200조원을 바라보고 있다. 그러면 현재의 기술적인 제한을 해결해 세상 모든 사람들이 문제없이 사용할 수 있는 암호화폐가 나오면 어떻게 될까? 그 암호화폐는 진정한 장기적 신뢰를 받아 지금의 100배 이상인 1경, 10경의 시가총액을 갖게 될 것이다. 암호화폐 독과점의 위험 모든 업계가 다 그렇다. 성공기업 하나에 실패기업 열 개가 따르는 법이다. 안타까운 사실은 주식시장 등의 기존 투자 분야들에 비해 암호화폐는 특히 일반 투자자들에게 유독 큰 손실을 안긴다는 것이다. 주식시장에서는 기업들이 비교적 초기단계에 실패하여 정리된다. 대중이 투자하기전, 상장하기전에 정리가 된다. 그러나, 암호화폐의 경우는 다르다. 시장의 검증이 전혀 없었던 수많은 창업기업이 대중으로부터 투자를 바로 받기 시작한다. 즉, 크게 봤을 때 암호화폐 시장은 주식시장보다 훨씬 위험한 투자처다. 시장을 주도하는 암호화폐가 되기 위해서는 무엇이 필요할까? 1세대 암호화폐인 비트코인을 포함한 현 암호화폐들이 지닌 기술적 한계점을 해결해야 한다. 1. 가장 대표적인 기술적 문제는 1초에 감당 가능한 거래수다. 현재 비트코인의 3~7건이 아니라 Visa에서 감당 가능한 2000건을 능가해야 한다. 더 나아가서는 전 세계 사람들이 일상의 모든 거래를 암호화폐로 진행하더라도 감당할 수 있을 수준이 되어야 한다. 또한, 보안, 운영 소요비용과 에너지 등의 이슈들을 해결해야 한다. 2. 세금 문제가 투명하게 이뤄질 수 있어야 한다. 암호화폐로 사업하는 기업이 결제를 위해 암호화폐를 주고받거나, 개인이 암호화폐를 증여받을 때, 어떤 통제도 안 되는 구조를 정부가 허용할 수 없다. 정부의 암호화폐 규제가 완화되는 가장 중요한 조건은 세금이 현재보다 더욱 투명하게 걷히는 것이다. 이를 위해서는 암호화폐의 익명성이 정부에게만 예외가 되는 방식이 필요할 수 있다. 3. 특정 이익추구 단체에서 중앙집권하지 않는 탈중앙 분산관리 오픈소스여야 한다. 근본적으로 이익추구 단체에서 화폐를 운영하는 것은 정부의 중앙집권 화폐와 다를 바 없다. 오히려 정부의 지지가 없기에 훨씬 변동성이 크며 집권단체의 이익에 편향된다. 사카시 나카모토가 비트코인을 만든 주목적은 탈중앙 화폐의 실현이며, 이를 중앙집권 없이 운영하기 위한 수단이 블록체인 기술이다. 따라서, 암호화폐의 본질은 블록체인 기술의 사용이 아니라 탈중앙 화폐에 있다는 점을 간과해서는 안된다. 4. 현존하는 암호화폐들과 반대되는 성격의 것이다. 미래의 선두 암호화폐는 적정한 수준의 인플레이션 기반 화폐가 될 가능성이 있다. 비트코인은 총 화폐 발행량 2100만 BTC로 고정되어 있고, 미발행 화폐의 발행 속도는 갈수록 줄어드는 통화 수축형 디플레이션 기반 화폐다. 하지만 디플레이션에서는 시장이 성장해가도 화폐가 한정되어 있기 때문에 화폐의 가치가 계속 올라간다. 화폐의 구매력이 현재보다 미래에 올라갈 것이라 예상되면 사람들은 그 화폐를 사용하지 않고 소지하려 한다. 이는 소비를 늦추고, 화폐 유통량을 줄여 경기침체로 이어진다. 현재 비트코인을 포함한 대부분의 암호화폐가 디플레이션 기반이기 때문에, 장기적으로 보관하는 자산으로는 좋은 투자 대상이 될 수 있지만, 일상의 소비를 위한 화폐로는 근본적으로 부적절하다. 암호화폐가 꼭 지금과 같아야만 하는 것은 아니다. 암호화폐도 기존 화폐들처럼 화폐 발행량을 제한시키지 않고, 매해 세계 GDP 성장 수준에 맞추어 늘려가는 것을 상상해볼 수 있다. 암호화폐도 이런 기준으로 화폐 발행정책을 설정한다면 인플레이션이나 디플레이션이 없는 통화로 운영될 수 있다. 어쩌면 밀턴 프리드먼이 주장하던 k% 준칙이 드디어 알고리즘화되어 실현되는 시대가 올 수도 있다. 정부의 전략 전환, 규제 아닌 상생 각국 정부의 규제에도 불구하고 세계적으로 암호화폐 사용 비중이 올라감에 따라 정부는 규제보다는 상생으로 전략을 전환할 것이다. 초기 인터넷으로 음악 영화 공유하는 것을 규제에서 합벅적으로 소비할 수 있게 구조화 시킨것과 같다. 정부와 암호화폐와의 공식협력이 이뤄지면 민간 암호화폐가 정부 차원에서 인정받는 결제수단이 되고, 더 나아가 법정화폐로 자리 잡게 될 것이다. 암호화폐의 단점 사회에 인플레이션이 심화될수록, 암호화폐는 주목을 받게 되지만, 성장기에서는 반대로 암호화폐의 본질적인 단점이 주목을 받게 된다. 바로 중앙집권 없이는 경제적 재난상황에 대응하지 못한다는 점이다. 공황이 들이닥쳐 암호화폐의 유통량이 급감하면 화폐로서 시장의 신뢰를 순식간에 잃게 된다. 이러한 사건을 계기로 중앙은행의 화폐 발행과 유통량 조절의 순기능이 재조명받게 될 것이다. 밀턴 프리드먼과 케인즈는 경제에서 심각한 공황이 있을 시에는 정부와 중앙은행의 개입이 필요하다는 것에 동의했다. 암호화폐도 이러한 개입이 필요한 상황이 오게 되며, 이때 암호화폐 발행량정책에 대한 다양한 논의가 일어날 것이다. 암호화폐의 가능성 성장기가 암호화폐의 한계를 현실적으로 받아들이는 기간이기는 하지만, 크게는 확실한 입지구축과 경제에서 의미 있는 비중을 차지하게 되는 엄청난 발전의 기간이 될 것이다.암호화폐의 발전에 따라 주요 암호화폐 간의 시너지 효과가 생겨날 것이다. 가령 정부발행 암호화폐와 민간발행 암호화폐 간의 시너지도 예상된다. 정부발행 암호화폐에 인플레이션이 발생하면, 사람들이 민간발행 암호화폐로 재산을 옮기고, 민간 암호화폐의 가격 변동이 극심해지면 정부발행 암호화폐로 재산을 옮길 수 있다. 결국 자산관리에 있어서 다양한 선택권이 생기는 것이며, 안 좋은 상황에서도 자신의 재산을 보호할 수 있는 헤징이 되는 것이다.","categories":[{"name":"Blockchain(Market)","slug":"Blockchain-Market","permalink":"https://cheonmro.github.io/categories/Blockchain-Market/"}],"tags":[{"name":"Cryptocurrency","slug":"Cryptocurrency","permalink":"https://cheonmro.github.io/tags/Cryptocurrency/"},{"name":"Finance","slug":"Finance","permalink":"https://cheonmro.github.io/tags/Finance/"},{"name":"Growth Stage","slug":"Growth-Stage","permalink":"https://cheonmro.github.io/tags/Growth-Stage/"}]},{"title":"금융의 새로운 패러다임, 암호화폐(도입기)","slug":"cryptocurrency-introduction-stage","date":"2018-11-13T02:35:58.000Z","updated":"2018-11-13T02:35:58.947Z","comments":true,"path":"2018/11/13/cryptocurrency-introduction-stage/","link":"","permalink":"https://cheonmro.github.io/2018/11/13/cryptocurrency-introduction-stage/","excerpt":"","text":"암호화폐 시장의 각 단계 패러다임을 가져오는 모든 신기술은 각 단계를 거쳐 성장한다. 도입기 - 성장기 - 성숙기 - 쇠퇴기 심리학자 토니 로빈스에 따르면, ‘사람들은 앞으로 1년 안에 이뤄낼 수 있는 일들을 과대평가하고, 20년 안에 이뤄낼 수 있는 일들을 과소평가한다’ 말한다. 암호화폐 발전도 이와 같을 것이다. 암호화폐가 나오기 시작한지 몇년 안된 지금은 여러가지 기술적, 사회적으로 문제가 많지만, 하나씩 문제를 해결해 발전하게 되면 지금과는 상상할 수 없는 영향력을 갖게 될 것이고, 이에 따라 현재의 금융 생태계에 엄청난 영향을 끼칠 수 있는 ‘패러다임 시프트’ 기술이 될 것이라고 생각한다. 암호화폐 도입기 현재(2018년 11월) 우리는 암호화폐에 도입기에 있다고 볼 수 있는데, 시장에 약 2,000개의 암호화폐가 있기 때문이다. 그야말로, 암호화폐의 춘추전국시대라고 할 수 있다. 앞으로 나올 암호화폐의 종류를 크게 3가지로 나누면 다음과 같다. 비트코인과 같은 본질적으로 화폐의 디지털화를 꿈꾸는 암호화폐 주식회사 형태의 기업들에서 출시하는 코인 또는 토큰의 암호화폐 정부기관들에서 발행하는 암호화폐 1. 비트코인과 같은 본질적으로 화폐의 디지털화를 꿈꾸는 암호화폐 이런 암호화폐들은 비영리재단으로 운영되고, 화폐를 만드는 주체의 이익에 국한되지 않도록 설계될 것이다. 또한, 오픈소스로 프로젝트를 공개하기 때문에, 누구나 참여하여 문제를 해결하고 공유할 수 있다. 예를 들어, 이더리움은 이더리움 재단(Ethereum Foundation)에서 비영리로써 운영되고, 모두 오픈소스 프로젝트들이다. 이러한 암호화폐들은 자유주의 사상을 밑바탕에 깔고 탈중앙화 분산관리를 지향하고 있다. 특정한 상황이나 정해진 업계에서만 사용하는 코인이 아니라 현재의 종이화폐 역할을 할 수 있는 범용 암호화폐다. 즉, 이것은 사토시 나카모토의 의도에 가장 가까운 것이다. 2. 주식회사 형태의 기업들에서 출시하는 코인 또는 토큰의 암호화폐 기업은 ICO 형태로 암호화폐를 발행할 것이다. 기업이 이런 방식으로 암호화폐를 발행하게 되면 2가지 이득이 있다. 쉽게 자금을 유치할 수 있다. 토큰의 수요가 많아지면, 해당 토큰을 대량으로 보유하고 있는 기업의 자산가치 또한 상승한다. 예를 들어, 어떤 대기업에서 자체 토큰을 발행한다면, 그 기업의 이미지로 인해 시작부터 엄청난 수요를 갖고 만들어질 것이다. 많은 사람들은 그 토큰을 많이 구매하게 될 것이고 이에 따라 그 대기업은 많은 자금을 쉽게 모을 수 있을 것이다. 기업이 ICO를 통해 자금을 ICO를 통해 자금을 유치하는 이유는, 그 자체의 시뇨리지 효과와 더불어 화폐의 가치상승을 노리기 때문이다. 시뇨리지란, 화폐를 발행함으로써 얻는 이익으로, 화폐의 액면가에서 제조비용을 뺀 금액을 말한다. 또한, 화폐 발행 이후, 토큰에 대한 수요가 많아지게 되면, 해당 토큰을 대량으로 보유하고 있는 기업의 자산 가치가 올라가게 된다. 이런 기업들은 기업의 이익에만 관심이 있지, 화폐의 디지털화나 자유주의 사상에는 큰 관심이 없다. 3. 정부기관에서 발행하는 암호화폐 각국 정부와 중앙은행은 암호화폐에 대해 다양한 방식으로 대응하고 있다. 국가 주도로 암호화폐 발행은 이미 시작되었고, 그 발행 동기와 화폐의 형태 역시 다양하다. 암호화폐 발행을 적극적으로 하는 국가의 종류는 다음과 같다. 초인플레이션으로 경제난을 경험한 남미국가들 달러에 적대적인 반미국가들 앞으로 국가 단위의 암호화폐와 경제권역별 암호화폐들이 가세할 예정이다. 이로써, 각 경제블록은 현재 글로벌 패권을 쥐고 있는 달러로 무역을 하지 않고, 자신들만의 화폐를 활용해 무역하려 할 것이다. 현재 암호화폐 발행을 진행하고 있는 대표적인 국가들을 살펴보자. 1. 에콰도르2015년 에콰도르는 세계 최초의 암호화폐 발행을 시도한 국가가 되었다. 미국 달러를 공식화폐로 사용하던 에콰도르는 달러와 동일한 가치를 갖는 국가 암호화폐 ‘전자화폐 시스템’의 발행 계획을 공표했다. 발행 주체가 에콰도르 중앙은행이다. 비록 달러와 동일한 가치를 두기에 독자적인 화폐 개념은 아니지만, 이로써 에콰도르는 화폐 발행권을 갖게 되었다. 2. 베네수엘라진정으로 독자적인 가치를 갖는 암호화폐의 첫 국가 발행은 베네수엘라다. 석유 기반 가상화폐 ‘페트로’를 발행한 베네수엘라는 일부 전문가들의 우려와 달리 사전판매 첫날인 2018년 2월 20일 7억 3500만 달러의 페트로 판매에 성공했다. 페트로의 총 발행량은 1억 토큰으로, 약 60억 달러어치다. 1페트로의 판매단가는 베네수엘라산 원유 1배럴 가격을 기준으로 한 60달러다. 이후 화폐 가치는 유가시장 변동에 따라 변한다. 베네수엘라의 마두로 대통령은 페트로를 통해 베네수엘라의 독립성과 경제 주권을 강화할 것이라고 했다. 주로 관광, 휘발유 판매와 석유 거래가 주로 이뤄질 예정이라고 했다. 마두로 대통령은 페트로를 통해 최저 수준으로 떨어진 경제와 과잉 인플레이션을 해결하기를 바라고 있다. 베네수엘라는 미국과 유럽연합의 경제제재 속에서 심화한 경제난과 유동성 위기를 겪고 있다. 3. 이란대표적 반미국가로써, 정부 주도의 암호화폐 발행을 서두르고 있다. 이란의 중앙은행인 포스트뱅크가 클라우드 기반 암호화폐를 개발하고 있다. 4. 터키‘투르크코인’ 또는 ‘국가 비트코인’ 이라는 정부 차원의 암호화폐 발행을 검토하고 있다. 5. 러시아석유 기반 가상화폐 ‘크립토루블’ 발행을 결정했다. 러시아 또한 반미국가로써, 암호화폐 개발에 뛰어든 것은 서방의 제재망을 뚫을 금융통로가 절실하기 때문이다. 러시아가 크림반도를 합병한 2014년 이후 러시아 기업들은 서방 금융기관을 통한 거래가 사실상 차단됐다. 해외에 진출한 러시아 기업들이 활동하기 위해서는 자금을 주고받을 수단이 필요한 상황이다. 이래저래 달러에 대한 도전이 거세지고 있다. 이어 튀니지, 세네갈 등이 같은 결정을 내렸고, 스웨덴, 중국, 영국, 네덜란드, 캐나다, 싱가포르 중앙은행은 물론 연준까지 암호화폐 발행 가능성을 검토하고 있는 것으로 알려졌다. 암호화폐에 대한 정부의 규제 도입기는 무엇보다 정부의 규제가 가장 심할 시기다. 암호화폐가 출현하게 되면서, 국가에 위협이 되는 것은 크게 2가지다. 화폐 발행량과 유통량 세금 1. 화폐 발행량과 유통량정부가 갖는 권력 중 하나가 화폐 발행권인데, 이를 통해 국가의 경제를 조절할 수 있다. 그러나, 암호화폐처럼 정부의 손 밖에 있는 주체가 화폐를 발행한다면 정부는 독점 권한을 잃는다. 국가가 발행하지 않은 화폐가 시장에 추가로 유통되는 것이기에 화폐 유통량이 제어가 안 되고, 더 크게는 국가경제의 조절도 불가능하다. 2. 세금정부가 갖는 또 다른 권력 중 하나는 세금이다. 우리나라에서도 주식회사의 채무는 주주들에게 전가되지 않지만, 세금만은 전가되어 국가에서 끝까지 추적해 받아내도록 되어 있다. 암호화폐는 세금을 매기기가 힘들다. 그래서 각국 정부들은 유일한 과세지점이 될 수 있는 거래소를 통해 거래정보를 파악하려 한다. 하지만, 이는 곧 거래소의 익명성 제한을 뜻하므로, 사용자들은 익명성이 보장되는 해외거래소나 유저들 각 P2P 방식으로 직접 거래하려 할 것이다. 이와 더불어서 대시, 모네로, 라이크코인 등 비트코인보다 익명성을 훨씬 강화한 암호화폐들이 생겨나고 있으며, 정부의 규제가 강해지면 강해질수록 이러한 익명성이 강화된 암호화폐도 늘어날 것이다. 화폐의 통제권과 세금 징수권을 위해 정부들은 두 가지 방향에서 규제를 하려 한다. 첫째는, 민간 암호화폐의 규제이다. 둘째는, 국가주도 암호화폐의 발행이다. 정부의 이 두 가지 제재는 이미 시작되었다. 정부의 규제가 필요한 부분도 분명 존재한다. 터키의 경제하가 제이훈 엘긴의 조사에 따르면, 세계 경제의 20% 이상이 지하경제로 구성되어 있다고 한다. 이들이 암호화폐를 이용하면 할수록 지하경제 자금의 추적은 더욱 어려워질 것이다. 그러므로 암호화폐와 지하경제의 밀약을 막기 위해서는 정부의 적절한 규제가 필요하다. 아르헨티나 G20을 통해 알게된 암호화폐에 대한 인식 2018년 3월 19~20일 아르헨티나에서 G20 재무장관과 중앙은행 총재 회의가 열렸다.주된 메시지는 ‘암호화폐를 금지하지는 않겠으나, 규제는 하겠다.’앞으로 각국의 암호화폐에 대한 대응을 어림할 수 있다는 면에서 다음과 같은 논의내용이 참고가 될 것이다. 논의 내용 암호화폐와 블록체인은 국가가 채택해야 한다. 경제 시스템의 변방에서 소외당하고 있는 사람들을 경제 시스템 안으로 끼워 넣을 힘을 지니고 있다는 사실을 인정했다. 암호화폐가 복지 시스템을 강화하는데 정부를 도울 수 있다는 사실도 인정했다. 세계는 전통적 경제의 종말을 인지해야 한다. 기존의 전통적 경제가 변화되는 과정을 겪고 있으며, 이제 그 경제로부터 디지털 시대를 분리시킬 수 없다는 것에 동의했다. 규제는 불가피하다. 규제는 불가피한 과정이며, 경제가 디지털화되더라도 국민들은 실제이고 한 나라에 살고 있듯이, 다른 모든 비즈니스에 대한 규제가 불가피한 것처럼 암호화폐도 규제되어야 한다. 금지가 아닌 규제 G20 참가국들은 만장일치로 암호화폐가 중요하며 경제와 사회 조직에 큰 혁신을 가져올 것이라는 것에 동의했다. 따라서, 암호화폐는 금지되어서는 안 되며 규제적 절차를 통해 우리 사회에 도입돼야 한다. 규제는 기술혁신을 막아서는 안되며, 암호화폐에 대한 과세는 불가피하다. 암호화폐에 대한 엄격한 규제가 기술혁신을 저해해서는 안 된다. 하지만, 암호화폐에 대한 과세가 각국에서 다양한 절차에 맞춰 이뤄지는 것은 불가피하다. 회원국들은 암호화폐에 국제자금세탁방지기구 기준을 동일하게 적용할 필요가 있다는 데도 의견을 같이했다. 전반적으로 이런 규제에 대한 합의보다 암호화폐에 대한 긍정적인 논의들이 더 많았다. IMF의 크리스틴 라가르드 총재는 국가기관이 힘이 없고 국가통화가 불안정한 나라에서는 암호화폐가 기존 통화를 대체할 가능성이 높다고 밝히기도 했다. 그녀는, 달러 같은 다른 국가의 통화를 채택하기보다는 암호화폐를 사용하는 국가들이 늘어날 수도 있다. 기존 화폐보다 쉽고 안전하다는 생각이 많이 퍼질 경우, 암호화폐의 잠재적 성장 가능성은 매우 높다. 암호화폐 시장이 향후 안정된다면, 이러한 시나리오는 더욱 빨리 진행될 수 있다. 라고 했다. 이에 따라, G20에서는 암호화폐를 자산으로 인정해 제도권안으로 편입할 가능성이 클 것이다. 향후 G20은 암호화폐가 테러자금에 악용되는 걸 막기 위해 암호화폐를 자산으로 분류해 제도권 내에서 다룰 것으로 보인다. 자산으로 규정하면 각국은 그에 맞게 규정을 제정하고 표준화할 수 있다. 이런 시각은 금융계도 마찬가지다. 골드만삭스는 비트코인이 화폐 성격을 갖지는 않지만, 그렇다고 사기도 아니라며 미래에 더 큰 가치를 가져올 수 있는 상품이라는 견해를 밝혔다. 또한, 미국 뉴욕증권거래서 모기업인 인터콘티넨털익스체인지는 비트코인 거래 플랫폼을 개발중이다.(2018년 11월 예정) 해당 플랫폼이 개발되면 뉴욕증권거래소에서 비트코인 거래가 가능해질 전망이다. 암호화폐 시장의 도입기에 대한 내용 요약 모든 신기술과 마찬가지로, 암호화폐 시장도 도입기는 암호화폐와 시장에 대한 잠재역으로 많은 개인, 기업들이 들어오는 상황이다. 개인은 호기심으로, 기업은 새로운 사업기회로 도전을 하고 있다. 이런 이유로, 현재 암호화폐 시장은 춘추전국의 시대로 다양한 형태와 목적의 암호화폐가 나오고 있다. 이에 따라, 시장을 규제할 국가와 정부가 개입하고, 세계적으로 모든 국가 및 단체들도 이런 암호화폐에 대해서 어떻게 대비를 해야할지 다양한 의견과 법을 만들어 가고 있는 상황인 것 같다. 이런 상황일 때는, 무조건 시장에 뛰어들기 보다는 암호화폐의 본질에 대해 이해하고, 암호화폐가 앞으로 사람들에게 어떤 영향을 미칠지 고민해보고, 큰 비전과 목적을 충분히 이해하고 공부한 뒤에, 암호화폐 시장에 참가하는 것이 바람직하다고 생각한다. 참고: 화폐혁명","categories":[{"name":"Blockchain(Market)","slug":"Blockchain-Market","permalink":"https://cheonmro.github.io/categories/Blockchain-Market/"}],"tags":[{"name":"Cryptocurrency","slug":"Cryptocurrency","permalink":"https://cheonmro.github.io/tags/Cryptocurrency/"},{"name":"Finance","slug":"Finance","permalink":"https://cheonmro.github.io/tags/Finance/"},{"name":"Introduction Stage","slug":"Introduction-Stage","permalink":"https://cheonmro.github.io/tags/Introduction-Stage/"}]},{"title":"블록체인(Blockchain)이란 무엇인가?","slug":"what-is-blockchain","date":"2018-11-12T09:12:52.000Z","updated":"2018-11-12T09:12:52.586Z","comments":true,"path":"2018/11/12/what-is-blockchain/","link":"","permalink":"https://cheonmro.github.io/2018/11/12/what-is-blockchain/","excerpt":"","text":"블록체인(Blockchain) 블록체인이란, 각각의 블록으로 연결된 체인으로써, 블록들의 집합을 말한다. 여기서 블록이란, 거래 정보(일정기간 거래정보를 기록한 데이터 덩어리)를 말하고, 이 거래 정보들을 기록한 원장이 블록체인이다. 이 원장(블록체인)은 어떤 특정 기관의 중앙 서버가 아닌 P2P 네트워크에 분산하여 저장되고, 다수의 참가자가 공동으로 기록하고 관리하는 기술로, 분산원장(Distributed Ledger) 기술이라고 한다. 출처: 블록체인을 이용한 거래 출처: 블록체인을 이용한 거래 블록체인(Blockchain)의 철학(본질) 블록체인은 상호간에 ‘신뢰’에 대한 불필요한 비용을 제거하기 위한 기술이다. 즉, 블록체인은 상호 신뢰하지 않는 참여자들(사람 또는 사물)이 어떤 목적(정치/경제/금융/물류/의료 등)을 가지고 커뮤니티(생태계)를 구성하였을 때, 신뢰기관(정부/은행/카드회사 등)이나 신뢰 중재자 없이 참여자들끼리 합리적으로 신뢰성을 확보하면서 추구하는 목적을 달성할 수 있도록 해주는 기술이다. 블록체인(Blockchain)의 특징 탈중앙화(신뢰된 제3자 없이 분산형 네트워크(P2P) 환경에서 거래) 기록된 데이터의 위변조가 불가능(무결성을 유지) 10분마다 새로운 블록이 생성되어 체인에 연결 데이터의 일부분이 손상되어도 다른 노드를 통해 복구 가능(모든 노드가 거래 기록을 공유) 블록체인(Blockchain) 기술의 발달과정 블록체인 1세대는 코인거래만 가능(Digital Currency) 블록체인 2세대는 코인거래 뿐만 아니라, 플랫폼 코인(이더리움, EOS, ICON 등)의 개발로, 플랫폼 코인에서 다양한 블록체인 앱을 개발 가능(Digital Currency + Smart Contract + DApp) 블록체인 기술의 발달과정은 4단계로 나누면 다음과 같다. 출처: 블록체인 기술의 발달과정","categories":[{"name":"Blockchain(Tech)","slug":"Blockchain-Tech","permalink":"https://cheonmro.github.io/categories/Blockchain-Tech/"}],"tags":[{"name":"Blockchain","slug":"Blockchain","permalink":"https://cheonmro.github.io/tags/Blockchain/"}]},{"title":"우선순위 큐(Queue)와 힙(Heap)","slug":"what-is-heap","date":"2018-11-06T03:08:59.000Z","updated":"2018-11-06T03:08:59.050Z","comments":true,"path":"2018/11/06/what-is-heap/","link":"","permalink":"https://cheonmro.github.io/2018/11/06/what-is-heap/","excerpt":"","text":"우선순위 큐(Queue) 우선순위 큐(Queue)란, 우선순위 개념을 큐에 도입한 자료구조이다. 우선순위 큐(Queue): 가장 우선순위가 높은 데이터부터 삭제된다. 큐(Queue): 가장 먼저 들어온 데이터부터 삭제된다. 스택(Stack): 가장 최근에 들어온 데이터부터 삭제된다. 힙(Heap) 힙(Heap)이란, 완전 이진 트리(Complete Binary Tree)의 일종으로, 우선순위 큐를 위해 만들어진 자료구조이다. 여러 개의 값들 중에서, 최대값이나 최소값을 빠르게 찾아내도록 만들어진 자료구조이다. *완전 이진 트리란, 마지막 레벨을 제외한 나머지 모든 레벨에서 노드가 완전히 채워진 트리를 말한다. 또한, 마지막 레벨은 꽉 차 있지 않아도 되지만, 노드가 왼쪽에서 오른쪽으로 채워져야 한다. 힙(Heap)의 종류 최대 힙(max heap) 부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전 이진 트리 최소 힙(min heap) 부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전 이진 트리 출처: ypes of Heap","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"https://cheonmro.github.io/categories/Computer-Science/"}],"tags":[{"name":"우선순위 큐","slug":"우선순위-큐","permalink":"https://cheonmro.github.io/tags/우선순위-큐/"},{"name":"Heap","slug":"Heap","permalink":"https://cheonmro.github.io/tags/Heap/"}]},{"title":"그래프(Graph)와 트리(Tree)의 차이점","slug":"graph-vs-tree","date":"2018-11-06T02:41:24.000Z","updated":"2018-11-06T02:41:24.494Z","comments":true,"path":"2018/11/06/graph-vs-tree/","link":"","permalink":"https://cheonmro.github.io/2018/11/06/graph-vs-tree/","excerpt":"","text":"그래프(Graph) vs. 트리(Tree) 출처: Graph vs. Tree","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"https://cheonmro.github.io/categories/Computer-Science/"}],"tags":[{"name":"Graph","slug":"Graph","permalink":"https://cheonmro.github.io/tags/Graph/"},{"name":"Tree","slug":"Tree","permalink":"https://cheonmro.github.io/tags/Tree/"}]},{"title":"그래프(Graph)란 무엇인가?","slug":"what-is-graph","date":"2018-11-06T02:37:39.000Z","updated":"2018-11-06T02:37:39.231Z","comments":true,"path":"2018/11/06/what-is-graph/","link":"","permalink":"https://cheonmro.github.io/2018/11/06/what-is-graph/","excerpt":"","text":"그래프(Graph) 그래프(Graph)란, 노드(node)와 그 노드를 연결하는 간선(edge)을 하나로 모아 놓은 자료 구조이다. 그래프(Graph)의 용어 출처: Graph 정점(vertex): 위치라는 개념인데, 노드라고도 함. 간선(edge): 위치 간의 관계. 즉, 노드를 연결하는 선 (link, branch 라고도 부름) 인접 정점(adjacent vertex): 간선에 의해 직접 연결된 정점 정점의 차수(degree): 무방향 그래프에서 하나의 정점에 인접한 정점의 수 무방향 그래프에 존재하는 정점의 모든 차수의 합 = 그래프의 간선 수의 2배 진입 차수(in-degree): 방향 그래프에서 외부에서 오는 간선의 수 (내차수 라고도 부름) 진출 차수(out-degree): 방향 그래픙에서 외부로 향하는 간선의 수 (외차수 라고도 부름) 방향 그래프에 있는 정점의 진입 차수 또는 진출 차수의 합 = 방향 그래프의 간선의 수(내차수 + 외차수) 경로 길이(path length): 경로를 구성하는 데 사용된 간선의 수 단순 경로(simple path): 경로 중에서 반복되는 정점이 없는 경우 사이클(cycle): 단순 경로의 시작 정점과 종료 정점이 동일한 경우 그래프(Graph)의 특징 그래프는 네트워크 모델이다. 그래프는 크게 방향 그래프와 무방향 그래프 2가지 종류가 있다.(노드들 사이에서 무방향 경로를 가질 수 있고, 단방향/양방향 경로를 가질 수 있다.) 루트노드라는 개념과, 부모/자식관계라는 개념이 없다. 그래프는 순환(Cyclic)/비순환(Acyclic)이 있다.(loop/circuit, self-loop 모두 가능하다.) 순회는 DFS/BFS로 이루어진다. 그래프(Graph)의 종류 무방향 그래프(Undirected Graph): 연결 관계에 있어서 방향성이 없는 그래프이다. 방향 그래프(Directed Graph): 간선에 방향성이 존재하는 그래프이다. 출처: Graph Types","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"https://cheonmro.github.io/categories/Computer-Science/"}],"tags":[{"name":"Graph","slug":"Graph","permalink":"https://cheonmro.github.io/tags/Graph/"}]},{"title":"트리(Tree)란 무엇인가?","slug":"what-is-tree","date":"2018-11-06T01:50:51.000Z","updated":"2018-11-06T01:50:51.805Z","comments":true,"path":"2018/11/06/what-is-tree/","link":"","permalink":"https://cheonmro.github.io/2018/11/06/what-is-tree/","excerpt":"","text":"트리(Tree) 트리(Tree)란, 부모/자식관계를 가지는 구조로, 계층적 관계(Hierarchical Relationship)를 표현하는 자료구조이다. 트리(Tree)의 용어 출처: Tree 루트 노드(root node): 트리의 최상단 노드로, 트리는 하나의 루트 노드만을 가짐. 단말 노드(leaf node): 자식이 없는 노드로, ‘말단 노드’ 또는 ‘잎 노드’라고도 함. 내부(internal) 노드: 단말 노드가 아닌 노드가 아닌 노드 간선(edge): 노드를 연결하는 선 (link, branch 라고도 부름) 형제(sibling): 같은 부모를 가지는 노드 노드의 크기(size): 자신을 포함한 모든 자손 노드의 개수 노드의 깊이(depth): 루트에서 어떤 노드에 도달하기 위해 거쳐야 하는 간선의 수 노드의 레벨(level): 트리의 특정 깊이를 가지는 노드의 집합 노드의 차수(degree): 하위 트리 개수 / 간선 수 (degree) = 각 노드가 지닌 가지의 수 트리의 차수(degree of tree): 트리의 최대 차수 트리의 높이(height): 루트 노드에서 가장 깊숙히 있는 노드의 깊이 트리(Tree)의 특징 트리는 그래프의 한 형태이다. 즉, 그래프 안에 여러 종류 중 트리가 있다. 트리는 방향이 위에서 아래로만 향하는 방향 그래프이다. 즉, 노드들 사이의 선을 간선(edge)라고 하는데, 트리는 간선의 방향이 위에서 아래이다. 트리는 DAG(Directed Acyclic Graphs, 방향성이 있는 비순환 그래프)의 한 종류이다. 즉, loop나 circuit이 없고, self-loop도 없다. 즉, 사이클이 없다. 한 개의 루트 노드만이 존재하며 모든 자식 노드는 한 개의 부모 노드만을 가진다. 트리(Tree)의 종류 서브 트리(Sub Tree): 전체 트리는 작은 트리로 구성되어 있는데, 이 작은 트리를 서브 트리(Sub Tree)라고 한다. 이진 트리(Binary Tree): 자식 노드가 최대 2개까지만 붙는 트리를 이진 트리(Binary Tree)라고 한다. 즉, 자식 노드가 1개이거나, 2개일 경우 모두 이진 트리이다. 출처: Binary Tree 이진 검색 트리(Binary Search Tree): 노드안에 데이터가 왼쪽 노드와 그 이하 자식 노드들은 현재 노드보다 작아야 하고, 오른쪽 노드와 그 이하 노드들은 현재 노드보다 커야 한다. 이 조건을 만족하는 트리를 이진 검색 트리(Binary Search Tree)라고 한다. 노드를 보고, 해당 노드보다 큰 값을 찾고 싶으면, 오른쪽에서 찾으면 되고, 해당 노드보다 작은 값을 찾고 싶으면, 왼쪽에서 찾으면 된다. 따라서, 어떤 값을 찾을 때, 두 갈래 길을 선택해서 가다보면, 그 값을 찾을 수 있다. 출처: Binary Search Tree","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"https://cheonmro.github.io/categories/Computer-Science/"}],"tags":[{"name":"Tree","slug":"Tree","permalink":"https://cheonmro.github.io/tags/Tree/"}]},{"title":"13. Printer(Stack/Queue)","slug":"printer","date":"2018-11-05T12:01:48.000Z","updated":"2018-11-05T12:01:48.020Z","comments":true,"path":"2018/11/05/printer/","link":"","permalink":"https://cheonmro.github.io/2018/11/05/printer/","excerpt":"","text":"[Problem]일반적인 프린터는 인쇄 요청이 들어온 순서대로 인쇄합니다. 그렇기 때문에 중요한 문서가 나중에 인쇄될 수 있습니다. 이런 문제를 보완하기 위해 중요도가 높은 문서를 먼저 인쇄하는 프린터를 개발했습니다. 이 새롭게 개발한 프린터는 아래와 같은 방식으로 인쇄 작업을 수행합니다. 인쇄 대기목록의 가장 앞에 있는 문서(J)를 대기목록에서 꺼냅니다. 나머지 인쇄 대기목록에서 J보다 중요도가 높은 문서가 한 개라도 존재하면 J를 대기목록의 가장 마지막에 넣습니다. 그렇지 않으면 J를 인쇄합니다. 예를 들어, 4개의 문서(A, B, C, D)가 순서대로 인쇄 대기목록에 있고 중요도가 2 1 3 2 라면 C D A B 순으로 인쇄하게 됩니다. 내가 인쇄를 요청한 문서가 몇 번째로 인쇄되는지 알고 싶습니다. 위의 예에서 C는 1번째로, A는 3번째로 인쇄됩니다. 현재 대기목록에 있는 문서의 중요도가 순서대로 담긴 배열 priorities와 내가 인쇄를 요청한 문서가 현재 대기목록의 어떤 위치에 있는지를 알려주는 location이 매개변수로 주어질 때, 내가 인쇄를 요청한 문서가 몇 번째로 인쇄되는지 return 하도록 solution 함수를 작성해주세요. [Algorithms] queue의 push/shift를 이용한 문제 Array 중에서 최대값을 구하고, 각 첫 요소가 최대값보다 같거나 크면, queue로 push한다. 이때, 그 첫 요소가 우리가 찾는 값이면, 그 값의 순서는 queue.length(사이즈)로 몇번째인지 알 수 있다. array는 요소의 값이 아니라, 우선순위만 나와있기 때문에, 순서가 같을 수 있다. 그래서 그 첫 요소가 우리가 찾는 값인지 알기 위해, 두번째 인자로 제공되는 location의 인덱스를 활용한다. location을 계속 array안에서 변경시키면서 확인한다. 그리고, 첫번째 요소만 확인하기 위해, while(i === 0)일때를 사용하여, 계속 첫번째 값만 확인하게 한다. [Solution]12345678910111213141516171819202122232425function solution(priorities, location) &#123; let answer = 0; let queue = []; let i = 0; while(i === 0) &#123; let max = Math.max(...priorities); // max = 9 if(priorities[i] &lt; max) &#123; const notMaxValue = priorities.shift(); priorities.push(notMaxValue); // [1, 3, 2, 2] location === 0 ? location = priorities.length - 1 : location = location - 1; &#125; else if(priorities[i] &gt;= max) &#123; const maxValue = priorities.shift(); // 9 queue.push(maxValue); // queue = [9], priorities = [1, 1, 1, 1, 1] if(i === location) &#123; return answer = queue.length; &#125; else &#123; location = location - 1; &#125; &#125; &#125; return answer;&#125;console.log(solution([1, 1, 9, 1, 1, 1], 0)); // 5","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://cheonmro.github.io/categories/Algorithms/"}],"tags":[{"name":"Stack/Queue algorithms","slug":"Stack-Queue-algorithms","permalink":"https://cheonmro.github.io/tags/Stack-Queue-algorithms/"}]},{"title":"12. 짝이 맞지 않는 괄호 문제(Stack/Queue)","slug":"pipe","date":"2018-11-05T11:50:47.000Z","updated":"2018-11-05T11:50:47.356Z","comments":true,"path":"2018/11/05/pipe/","link":"","permalink":"https://cheonmro.github.io/2018/11/05/pipe/","excerpt":"","text":"[Problem]여러 개의 쇠막대기를 레이저로 절단하려고 합니다. 효율적인 작업을 위해서 쇠막대기를 아래에서 위로 겹쳐 놓고, 레이저를 위에서 수직으로 발사하여 쇠막대기들을 자릅니다. 쇠막대기와 레이저의 배치는 다음 조건을 만족합니다. 쇠막대기는 자신보다 긴 쇠막대기 위에만 놓일 수 있습니다. 쇠막대기를 다른 쇠막대기 위에 놓는 경우 완전히 포함되도록 놓되, 끝점은 겹치지 않도록 놓습니다. 각 쇠막대기를 자르는 레이저는 적어도 하나 존재합니다. 레이저는 어떤 쇠막대기의 양 끝점과도 겹치지 않습니다. 아래 그림은 위 조건을 만족하는 예를 보여줍니다. 수평으로 그려진 굵은 실선은 쇠막대기이고, 점은 레이저의 위치, 수직으로 그려진 점선 화살표는 레이저의 발사 방향입니다. 이러한 레이저와 쇠막대기의 배치는 다음과 같이 괄호를 이용하여 왼쪽부터 순서대로 표현할 수 있습니다. (a) 레이저는 여는 괄호와 닫는 괄호의 인접한 쌍 ‘()’으로 표현합니다. 또한 모든 ‘()’는 반드시 레이저를 표현합니다.(b) 쇠막대기의 왼쪽 끝은 여는 괄호 ‘(‘로, 오른쪽 끝은 닫힌 괄호 ‘)’로 표현됩니다. 위 예의 괄호 표현은 그림 위에 주어져 있습니다.쇠막대기는 레이저에 의해 몇 개의 조각으로 잘리는데, 위 예에서 가장 위에 있는 두 개의 쇠막대기는 각각 3개와 2개의 조각으로 잘리고, 이와 같은 방식으로 주어진 쇠막대기들은 총 17개의 조각으로 잘립니다. 쇠막대기와 레이저의 배치를 표현한 문자열 arrangement가 매개변수로 주어질 때, 잘린 쇠막대기 조각의 총 개수를 return 하도록 solution 함수를 작성해주세요. [Algorithms] ‘(’면 stack에 push해서 저장한다. ‘)’일때, 이게 레이저냐 파이프냐에 따라 나뉜다. 레이저일 경우, stack.size() 또는 stack.length를 이용해 쇠막대기 수를 계산한다. 이때, 레이저인지는 앞에 입력 문자열의 전 문자가 ‘(‘일때이다. 파이프일 경우, 쇠막대기 수에 1를 더한다. 이때, 파이프인지는 앞에 입력 문자열의 전 문자가 ‘)’일때이다. 중요한건, 기본적으로 이런 문제는 stack(배열)에 push/pop을 이용한다. stack의 사이즈(크기)를 이용하여 수를 구한다. [Solution]12345678910111213141516171819202122232425const solution = arrangement =&gt; &#123; let answer = 0; // 전체 조각난 쇠막대기 수 let stack = []; let ironBar = 0; // 조각난 쇠막대기 수 ------ for(let i = 0; i &lt; arrangement.length; i++) &#123; if(arrangement[i] === &apos;(&apos;) &#123; stack.push(arrangement[i]); &#125; else if(arrangement[i] === &apos;)&apos;) &#123; // check if it is lazer or pipe stack.pop(); // if lazer if (arrangement[i-1] === &apos;(&apos;) &#123; ironBar = stack.length; answer += ironBar; // if pipe &#125; else if (arrangement[i-1] === &apos;)&apos;) &#123; answer += 1; &#125; &#125; &#125; return answer;&#125;console.log(solution(&apos;()(((()())(())()))(())&apos;)) // 17","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://cheonmro.github.io/categories/Algorithms/"}],"tags":[{"name":"Stack/Queue algorithms","slug":"Stack-Queue-algorithms","permalink":"https://cheonmro.github.io/tags/Stack-Queue-algorithms/"}]},{"title":"11. 가장 큰 수(정렬)","slug":"max-number","date":"2018-11-05T11:26:20.000Z","updated":"2018-11-05T11:26:20.551Z","comments":true,"path":"2018/11/05/max-number/","link":"","permalink":"https://cheonmro.github.io/2018/11/05/max-number/","excerpt":"","text":"[Problem]0 또는 양의 정수가 주어졌을 때, 정수를 이어 붙여 만들 수 있는 가장 큰 수를 알아내 주세요. 예를 들어, 주어진 정수가 [6, 10, 2]라면 [6102, 6210, 1062, 1026, 2610, 2106]를 만들 수 있고, 이중 가장 큰 수는 6210입니다. 0 또는 양의 정수가 담긴 배열 numbers가 매개변수로 주어질 때, 순서를 재배치하여 만들 수 있는 가장 큰 수를 문자열로 바꾸어 return 하도록 solution 함수를 작성하시오. [Algorithms] [Solution]1234567891011const solution = numbers =&gt; &#123; // 배열의 각 요소를 문자열로 만들기 const answer = numbers.map(v=&gt; v+&apos;&apos;) // [ &apos;3&apos;, &apos;30&apos;, &apos;34&apos;, &apos;5&apos;, &apos;9&apos; ] // 문자열이지만, 값이 숫자인 요소들을 앞 숫자가 큰 요소로 정렬하기 .sort((a,b) =&gt; Number(b+a) - Number(a+b)) // [ &apos;9&apos;, &apos;5&apos;, &apos;34&apos;, &apos;3&apos;, &apos;30&apos; ] .join(&apos;&apos;); return answer[0] === &apos;0&apos; ? &apos;0&apos; : answer;&#125;console.log(solution([3, 30, 34, 5, 9])) // &apos;9534330&apos;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://cheonmro.github.io/categories/Algorithms/"}],"tags":[{"name":"sort algorithms","slug":"sort-algorithms","permalink":"https://cheonmro.github.io/tags/sort-algorithms/"}]},{"title":"10. K번째 수(정렬)","slug":"k-number","date":"2018-11-05T11:05:03.000Z","updated":"2018-11-05T11:05:03.692Z","comments":true,"path":"2018/11/05/k-number/","link":"","permalink":"https://cheonmro.github.io/2018/11/05/k-number/","excerpt":"","text":"[Problem]배열 array의 i번째 숫자부터 j번째 숫자까지 자르고 정렬했을 때, k번째에 있는 수를 구하려 합니다. 예를 들어 array가 [1, 5, 2, 6, 3, 7, 4], i = 2, j = 5, k = 3이라면, array의 2번째부터 5번째까지 자르면 [5, 2, 6, 3]입니다. 1에서 나온 배열을 정렬하면 [2, 3, 5, 6]입니다. 2에서 나온 배열의 3번째 숫자는 5입니다. 배열 array, [i, j, k]를 원소로 가진 2차원 배열 commands가 매개변수로 주어질 때, commands의 모든 원소에 대해 앞서 설명한 연산을 적용했을 때 나온 결과를 배열에 담아 return 하도록 solution 함수를 작성하시오. [Algorithms] [Solution]123456789101112function solution(array, commands) &#123; let answer = []; for(let i = 0; i &lt; commands.length; i++) &#123; const sliceArray = array.slice(commands[i][0] - 1, commands[i][1]); // [ 5, 2, 6, 3 ] const sortedArray = sliceArray.sort((a, b) =&gt; &#123; return a - b &#125;); // [ 2, 3, 5, 6 ] const value = sortedArray[commands[i][2] - 1]; // 5 answer.push(value); &#125; return answer;&#125;console.log(solution([1, 5, 2, 6, 3, 7, 4], [[2, 5, 3], [4, 4, 1], [1, 7, 3]])); // [ 5, 6, 3 ]","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://cheonmro.github.io/categories/Algorithms/"}],"tags":[{"name":"sort algorithms","slug":"sort-algorithms","permalink":"https://cheonmro.github.io/tags/sort-algorithms/"}]},{"title":"9. 최대공약수와 최소공배수","slug":"gcd-lcm","date":"2018-11-05T08:37:39.000Z","updated":"2018-11-05T08:37:39.269Z","comments":true,"path":"2018/11/05/gcd-lcm/","link":"","permalink":"https://cheonmro.github.io/2018/11/05/gcd-lcm/","excerpt":"","text":"[Problem]두 수를 입력받아 두 수의 최대공약수와 최소공배수를 반환해주는 gcdlcm() 함수를 작성하시오. 예를 들어, 3과 12의 두 숫자의 최대공약수와 최소공배수를 비교한다고 해보자. 3의 약수는 1, 3이고, 12의 약수는 1, 2, 3, 4, 6, 12이다. 여기서, 최대공약수는 3이다. 3의 배수는 3, 6, 9, 12, 15, 18… 이다. 12의 배수는 12, 24, 36, 48… 이다. 여기서, 최소공배수는 12이다. [Algorithms] [Solution]123456789101112131415function gcdlcm(a, b) &#123; let gcd = 1, lcm = 1; const minNum = Math.min(a,b); // 두 숫자 중에서 작은 값을 찾아, 1부터 그 작은값까지 비교하면서, 두 숫자에 대한 공약수를 찾는다. for (let i = 1; i &lt;= minNum; i++) &#123; if ((a%i == 0) &amp;&amp; (b%i == 0)) &#123; gcd = i &#125; &#125;; // 최소공배수는 두 수의 곱에 최대공약수로 나눈 값이다. lcm = a*b/gcd; return [gcd, lcm]&#125;console.log(gcdlcm(3,12)); // [ 3, 12 ]","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://cheonmro.github.io/categories/Algorithms/"}],"tags":[{"name":"최대공약수","slug":"최대공약수","permalink":"https://cheonmro.github.io/tags/최대공약수/"},{"name":"최소공배수","slug":"최소공배수","permalink":"https://cheonmro.github.io/tags/최소공배수/"}]},{"title":"8. 두 정수 사이의 함","slug":"sum-two-integers","date":"2018-11-05T08:01:52.000Z","updated":"2018-11-05T08:01:52.691Z","comments":true,"path":"2018/11/05/sum-two-integers/","link":"","permalink":"https://cheonmro.github.io/2018/11/05/sum-two-integers/","excerpt":"","text":"[Problem]두 정수 a, b가 주어졌을 때, a와 b 사이에 속한 모든 정수의 합을 리턴하는 함수, sumInt() 함수를 작성하시오. [Algorithms] [Solution]12345678910111213141516171819202122function sumInt(a, b) &#123; let answer = 0; const sortNumber = (a, b) =&gt; &#123; return Array.prototype.slice.call(arguments).sort(function(a,b)&#123; return a - b; &#125;) &#125; const newArray = sortNumber(a, b); // [ 1, 5 ] if (newArray[0] === newArray[1]) &#123; answer = newArray[0]; &#125; else &#123; for (let i = newArray[0]; i &lt;= newArray[1]; i++)&#123; answer += i; &#125; &#125; return answer;&#125;console.log(sumInt(1, 5)); // 15 -&gt; sum of 1 ~ 5","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://cheonmro.github.io/categories/Algorithms/"}],"tags":[{"name":"Sum All Integers Between Two Integers","slug":"Sum-All-Integers-Between-Two-Integers","permalink":"https://cheonmro.github.io/tags/Sum-All-Integers-Between-Two-Integers/"}]},{"title":"7. 나누어 떨어지는 숫자 배열","slug":"divide-array","date":"2018-11-05T07:38:59.000Z","updated":"2018-11-05T07:38:59.906Z","comments":true,"path":"2018/11/05/divide-array/","link":"","permalink":"https://cheonmro.github.io/2018/11/05/divide-array/","excerpt":"","text":"[Problem]array의 각 element 중 divisor로 나누어 떨어지는 값을 오름차순으로 정렬한 배열을 반환하는 함수, solution을 작성하시오. [Algorithms] [Solution]12345678910111213141516171819const solution = (arr, divisor) =&gt; &#123; let answer = []; for (let i = 0; i &lt; arr.length; i++) &#123; if(arr[i]%divisor === 0) &#123; answer.push(arr[i]); &#125; &#125; if (typeof answer !== &apos;undefined&apos; &amp;&amp; answer.length &gt; 0) &#123; answer.sort((a, b) =&gt; &#123; return a - b; &#125;); &#125; else &#123; answer.push(-1); &#125; return answer;&#125;console.log(solution([6, 7, 10, 3, 12], 3)); // [ 3, 6, 12 ]console.log(solution([], 3)); // [ -1 ]","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://cheonmro.github.io/categories/Algorithms/"}],"tags":[{"name":"Divide Array","slug":"Divide-Array","permalink":"https://cheonmro.github.io/tags/Divide-Array/"}]},{"title":"6. 가운데 글자 가져오기","slug":"find-mid-character","date":"2018-11-05T07:28:01.000Z","updated":"2018-11-05T07:28:01.843Z","comments":true,"path":"2018/11/05/find-mid-character/","link":"","permalink":"https://cheonmro.github.io/2018/11/05/find-mid-character/","excerpt":"","text":"[Problem]단어 str의 가운데 글자를 반환하는 함수, solution을 작성하시오. 만약, 단어의 길이가 짝수라면 가운데 두글자를 반환하면 됩니다. [Algorithms] [Solution]1234567891011121314151617181920const solution = str =&gt; &#123; let answer = &apos;&apos;; const stringLen = str.length; const stringHalf = Math.floor(stringLen/2); let stringStart = &apos;&apos;; const stringEnd = stringHalf + 1; if (stringLen % 2 === 0) &#123; stringStart = stringHalf - 1; answer = str.substring(stringStart, stringEnd); &#125; else if (stringLen % 2 === 1) &#123; stringStart = stringHalf; answer = str.substring(stringStart, stringEnd); &#125; return answer;&#125;console.log(solution(&apos;names&apos;)); // mconsole.log(solution(&apos;name&apos;)); // am","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://cheonmro.github.io/categories/Algorithms/"}],"tags":[{"name":"Find Mid Character","slug":"Find-Mid-Character","permalink":"https://cheonmro.github.io/tags/Find-Mid-Character/"}]},{"title":"5. Harmless Ransom Note","slug":"ransom-note","date":"2018-11-05T06:49:03.000Z","updated":"2018-11-05T06:49:03.440Z","comments":true,"path":"2018/11/05/ransom-note/","link":"","permalink":"https://cheonmro.github.io/2018/11/05/ransom-note/","excerpt":"","text":"What is Harmless Ransom Note?FacHarmless Ransom Note란, 중복되는 문자열의 유무를 파악해서 true/false로 확인하는 것을 말한다. [Problem]2개의 문자열 중, 중복되는 문자열의 유무를 파악해서 true/false로 반환하는 함수를 작성하시오. 즉, 왼쪽 문자열의 각 단어들이 오른쪽 문자열에 1개라도 포함이 안되거나, 오른쪽 문자열의 각 동일한 단어보다 더 많을 경우, false를 반환한다. 예를 들어, 왼쪽 문자열이 ‘this is my my note’ 이고, 오른쪽 문자열이 ‘this is is my note’일 때, 왼쪽 문자열의 각 단어 중 my는 왼쪽 문자열에서 2번있는데, 오른쪽에서는 1번 밖에 없으면 false를 반환해야 한다. 또한, 왼쪽 문자열이 ‘this is my special note’ 이고, 오른쪽 문자열이 ‘this is is my note’일 때, 왼쪽 문자열의 special 단어는 오른쪽 문자열에 없어도, false를 반환해야 한다. [Algorithms] [Solution]1234567891011121314151617181920212223242526272829303132333435363738394041424344const harmlessRansomeNote = (noteText, magazineText) =&gt; &#123; //split both string parameters into arrays let noteArr = noteText.split(&apos; &apos;); let magArr = magazineText.split(&apos; &apos;); //create an object to use as a hash table it also avoids exponential time complexity of nested loops let magObj = &#123;&#125;; //forEach to check if word is an word is an object on our property magArr.forEach(word =&gt; &#123; //if not we add it to our object //increment the value if (!magObj[word]) &#123; magObj[word] = 1; &#125; else &#123; //otherwise, if it is there //we just increment the value magObj[word]++; &#125; &#125;); // &#123; this: 1, is: 2, my: 1, note: 1 &#125; //Boolean variable to be return from function let noteIsPossible = true; //use forEach to iterate through each word noteArr.forEach(word =&gt; &#123; //if word is found on the object decrement it if (magObj[word]) &#123; magObj[word]--; //if word value &lt; 0 we can&apos;t make our word so note is NOT possible. if (magObj[word] &lt; 0) &#123; noteIsPossible = false; &#125; //if word is not found then the note is NOT possible. &#125; else &#123; noteIsPossible = false; &#125; &#125;); return noteIsPossible;&#125;;console.log(harmlessRansomeNote(&apos;this is my note&apos;, &apos;this is is my note&apos;)); // true","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://cheonmro.github.io/categories/Algorithms/"}],"tags":[{"name":"Harmless Ransom Note","slug":"Harmless-Ransom-Note","permalink":"https://cheonmro.github.io/tags/Harmless-Ransom-Note/"}]},{"title":"4. Factorial","slug":"factorial","date":"2018-11-05T06:04:00.000Z","updated":"2018-11-05T06:04:00.293Z","comments":true,"path":"2018/11/05/factorial/","link":"","permalink":"https://cheonmro.github.io/2018/11/05/factorial/","excerpt":"","text":"What is Factorial?Factorial이란, 해당하는 수부터 그 이하로 1까지를 모두 곱하는 수를 말한다.예를 들어, 3!이면 3 x 2 x 1 = 6을 말한다. [Problem]Factorial을 구현하는 함수를 작성하시오. [Algorithms] number가 1일 경우, number를 반환한다. number가 2이상이면 number부터 1씩 값을 줄여가면서, 모두 곱한다. 곱한 최종 값을 반환한다. [Solution]1234567891011function factorial(number) &#123; if(number === 1) return number; let result = 1; for (var i = number; i &gt;= 1 ; --i ) &#123; result *= i; &#125; return result;&#125;console.log(factorial(5)); // 120 [Better Practice]123456789function factorial(number) &#123; if(number === 1) &#123; return number; &#125; else &#123; return number * factorial(number-1); &#125;&#125;console.log(factorial(5)); // 120","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://cheonmro.github.io/categories/Algorithms/"}],"tags":[{"name":"Factorial","slug":"Factorial","permalink":"https://cheonmro.github.io/tags/Factorial/"}]},{"title":"String Method","slug":"string-method","date":"2018-11-05T05:34:24.000Z","updated":"2018-11-05T05:34:25.004Z","comments":true,"path":"2018/11/05/string-method/","link":"","permalink":"https://cheonmro.github.io/2018/11/05/string-method/","excerpt":"","text":"1. String.prototype.charAt(index) 매개변수로 전달한 index 번호에 해당하는 위치의 문자를 반환한다. index 번호는 0 ~ (문자열 길이 - 1) 사이의 정수이다. 12345678910const str = &apos;Hello&apos;;console.log(str.charAt(0)); // Hconsole.log(str.charAt(1)); // econsole.log(str.charAt(2)); // lconsole.log(str.charAt(3)); // lconsole.log(str.charAt(4)); // o// 지정한 index가 범위(0 ~ str.length-1)를 벗어난 경우 빈문자열을 반환한다.console.log(str.charAt(5)); // &apos;&apos; 2. String.prototype.concat(index) 매개변수로 전달된 1개 이상의 문자열과 연결하여 새로운 문자열을 반환한다. concat 메소드를 사용하는 것보다는 +, += 할당 연산자를 사용하는 것이 성능상 유리하다. 12345let str = &apos;My name is &apos;;let name = &apos;Cheon&apos;;str = str.concat(name); // str = str + name;console.log(str); // &apos;My name is Cheon&apos; 3. String.prototype.split(string | regular Expression, number) 첫번째 인자에 전달된 문자열 또는 정규표현식을 대상 문자열에서 검색하여 문자열을 구분한 후, 분리된 각 문자열로 이루어진 배열을 반환한다. 원본 문자열은 변경되지 않는다. 인수가 없는 경우, 대상 문자열 전체를 단일 요소로 하는 배열을 반환한다. 12345678910111213141516171819202122232425let str = &apos;How are you doing?&apos;;// 공백으로 구분(단어로 구분)하여 배열로 반환한다let splitStr = str.split(&apos; &apos;);console.log(splitStr); // [ &apos;How&apos;, &apos;are&apos;, &apos;you&apos;, &apos;doing?&apos; ]// 원본 문자열은 변경되지 않는다console.log(str); // How are you doing?// 인수가 없는 경우, 대상 문자열 전체를 단일 요소로 하는 배열을 반환한다.splitStr = str.split();console.log(splitStr); // [ &apos;How are you doing?&apos; ]// 각 문자를 모두 분리한다splitStr = str.split(&apos;&apos;);console.log(splitStr); // [ &apos;H&apos;,&apos;o&apos;,&apos;w&apos;,&apos; &apos;,&apos;a&apos;,&apos;r&apos;,&apos;e&apos;,&apos; &apos;,&apos;y&apos;,&apos;o&apos;,&apos;u&apos;,&apos; &apos;,&apos;d&apos;,&apos;o&apos;,&apos;i&apos;,&apos;n&apos;,&apos;g&apos;,&apos;?&apos; ]// 공백으로 구분하여 배열로 반환한다. 단 요소수는 3개까지만 허용한다splitStr = str.split(&apos; &apos;, 3);console.log(splitStr); // [ &apos;How&apos;, &apos;are&apos;, &apos;you&apos; ]// &apos;o&apos;으로 구분하여 배열로 반환한다.splitStr = str.split(&apos;o&apos;);console.log(splitStr); // [ &apos;H&apos;, &apos;w are y&apos;, &apos;u d&apos;, &apos;ing?&apos; ] 4. String.prototype.substring(start, end) 첫번째 인자에 전달된 index(start)에 해당하는 문자부터 두번째 인자에 전달된 index(end)에 해당하는 문자의 바로 이전 문자까지를 모두 반환한다. 이때 첫번째 인수 &lt; 두번째 인수의 관계가 성립된다. 123456789101112let str = &apos;Hello World&apos;; // str.length == 11let res = str.substring(1, 4);console.log(res); // ell// 첫번째 인수 &gt; 두번째 인수 : 두 인수는 교환된다.res = str.substring(4, 1);console.log(res); // ell// 두번째 인수가 생략된 경우 : 해당 문자열의 끝까지 반환한다.res = str.substring(4);console.log(res); // o World 5. String.prototype.toLowerCase() 대상 문자열의 모든 문자를 소문자로 변경한다. 1234let str = &apos;Hello World!&apos;;const res = str.toLowerCase();console.log(res); // hello world! 6. String.prototype.toUpperCase() 대상 문자열의 모든 문자를 대문자로 변경한다. 1234let str = &apos;Hello World!&apos;;const res = str.toUpperCase();console.log(res); // HELLO WORLD!","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://cheonmro.github.io/categories/Algorithms/"}],"tags":[{"name":"String Method","slug":"String-Method","permalink":"https://cheonmro.github.io/tags/String-Method/"}]},{"title":"Array Method for Advanced","slug":"array-method-advanced","date":"2018-11-05T05:10:12.000Z","updated":"2018-11-05T05:10:12.385Z","comments":true,"path":"2018/11/05/array-method-advanced/","link":"","permalink":"https://cheonmro.github.io/2018/11/05/array-method-advanced/","excerpt":"","text":"1. Array.prototype.forEach(function(elem, index, array)) 배열을 순회하며 배열의 각 요소에 대하여 인자로 주어진 콜백함수를 실행한다. 콜백함수의 매개변수를 통해 배열 요소의 값(elem), 요소 인덱스(index), 순회할 배열(array)을 전달 받을 수 있다. 반환값은 undefined이다. forEach 메소드는 원본배열을 변경하지 않는다. forEach 메소드는 for 문과는 달리 break 문을 사용할 수 없고, 일반 for 구문에 비해 성능이 좋지는 않다. forEach()는 배열을 순회하며 요소 값을 참조하여 무언가를 하기 위한 함수 123456789101112let sum = 0;const arr = [1, 3, 5, 7, 9];arr.forEach(function (elem, index, array) &#123; console.log(&apos;[&apos; + index + &apos;] = &apos; + elem); sum += elem;&#125;);console.log(sum); // 25// 원본배열이 유지된다.console.log(arr); // [ 1, 3, 5, 7, 9 ] 2. Array.prototype.map(function(elem, index, array)) 배열을 순회하며 각 요소에 대하여 인자로 주어진 콜백함수의 반환값(결과값)으로 새로운 배열을 생성하여 반환한다. 원본 배열은 변경되지 않는다. 콜백함수의 매개변수를 통해 배열 요소의 값(elem), 요소 인덱스(index), 순회할 배열(array)을 전달 받을 수 있다. map()은 배열을 순회하며 요소 값을 다른 값으로 맵핑하기 위한 함수이다. 123456789101112const arr = [1, 4, 9];// 배열을 순회하며 각 요소에 대하여 인자로 주어진 콜백함수를 실행const result = arr.map(elem =&gt; &#123; return Math.sqrt(elem);&#125;);// map 메소드는 새로운 배열을 반환한다console.log(result); // [ 1, 2, 3 ]// map 메소드는 원본 배열은 변경하지 않는다console.log(arr); // [ 1, 4, 9 ] 3. Array.prototype.filter(function(elem, index, array)) 배열을 순회하며 각 요소에 대하여 인자로 주어진 콜백함수의 실행 결과가 true인 배열 요소의 값만을 추출한 새로운 배열을 반환한다. 이때 원본 배열은 변경되지 않는다. 콜백함수의 매개변수를 통해 배열 요소의 값(elem), 요소 인덱스(index), 순회할 배열(array)을 전달 받을 수 있다. filter()는 배열에서 특정 케이스만 필터링 조건으로 추출하여 새로운 배열을 만들고 싶을 때 사용한다. 12345678910const arr = [1, 2, 3, 4, 5];const result = arr.filter(function (elem, index, array) &#123; console.log(&apos;[&apos; + index + &apos;] = &apos; + elem); return elem % 2; // 홀수만을 필터링한다 (1은 true로 평가된다)&#125;);console.log(result); // [ 1, 3, 5 ]// 원본배열은 유지된다.console.log(arr); // [ 1, 2, 3, 4, 5 ]","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://cheonmro.github.io/categories/Algorithms/"}],"tags":[{"name":"Array Method","slug":"Array-Method","permalink":"https://cheonmro.github.io/tags/Array-Method/"}]},{"title":"정렬 함수 sort() 사용법","slug":"sort-function","date":"2018-11-05T03:47:14.000Z","updated":"2018-11-05T03:47:15.007Z","comments":true,"path":"2018/11/05/sort-function/","link":"","permalink":"https://cheonmro.github.io/2018/11/05/sort-function/","excerpt":"","text":"Array.prototype.sort() 배열안에 원소를 정렬하는 함수로, 원본 배열을 직접 변경하며 정렬된 배열을 반환한다. sort(compareFunction) 함수는 sort() 안에 인자로 정렬 순서를 정의하는 함수를 넣어서 정렬을 한다. 만약, 생략하게 되면, 기본 문자열에 순서에 따라 정렬이 된다. 즉, ASCII 문자 순서(오름차순)로 정렬된다. 또한, sort() 함수는 정렬하는 원소가 문자열, 숫자, 또는 객체형이냐에 따라 사용법이 조금씩 다르다. sort() 안에 인자인 compareFunction를 지정하면, 값은 아래 중 하나로 반환된다. 첫번째 인수가 두번째 인수보다 작을 경우 -&gt; ‘-‘ 첫번째 인수가 두번째 인수보다 클 경우 -&gt; ‘+’ 두 인수가 같을 경우 -&gt; 0 1. 정렬할 원소가 문자열일 경우 123456789101112131415161718// 오름차순const arr = [&apos;orange&apos;, &apos;apple&apos;, &apos;banana&apos;];console.log(arr.sort()); // [ &apos;apple&apos;, &apos;banana&apos;, &apos;orange&apos; ]// 내림차순(ES6) - 문자열끼리 비교할 때는 비교연산자를 사용한다.(숫자는 뺄셈연산자 사용)console.log(arr.sort((a, b) =&gt; &#123; if(a &gt; b) return -1; else if(b&gt; a) return 1; else return 0;&#125;)); // [ &apos;orange&apos;, &apos;banana&apos;, &apos;apple&apos; ]// 내림차순(ES5) - 문자열끼리 비교할 때는 비교연산자를 사용한다.(숫자는 뺄셈연산자 사용)console.log(arr.sort(function(a, b) &#123; if(a &gt; b) return -1; else if(b&gt; a) return 1; else return 0;&#125;)); // [ &apos;orange&apos;, &apos;banana&apos;, &apos;apple&apos; ] 2. 정렬할 원소가 숫자일 경우 123456789101112131415161718192021222324const arr = [3, 11, 12, 10, 9, 1];// ASCII 문자 순서로 정렬되어 숫자의 크기대로 나오지 않음 -&gt; sort()안에 인자로 함수를 추가해줘야 함console.log(arr.sort()); // [ 1, 10, 11, 12, 3, 9 ]// 오름차순(ES6)console.log(arr.sort((a, b) =&gt; &#123; // [ 1, 3, 9, 10, 11, 12 ] return a - b;&#125;));// 오름차순(ES5)console.log(arr.sort(function(a, b) &#123; // [ 1, 3, 9, 10, 11, 12 ] return a - b;&#125;));// 내림차순(ES6)console.log(arr.sort((a, b) =&gt; &#123; // [ 12, 11, 10, 9, 3, 1 ] return b - a;&#125;));// 내림차순(ES5)console.log(arr.sort(function(a, b) &#123; // [ 12, 11, 10, 9, 3, 1 ] return b - a;&#125;)); 3. 정렬할 원소가 객체일 경우 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const person = [ &#123; name : &quot;john&quot;, age : 25&#125;, &#123; name : &quot;smith&quot;, age : 15&#125;, &#123; name : &quot;ro&quot;, age : 35&#125;, &#123; name : &quot;park&quot;, age : 45&#125;]/* 이름순으로 정렬 */// 문자열끼리 비교할 때는 비교연산자를 사용한다.// 오름차순(ES6)console.log(person.sort((a, b) =&gt; &#123; return a.name &lt; b.name ? -1 : a.name &gt; b.name ? 1 : 0;&#125;)); // [ &#123; name: &apos;john&apos;, age: 25 &#125;, &#123; name: &apos;park&apos;, age: 45 &#125;, &#123; name: &apos;ro&apos;, age: 35 &#125;, &#123; name: &apos;smith&apos;, age: 15 &#125; ]// 오름차순(ES5)console.log(person.sort(function(a, b) &#123; return a.name &lt; b.name ? -1 : a.name &gt; b.name ? 1 : 0;&#125;)); // [ &#123; name: &apos;john&apos;, age: 25 &#125;, &#123; name: &apos;park&apos;, age: 45 &#125;, &#123; name: &apos;ro&apos;, age: 35 &#125;, &#123; name: &apos;smith&apos;, age: 15 &#125; ]// 내림차순(ES6)console.log(person.sort((a, b) =&gt; &#123; return a.name &gt; b.name ? -1 : a.name &lt; b.name ? 1 : 0;&#125;)); // [ &#123; name: &apos;smith&apos;, age: 15 &#125;, &#123; name: &apos;ro&apos;, age: 35 &#125;, &#123; name: &apos;park&apos;, age: 45 &#125;, &#123; name: &apos;john&apos;, age: 25 &#125; ]// 내림차순(ES5)console.log(person.sort(function(a, b) &#123; return a.name &gt; b.name ? -1 : a.name &lt; b.name ? 1 : 0;&#125;)); // [ &#123; name: &apos;smith&apos;, age: 15 &#125;, &#123; name: &apos;ro&apos;, age: 35 &#125;, &#123; name: &apos;park&apos;, age: 45 &#125;, &#123; name: &apos;john&apos;, age: 25 &#125; ]/* 나이순으로 정렬 */// 숫자끼리 비교할 때는 뺄셈연산자를 사용한다.const sortingField = &quot;age&quot;;// 오름차순(ES6)console.log(person.sort((a, b) =&gt; &#123; return a[sortingField] - b[sortingField];&#125;)); // [ &#123; name: &apos;smith&apos;, age: 15 &#125;, &#123; name: &apos;john&apos;, age: 25 &#125;, &#123; name: &apos;ro&apos;, age: 35 &#125;, &#123; name: &apos;park&apos;, age: 45 &#125; ]// 오름차순(ES5)console.log(person.sort(function(a, b) &#123; return a[sortingField] - b[sortingField];&#125;)); // [ &#123; name: &apos;smith&apos;, age: 15 &#125;, &#123; name: &apos;john&apos;, age: 25 &#125;, &#123; name: &apos;ro&apos;, age: 35 &#125;, &#123; name: &apos;park&apos;, age: 45 &#125; ]// 내림차순(ES6)console.log(person.sort((a, b) =&gt; &#123; return b[sortingField] - a[sortingField];&#125;)); // [ &#123; name: &apos;park&apos;, age: 45 &#125;, &#123; name: &apos;ro&apos;, age: 35 &#125;, &#123; name: &apos;john&apos;, age: 25 &#125;, &#123; name: &apos;smith&apos;, age: 15 &#125; ]// 내림차순(ES5)console.log(person.sort(function(a, b) &#123; return b[sortingField] - a[sortingField];&#125;)); // [ &#123; name: &apos;park&apos;, age: 45 &#125;, &#123; name: &apos;ro&apos;, age: 35 &#125;, &#123; name: &apos;john&apos;, age: 25 &#125;, &#123; name: &apos;smith&apos;, age: 15 &#125; ]","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://cheonmro.github.io/categories/Algorithms/"}],"tags":[{"name":"Sort function","slug":"Sort-function","permalink":"https://cheonmro.github.io/tags/Sort-function/"}]},{"title":"Array Method for Basic","slug":"array-method-basic","date":"2018-11-05T02:37:57.000Z","updated":"2018-11-05T02:37:57.989Z","comments":true,"path":"2018/11/05/array-method-basic/","link":"","permalink":"https://cheonmro.github.io/2018/11/05/array-method-basic/","excerpt":"","text":"1. Array.prototype.indexOf() arr.indexOf(searchElement, fromIndex): arr에서 찾아야할 값(searchElement)이 몇번째 인덱스부터(fromIndex) 시작해서 그 찾아야할 값에 대한 index를 찾을 때 사용 indexOf 메소드의 인자로 지정된 요소를 배열에서 검색하여 인덱스를 반환한다. 중복되는 요소가 있는 경우 첫번째 인덱스만 반환된다. 만일 해당하는 요소가 없는 경우, -1을 반환한다. 1234const arr = [1, 2, 2, 3];console.log(arr.indexOf(2)); // 1console.log(arr.indexOf(4)); // -1console.log(arr.indexOf(2, 2)); // 1 2. Array.prototype.concat() concat 메소드의 인수로 넘어온 값들(배열 또는 값)을 자신의 복사본에 요소로 추가하고 반환한다. 이때 원본 배열은 변경되지 않는다. 1234567891011const arr1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];const arr2 = [&apos;x&apos;, &apos;y&apos;, &apos;z&apos;];const c = arr1.concat(arr2);console.log(c); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;x&apos;, &apos;y&apos;, &apos;z&apos;]const d = arr1.concat(&apos;hello&apos;);console.log(d); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;hello&apos;]// 원본 배열은 변하지 않는다.console.log(arr1); // [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos; ] 3. Array.prototype.join() 배열 요소 전체를 연결하여 생성한 문자열을 반환한다. 구분자(separator)는 생략 가능하며 기본 구분자는 ,이다. 이때, 원본 배열은 유지된다. 123456789101112const arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;];const x = arr.join();console.log(x); // &apos;a,b,c,d&apos;;const y = arr.join(&apos;&apos;);console.log(y); // &apos;abcd&apos;const z = arr.join(&apos;:&apos;);console.log(z); // &apos;a:b:c:d&apos;console.log(arr); // [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos; ] 4. Array.prototype.reverse() 배열 요소의 순서를 반대로 변경한다. 이때 원본 배열이 변경된다. 반환값은 변경된 배열이다. 123456const arr1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];const arr2 = arr1.reverse();// 원본 배열이 변경된다console.log(arr1); // [ &apos;c&apos;, &apos;b&apos;, &apos;a&apos; ]console.log(arr2); // [ &apos;c&apos;, &apos;b&apos;, &apos;a&apos; ] 5. Array.prototype.slice(start, end) 인자로 지정된 배열의 부분을 복사하여 반환한다. 원본 배열은 변경되지 않는다. 첫번째 매개변수 start에 해당하는 인덱스를 갖는 요소부터 매개변수 end에 해당하는 인덱스를 가진 요소 전까지 복사된다. 1234567891011121314151617181920const arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];// items[1]부터 items[2] 이전(items[2] 미포함)까지 반환const res2 = arr.slice(1, 2);console.log(res2); // [ &apos;b&apos; ]// items[1]부터 이후의 모든 요소 반환const res3 = arr.slice(1);console.log(res3); // [ &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; ]// 인자가 음수인 경우 배열의 끝에서 2개의 요소를 반환const res4 = arr.slice(-2);console.log(res4); // [ &apos;d&apos;, &apos;e&apos; ]// 모든 요소를 반환 (= 복사본 생성)const res5 = arr.slice();console.log(res5); // [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; ]// 원본은 변경되지 않는다.console.log(arr); // [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; ] 6. Array.prototype.splice(start, end) 기존의 배열의 요소를 제거하고 그 위치에 새로운 요소를 추가한다. 배열 중간에 새로운 요소를 추가할 때도 사용되고, 삭제만 할 때도 사용된다. 123456789const arr = [1, 2, 3, 4, 5, 6];// items[1]부터 2개의 요소를 제거하고 제거된 요소를 배열로 반환const res = arr.splice(1, 2);// 원본 배열이 변경된다.console.log(arr); // [ 1, 4, 5, 6 ]// 제거한 요소가 배열로 반환된다.console.log(res); // [ 2, 3 ] 7. Array.prototype.push()/pop()/shift()/unshift() 4가지 메소드는 모두 원본을 변경한다. 출처: Array push/pop/shift/unshift 8. Array.prototype.includes() arr.includes(searchElement, fromIndex): 배열에 특정 요소가 포함되어 있는지 여부를 확인할 때 사용 1234567const arr = [1,2,3,4];const result1 = arr.includes(3);const result2 = arr.includes(1, 1);console.log(result1); // trueconsole.log(result2); // false// 원본 배열이 유지된다.console.log(arr); // [1,2,3,4] 9. Array.prototype.toString() arr.toString(): 배열에 있는 원소를 문자열로 반환할 때 사용 12345const arr = [1,2,3];const result = arr.toString();console.log(result); // &quot;1,2,3&quot;// 원본 배열이 유지된다.console.log(arr); // [1,2,3]","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://cheonmro.github.io/categories/Algorithms/"}],"tags":[{"name":"Array Method","slug":"Array-Method","permalink":"https://cheonmro.github.io/tags/Array-Method/"}]},{"title":"Javascript Technique for Algorithms","slug":"javascript-technique","date":"2018-11-05T01:41:47.000Z","updated":"2018-11-05T01:41:47.770Z","comments":true,"path":"2018/11/05/javascript-technique/","link":"","permalink":"https://cheonmro.github.io/2018/11/05/javascript-technique/","excerpt":"","text":"배열이나 문자열에서 i번째 인덱스 내용을 삭제해야 하는 경우 1. 원본을 유지하면서, 삭제하는 방법 array 메소드 중, slice()를 사용하면, 원본을 유지하면서, 삭제된 새로운 배열을 생성할 수 있다. 12345const arr = [1,2,3,4,5];const newArr = [...arr.slice(0,3), ...arr.slice(4)]; // 3번째 인덱스 삭제console.log(newArr); // [1,2,4,5]console.log(arr); // [1,2,3,4,5] 2. 원본을 변경하면서, 삭제하는 방법 array 메소드 중, splice()를 사용하면, 특정 요소를 삭제함으로써, 원본이 변경된 배열이 된다. 123const arr = [1,2,3,4,5];arr.splice(3,1); // 3번 인덱스부터 1개를 삭제console.log(arr); // [1,2,3,5] 배열이나 문자열에서 중복을 제거해야 할 때 Set을 사용해서 중복을 제거할 수 있다.(Set은 unique한 자료형만을 저장한다.) 1234567891011// 배열const arr = [1, 3, 2, 9, 9, 1, 5, 1, 4, 5, 2];console.log(new Set(arr)); // &#123; 1, 3, 2, 9, 5, 4 &#125;const newArr = [...new Set(arr)];console.log(newArr); // [ 1, 3, 2, 9, 5, 4 ]// 문자열const str = &quot;abcdacbe&quot;;console.log(new Set(str)); // &#123; &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; &#125;const newStr = [...new Set(str)].join(&apos;&apos;);console.log(newStr); // &quot;abcde&quot; 배열이나 문자열에서 딱 1개만 있는 요소를 찾아야 할 경우 array 메소드 중, filter()와 indexOf()를 사용하면, 딱 1개만 있는 요소를 찾을 수 있다. 123456789// 배열const arr = [3, 3, 3, 7, 3];const filterArr = arr.filter( elem =&gt; arr.indexOf(elem) === arr.lastIndexOf(elem) );console.log(filterArr); // [7]// 문자열const str = &apos;33373&apos;;const filterStr = str.split(&apos;&apos;).filter( elem =&gt; str.indexOf(elem) === str.lastIndexOf(elem) );console.log(filterStr); // [&apos;7&apos;] 배열에 규칙적인 연속된 값 할당해야할 경우 Array()와 fill()를 사용한다. 1234const newArr = Array(5).fill(2);console.log(newArr); // [2, 2, 2, 2, 2]const newArr2 = Array(5).fill(1).map( (elem, i) =&gt; elem + i );console.log(newArr2); // [1,2,3,4,5] 배열에 최대값/최소값을 찾아야 할 경우 Math.max(), Math.min()를 사용한다. 123456789// 최대값const arr = [1, 2, 3];const max = Math.max(...arr); // 3console.log(max);// 최소값const arr = [1, 2, 3];const min = Math.min(...arr); // 3console.log(min); 지정된 숫자를 자신보다 작은, 가까운 정수로 내림해야 할 경우 Math.floor()를 사용한다. 123456789const floor1 = Math.floor(2.9); // 2const floor2 = Math.floor(9.1); // 9const floor3 = Math.floor(-1.9); // -2const floor4 = Math.floor(-9.1); // -10console.log(floor1);console.log(floor2);console.log(floor3);console.log(floor4); 지정된 숫자를 자신보다 큰, 가까운 정수로 올림해야 할 경우 Math.ceil()를 사용한다. 12345const ceil1 = Math.ceil(1.1); // 2const ceil2 = Math.ceil(-1.4); // -1console.log(ceil1);console.log(ceil2);","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://cheonmro.github.io/categories/Algorithms/"}],"tags":[{"name":"Javascript Technique","slug":"Javascript-Technique","permalink":"https://cheonmro.github.io/tags/Javascript-Technique/"}]},{"title":"Hash Table이란 무엇인가?","slug":"what-is-hashtable","date":"2018-11-04T11:53:11.000Z","updated":"2018-11-04T11:53:11.953Z","comments":true,"path":"2018/11/04/what-is-hashtable/","link":"","permalink":"https://cheonmro.github.io/2018/11/04/what-is-hashtable/","excerpt":"","text":"Hash Table(해시 테이블) Hash Table이란, 검색하고자 하는 key 값을 입력받아서 해시함수를 돌려서 반환받은 해시코드를 배열의 인덱스로 환산해서 데이터에 접근하는 방식의 자료구조이다. Hash Table 작동원리 출처: Hash Table 검색하고자 하는 Key 값을 해시함수를 돌리면, 해시코드를 반환받는다.(해시코드는 정수이다) 반환된 해시코드를 배열의 개수로 나머지(%) 연산을 해서 인덱스 번호로 바꾼다. 예를 들어, 어떤 Key 값의 해시코드가 445이고 배열의 크기가 3이면, 445 % 3 = 1이 되어, 인덱스 번호는 1이 된다. 이 인덱스 번호로 배열에 데이터를 저장한다. 예를 들어, 인덱스 번호가 1이라면, 배열에서 배열방 1번에 저장한다. 즉, 해시코드 자체가 배열방의 인덱스로 사용되어 검색이 필요없고, 해시코드로 바로 배열의 데이터에 접근이 가능하다. 각 배열방에 저장되어 있는 데이터들은 연결 리스트로 되어 있어, 배열방에 새로운 데이터가 추가될 때마다, 연결 리스트에 추가가 된다. 어떤 Key 값에 대한 검색 요청이 들어와 인덱스로 환산한 뒤, 어떤 배열방에서 그 Key 값을 찾기 위해서는, 그 배열방에 연결 리스트를 순회화면서 그 Key 값을 찾는다. Hash Table 특징 장점: 해시코드 자체가 배열방의 인덱스로 사용되어 다른 검색이 필요없이 해시코드로 바로 배열의 데이터에 접근이 가능하기 때문에, 시간복잡도가 O(1)이다. 단점: 1개의 배열방에 여러 데이터가 겹쳐서 저장되는 경우를 Collision(충돌)이라고 하는데, 이 경우 시간복잡도는 O(n)이다. 이는, 배열방에서 그 Key 값을 찾기 위해, 그 배열방에 연결 리스트를 순회화면서 그 Key 값을 찾아야 하기 때문이다. 이런 문제가 생기는 경우는 크게 2가지이다. 서로 다른 Key 값이지만, 동일한 해시코드로 반환받는 경우 Key 값은 문자열이고 그 가짓수가 무한한대 반해서 해시코드는 정수개 밖에 제공을 못하기 때문에, 알고리즘이 아무리 좋아도 어떤 Key들은 중복되는 해시코드를 가질 수 밖에 없다. 서로 다른 해시코드이지만, 동일한 인덱스로 바뀌는 경우 배열방은 한정되어 있기 때문에, 서로 다른 해시코드이더라도, 환산할 때 동일한 인덱스를 얻게 되는 경우가 있을 수 있기 때문에, 같은 배열방에 배정받는 경우도 있다. 이런 Collision을 최소화하기 위해서는 좋은 해시 알고리즘을 만드는 것이 중요하다. 즉, 배열방을 나눌 때, 규칙을 잘 만들어야 한다.","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"https://cheonmro.github.io/categories/Computer-Science/"}],"tags":[{"name":"Hash Table","slug":"Hash-Table","permalink":"https://cheonmro.github.io/tags/Hash-Table/"}]},{"title":"리스트(List)란 무엇인가?","slug":"what-is-list","date":"2018-11-04T06:42:53.000Z","updated":"2018-11-04T06:42:53.202Z","comments":true,"path":"2018/11/04/what-is-list/","link":"","permalink":"https://cheonmro.github.io/2018/11/04/what-is-list/","excerpt":"","text":"리스트(List) 리스트란, 자료를 순서대로 한 줄로 저장하는 선형 자료구조이다. head: 리스트에서 제일 처음 데이터를 head라고 한다. tail: 리스트에서 제일 마지막 데이터를 tail이라고 한다. 리스트(List)의 종류 리스트는 구현방식에 따라, 다음과 같이 분류된다. 순차 리스트(Array List): 배열을 기반으로 구현된 리스트 연결 리스트(Linked List 메모리의 동적 할당을 기반으로 구현된 리스트 출처: ArrayList vs. LinkedList 두 리스트의 차이점을 더 자세하게 알고 싶다면, Linked List와 Array의 차이점를 클릭한다. 연결 리스트(Linked List)의 종류 1. Simple Linked List(단순 연결 리스트) 단순 연결 리스트란, 연결의 형태가 한쪽 방향으로 전개되고 시작과 끝이 분명히 존재하는 리스트를 말한다. 출처: Simple Linked List 2. Doubly Linked List(이중/양방향 연결 리스트) 이중/양방향 연결 리스트란, 노드가 양쪽 방향으로 연결된 구조의 리스트를 말한다. 즉, 왼쪽 노드가 오른쪽 노드를 가리킴과 동시에 오른쪽 노드도 왼쪽 노드를 가리키는 구조이다. 출처: Doubly Linked List 3. Circular Linked List(원형/환형 연결 리스트) 원형/환형 연결 리스트란, 단순 연결 리스트에서 마지막 노드가 첫 번째 노드를 가리켜서 연결의 형태가 원을 이루는 리스트를 말한다. 출처: Circular LinkedList","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"https://cheonmro.github.io/categories/Computer-Science/"}],"tags":[{"name":"Data Structures","slug":"Data-Structures","permalink":"https://cheonmro.github.io/tags/Data-Structures/"},{"name":"List","slug":"List","permalink":"https://cheonmro.github.io/tags/List/"}]},{"title":"자료구조(Data Structures)의 분류","slug":"types-of-data-structures","date":"2018-11-04T05:41:46.000Z","updated":"2018-11-04T05:41:46.897Z","comments":true,"path":"2018/11/04/types-of-data-structures/","link":"","permalink":"https://cheonmro.github.io/2018/11/04/types-of-data-structures/","excerpt":"","text":"자료구조(Data Structures) 자료구조란, 자료의 집합으로써, 각 원소들이 논리적으로 정의된 규칙에 의해 나열되며 자료에 대한 처리를 효율적으로 수행할 수 있도록 자료를 구분하여 표현한 것을 말한다. 자료구조의 분류 자료구조는 다음과 같이 분류되어 있다. 출처: Data Structures","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"https://cheonmro.github.io/categories/Computer-Science/"}],"tags":[{"name":"Data Structures","slug":"Data-Structures","permalink":"https://cheonmro.github.io/tags/Data-Structures/"}]},{"title":"Stack과 Queue, 그리고 Deque의 차이점","slug":"stack-vs-queue","date":"2018-11-04T05:20:18.000Z","updated":"2018-11-04T05:20:18.745Z","comments":true,"path":"2018/11/04/stack-vs-queue/","link":"","permalink":"https://cheonmro.github.io/2018/11/04/stack-vs-queue/","excerpt":"","text":"Stack Stack이란, 한쪽 끝에서만 데이터의 삽입, 삭제가 이루어지는 자료구조다. 가장 마지막에 삽입된 항목이 맨 먼저 삭제된다. -&gt; Last In First Out(LIFO) push: Stack에 데이터를 넣는 연산 pop: Stack에 데이터를 꺼내는 연산 peek: Stack에 데이터를 들여다 보는 연산 출처: Stack Stack 구현 1. class를 이용한 Stack 구현(ES6) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// ES6class Stack &#123; constructor() &#123; this.count = 0; this.dataStore = []; &#125; push(element) &#123; this.dataStore[this.count] = element; this.count++; &#125; pop() &#123; if(this.count &gt;= 1) &#123; let val = this.dataStore[this.count - 1]; this.count--; return val; &#125; return null; &#125; peek() &#123; return this.dataStore[this.count - 1]; &#125; size() &#123; return this.count; &#125; isEmpty() &#123; return this.count === 0; &#125; clear() &#123; this.count = 0; this.dataStore = []; &#125;&#125;// for Testconst stack = new Stack();console.log(stack); // &#123; count: 0, dataStore: [] &#125;stack.push(&apos;ro1&apos;);stack.push(&apos;ro2&apos;);stack.push(&apos;ro3&apos;);console.log(stack.peek()); // ro3console.log(stack.pop()); // ro3console.log(stack.pop()); // ro2console.log(stack.size()); // 1console.log(stack.isEmpty()); // falseconsole.log(stack.pop()); // ro1console.log(stack.pop()); // null 2. 생성자 함수를 이용한 Stack 구현(ES5) 123456789101112131415161718192021222324252627282930313233343536373839404142434445// ES5function Stack() &#123; var dataStore = []; var count = 0; this.push = function(element) &#123; dataStore[count] = element; count++; &#125;; this.pop = function() &#123; if(count &gt;= 1) &#123; let val = dataStore[count - 1]; count--; return val; &#125; return null; &#125;; this.peek = function() &#123; return dataStore[count - 1]; &#125;; this.size = function() &#123; return count; &#125;; this.isEmpty = function() &#123; return count === 0; &#125;;&#125;// for Testvar stack = new Stack();console.log(stack); // &#123; push: [Function], pop: [Function], peek: [Function], size: [Function], isEmpty: [Function] &#125;stack.push(&apos;ro1&apos;);stack.push(&apos;ro2&apos;);stack.push(&apos;ro3&apos;);console.log(stack.peek()); // ro3console.log(stack.pop()); // ro3console.log(stack.pop()); // ro2console.log(stack.size()); // 1console.log(stack.isEmpty()); // falseconsole.log(stack.pop()); // ro1console.log(stack.pop()); // null Queue Queue란, 데이터의 삽입이 한쪽 끝(뒤, rear)에서 이루어지고, 삭제는 다른 쪽(앞, front)에서 이루어지는 자료구조다. 가장 처음 삽입된 항목이 맨 먼저 삭제된다. -&gt; First In First Out(FIFO) enqueue: Queue에 데이터를 넣는 연산 dequeue: Queue에 데이터를 꺼내는 연산 출처: Queue Queue 구현(2개의 Stack으로 Queue 구현) 1. class를 이용한 Queue 구현(ES6) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// Stackclass Stack &#123; constructor() &#123; this.count = 0; this.dataStore = []; &#125; push(element) &#123; this.dataStore[this.count] = element; this.count++; &#125; pop() &#123; if(this.count &gt;= 1) &#123; let val = this.dataStore[this.count - 1]; this.count--; return val; &#125; return null; &#125; peek() &#123; return this.dataStore[this.count - 1]; &#125; size() &#123; return this.count; &#125; isEmpty() &#123; return this.count === 0; &#125; clear() &#123; this.count = 0; this.dataStore = []; &#125;&#125;// Queueclass Queue &#123; constructor() &#123; this.inbox = new Stack(); this.outbox = new Stack(); this.size = 0; &#125; eneque(element) &#123; this.inbox.push(element); &#125; dequeue() &#123; if(this.outbox.size() === 0) &#123; while(this.inbox.size()) &#123; this.outbox.push(this.inbox.pop()); &#125; &#125; return this.outbox.pop(); &#125; size() &#123; return this.inbox.size() + this.outbox.size(); &#125;&#125;// for Testconst queue = new Queue();console.log(queue); // &#123; inbox: Stack &#123; count: 0, dataStore: [] &#125;, outbox: Stack &#123; count: 0, dataStore: [] &#125; size: 0 &#125;queue.eneque(&apos;a&apos;);queue.eneque(&apos;b&apos;);queue.eneque(&apos;c&apos;);console.log(queue.dequeue()); // aconsole.log(queue.dequeue()); // bqueue.eneque(&apos;d&apos;);queue.eneque(&apos;e&apos;);console.log(queue.dequeue()); // cconsole.log(queue.dequeue()); // d 2. 생성자 함수를 이용한 Queue 구현(ES5) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// Stackfunction Stack() &#123; var dataStore = []; var count = 0; this.push = function(element) &#123; dataStore[count] = element; count++; &#125;; this.pop = function() &#123; if(count &gt;= 1) &#123; let val = dataStore[count - 1]; count--; return val; &#125; return null; &#125;; this.peek = function() &#123; return dataStore[count - 1]; &#125;; this.size = function() &#123; return count; &#125;; this.isEmpty = function() &#123; return count === 0; &#125;;&#125;// Queuefunction Queue() &#123; var inbox = new Stack(); var outbox = new Stack(); this.eneque = function(element) &#123; inbox.push(element); &#125;; this.dequeue = function() &#123; if (outbox.size() === 0) &#123; while (inbox.size()) outbox.push(inbox.pop()); &#125; return outbox.pop(); &#125;; this.size = function()&#123; return inbox.size() + outbox.size(); &#125;;&#125;// for Testvar queue = new Queue();console.log(queue); // &#123; eneque: [Function], dequeue: [Function], size: [Function] &#125;queue.eneque(&apos;a&apos;);queue.eneque(&apos;b&apos;);queue.eneque(&apos;c&apos;);console.log(queue.dequeue()); // aconsole.log(queue.dequeue()); // bqueue.eneque(&apos;d&apos;);queue.eneque(&apos;e&apos;);console.log(queue.dequeue()); // cconsole.log(queue.dequeue()); // d Deque Deque란, 데이터의 삽입과 삭제를 앞, 뒤 양쪽에서 이루어지는 자료구조다. 출처: Deque","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"https://cheonmro.github.io/categories/Computer-Science/"}],"tags":[{"name":"Queue","slug":"Queue","permalink":"https://cheonmro.github.io/tags/Queue/"},{"name":"Stack","slug":"Stack","permalink":"https://cheonmro.github.io/tags/Stack/"},{"name":"Deque","slug":"Deque","permalink":"https://cheonmro.github.io/tags/Deque/"}]},{"title":"Linked List와 Array의 차이점","slug":"linkedlist-vs-array","date":"2018-11-03T07:20:39.000Z","updated":"2018-11-03T07:20:39.427Z","comments":true,"path":"2018/11/03/linkedlist-vs-array/","link":"","permalink":"https://cheonmro.github.io/2018/11/03/linkedlist-vs-array/","excerpt":"","text":"Linked List(연결 리스트) Linked List란, 데이터를 논리적 순서에 따라 입력하지만, 물리적 주소는 순차적이지 않는 자료구조를 말한다. Linked List의 특징: 장점: Linked List에 데이터를 삽입하거나, 삭제시에 각 데이터가 가지고 있는 링크만 변경하면 되므로, 다른 데이터의 영향없이 빠르게 가능하다. 단점: 배열의 인덱스 대신에 각 데이터가 이전 위치 및 다음 위치를 가리키는 링크를 가지고 있기 때문에, 데이터에 한번에 접근할 수는 없고, 연결되어 있는 링크를 따라가야 하기 때문에, 배열에 비해 속도가 느리다. Array(배열) Array란, 데이터를 논리적 순서에 따라 순차적으로 데이터를 입력하며, 물리적 주소 또한 순차적인 자료구조를 말한다. Array의 특징: 장점: 인덱스를 가지고 있어서 원하는 데이터에 한번에 접근이 가능하기 때문에 접근속도가 빠르다. 단점: Array에 데이터를 삽입하거나 삭제할 시에 배열을 통째로 복사해서 삽입/삭제가 이루어지고, 삽입/삭제가 이루어진 위치의 다음부터 모든 데이터의 위치를 변경해야 하기 때문에, 삽입/삭제 때마다 데이터의 위치를 바꾸는 데만 많은 리소스를 사용하게 된다. 1. 접근 속도(Access) Linked List: 최소 한번은 리스트를 순회해야 하기 때문에, 시간복잡도는 O(n)이다. Array: 인덱스로 접근하기 때문에, 시간복잡도는 O(1)이다. 출처: Array vs. LinkedList 2. 삽입/삭제 속도(Add/Remove) Linked List: 어느 곳에 삽입/삭제를 하던간에 리스트를 순회해야 하기 때문에, 시간복잡도는 O(n)이다. Array: 데이터를 삽입/삭제시에 삽입 또는 삭제될 위치 그 이후의 데이터를 한 칸씩 미뤄야하는 추가과정과 시간 등 리소스가 소비됨.(Linked List는 필요없음) 또한, 데이터를 삽입시에 모든 공간이 다 꽉 차버렸다면, 새로운 메모리 공간이 필요함.(Linked List는 필요없음) 목적과 상황에 따라 선택해야 하는 자료구조 Linked List를 사용해야 하는 경우: 데이터의 삽입/삭제가 자주 일어나야 한다면 사용Array를 사용해야 하는 경우: 데이터의 삽입/삭제가 많이 없고, 대신에 데이터의 접근이 자주 일어나야 한다면 사용","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"https://cheonmro.github.io/categories/Computer-Science/"}],"tags":[{"name":"Linked List","slug":"Linked-List","permalink":"https://cheonmro.github.io/tags/Linked-List/"},{"name":"Array","slug":"Array","permalink":"https://cheonmro.github.io/tags/Array/"}]},{"title":"Javascript에서의 this","slug":"what-is-this","date":"2018-11-01T01:54:20.000Z","updated":"2018-11-01T01:54:20.385Z","comments":true,"path":"2018/11/01/what-is-this/","link":"","permalink":"https://cheonmro.github.io/2018/11/01/what-is-this/","excerpt":"","text":"Javascript에서의 this는 다음과 같은 규칙을 따른다. 기본적으로, this는 전역객체(window)를 가리킨다. 예외1: 생성자 함수내의 this는 생성자 함수가 생성한 객체를 가리킨다. 예외2: 메소드 내에서 this는 메소드를 호출한(소유한) 객체를 가리킨다. 그외는 this는 언제나 window를 가리킨다. 또는, 명시적으로 this를 바꿀 수 있다.(apply() &amp; call() 메소드 사용)","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://cheonmro.github.io/categories/Javascript/"}],"tags":[{"name":"this","slug":"this","permalink":"https://cheonmro.github.io/tags/this/"}]},{"title":"Prototype이란 무엇인가?","slug":"what-is-prototype","date":"2018-10-31T15:59:03.000Z","updated":"2018-10-31T17:00:28.021Z","comments":true,"path":"2018/11/01/what-is-prototype/","link":"","permalink":"https://cheonmro.github.io/2018/11/01/what-is-prototype/","excerpt":"","text":"Prototype과 Prototype Architecture Prototype(객체)이란, 새로 생성된 인스턴스(객체)의 부모의 역할을 하는 객체를 말한다. 여기서 부모의 역할이란, 새로 생성된 인스턴스(객체)가 부모 객체의 프로퍼티 또는 메소드를 상속받아 사용할 수 있다는 뜻이다. Prototype 객체는 생성자 함수에 의해 생성된 각각의 객체에 공유 프로퍼티를 제공하기 위해 사용한다. Java, C++과 같은 클래스 기반 객체지향 프로그래밍 언어와 달리 자바스크립트는 프로토타입 기반 객체지향 프로그래밍 언어이다. 클래스 기반 객체지향 프로그래밍 언어는 객체 생성 이전에 클래스를 정의하고 이를 통해 객체(인스턴스)를 생성한다. 하지만 프로토타입 기반 객체지향 프로그래밍 언어는 클래스 없이(Class-less)도 객체 리터럴 방식 또는 생성자 함수를 이용해서 객체를 생성할 수 있다. (ECMAScript 6에서 클래스가 추가되었다) 기본적으로 Prototype과 관련된 개념은 다음과 같다. 출처: Prototype Architecture 어떤 생성자 함수(Person 생성자 함수)에 의해 인스턴스(foo 객체)가 생성되면, 그 인스턴스의 부모 역할을 하는 프로토타입 객체(Person.prototype)가 결정된다. 위 그림에서, 생성된 인스턴스는 name, gender 프로퍼티와, sayHello 메소드를 가지고 있다. ECMAScript spec에서는 자바스크립트의 모든 객체는 자신의 프로토타입을 가리키는 [[Prototype]]이라는 숨겨진 프로퍼티를 가진다 라고 되어있다. 크롬, 파이어폭스 등에서는 숨겨진 [[Prototype]] 프로퍼티가 __proto__ 프로퍼티로 구현되어 있다. 즉, __proto__과 [[Prototype]]은 같은 개념이다. foo 객체는 __proto__ 프로퍼티로 자신의 부모 객체(프로토타입 객체)인 Person.prototype을 가리키고 있다. 객체를 생성할 때 프로토타입은 결정된다. 결정된 프로토타입 객체는 다른 임의의 객체로 변경할 수 있다. 이것은 부모 객체인 프로토타입을 동적으로 변경할 수 있다는 것을 의미한다. 이러한 특징을 활용하여 객체의 상속을 구현할 수 있다. constructor 프로퍼티 프로토타입 객체는 constructor 프로퍼티를 갖는다. 이 constructor 프로퍼티는 객체의 입장에서 자신을 생성한 객체를 가리킨다. 예를 들어 Person() 생성자 함수에 의해 생성된 객체를 foo라 하자. 이 foo 객체를 생성한 객체는 Person() 생성자 함수이다. 이때 foo 객체 입장에서 자신을 생성한 객체는 Person() 생성자 함수이며, foo 객체의 프로토타입 객체는 Person.prototype이다. 따라서 프로토타입 객체 Person.prototype의 constructor 프로퍼티는 Person() 생성자 함수를 가리킨다. Prototype Chain 자바스크립트는 특정 객체의 프로퍼티나 메소드에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티 또는 메소드가 없다면 [[Prototype]] 프로퍼티가 가리키는 링크를 따라 자신의 부모 역할을 하는 프로토타입 객체의 프로퍼티나 메소드를 차례대로 검색한다. 이것을 프로토타입 체인이라 한다. 프로토타입 체인 동작 조건 객체의 프로퍼티를 참조하는 경우, 해당 객체에 프로퍼티가 없는 경우, 프로토타입 체인이 동작한다. 객체의 프로퍼티에 값을 할당하는 경우, 프로토타입 체인이 동작하지 않는다. 이는 객체에 해당 프로퍼티가 있는 경우, 값을 재할당하고 해당 프로퍼티가 없는 경우는 해당 객체에 프로퍼티를 동적으로 추가하기 때문이다. 출처: 프로토타입 체인 동작 조건","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://cheonmro.github.io/categories/Javascript/"}],"tags":[{"name":"Prototype","slug":"Prototype","permalink":"https://cheonmro.github.io/tags/Prototype/"}]},{"title":"Closure란 무엇인가?","slug":"what-is-closures","date":"2018-10-31T14:52:06.000Z","updated":"2018-10-31T14:52:06.449Z","comments":true,"path":"2018/10/31/what-is-closures/","link":"","permalink":"https://cheonmro.github.io/2018/10/31/what-is-closures/","excerpt":"","text":"클로저(Closure) 클로저란, 외부함수와 내부함수가 있을 때, 외부함수에 의해 내부함수가 반환된 이후에도, 내부함수에서 외부함수에 있는 변수를 참조할 수 있는 것을 말한다. 조건 3가지 외부함수와 내부함수가 존재 내부함수가 외부함수에 있는 변수를 참조해야 한다. 외부함수가 내부함수를 return(라이프사이클과 관련) 해야한다. 내부함수가 외부함수보다 더 긴 라이프 사이클을 가지고 있을때,외부함수에 있는 변수를 내부함수가 참조하는데, 그 변수의 값은 유지되어있다. 실행 컨텍스트의 관점에서 이해해보자. 기본적으로 실행 컨텍스트는 함수가 종료되면, 실행 컨텍스트 스택에서 제거된다. 그래서 외부함수에서 내부함수를 반환하고, 모두 실행이 되면, 외부함수의 실행 컨텍스트는 제거된다. 그럼에도 불구하고, 내부함수에서 외부함수의 실행 컨텍스트 내에 있는 활성 객체는 유효하기 때문에, 내부함수에서 외부함수의 변수를 참조할 수 있다. (이때, 이 변수를 자유변수라고 한다.) 이는 내부함수가 스코프 체인을 통해 참조하려는 변수를 먼저 내부함수에서 찾고(내부함수 안에 있는 스코프체인의 ‘0’이 가리키는 활성객체에 참조하려는 변수가 있는지 확인한다.), 없으면, 상위지역인 외부함수에서 찾는다.(내부함수 안에 있는 스코프체인의 ‘1’이 가리키는 활성객체, 즉 외부함수의 활성객체에 들어있는 변수를 말한다.) 이때 내부함수가 외부함수에 있는 변수의 복사본이 아니라, 실제 변수에 접근하는 것이다. 위 내용을 예제와 함께 요약하면 다음과 같다.12345678function outerFunc() &#123; var x = 10; var innerFunc = function () &#123; console.log(x); &#125;; return innerFunc;&#125;var inner = outerFunc();inner(); // 10 순서 외부함수(outerFunc)가 내부함수(innerFunc)를 반환하고, 외부함수는 종료된다.(이때, 외부함수의 실행 컨텍스트는 실행 컨텍스트 스택에서 제거된다.) 내부함수에서 변수 x를 참조하려 할 때, 먼저 내부함수(자기자신) 내에서 그 변수를 찾는다.(내부함수의 스코프체인의 ‘0’이 가리키는 활성객체내에 변수 x를 찾는다.) 내부함수내에 없으면, 그 내부함수를 포함하고 있는 외부함수 내에서 그 변수를 찾는다.(내부함수의 스코프체인의 ‘1’이 가리키는 활성객체내에 변수 x를 찾아 참조한다.) 이때 내부함수가 외부함수에 있는 변수의 복사본이 아니라, 실제 변수에 접근한다.!","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://cheonmro.github.io/categories/Javascript/"}],"tags":[{"name":"Closures","slug":"Closures","permalink":"https://cheonmro.github.io/tags/Closures/"}]},{"title":"실행 컨텍스트란 무엇인가?","slug":"what-is-execution-context","date":"2018-10-31T14:42:23.000Z","updated":"2018-10-31T14:42:23.820Z","comments":true,"path":"2018/10/31/what-is-execution-context/","link":"","permalink":"https://cheonmro.github.io/2018/10/31/what-is-execution-context/","excerpt":"","text":"실행 컨텍스트(Execution Context) 실행 컨텍스트란, 실행 가능한 코드가 실행되기 위해 필요한 환경을 의미하는데, 이 환경은 코드가 실행되기 전에 설정이 된다. 이때, 실행 가능한 코드는 총 3개(전역코드/함수코드/Eval코드)가 있는데, 일반적으로 전역코드/함수코드를 말한다. 여기서 환경이 설정된다는 것은 실행에 필요한 여러가지 정보를 담는다는 뜻이다. 코드가 전역변수와 외부함수 그리고 그 안에 내부함수 있다고 해보자. 코드가 실행되기 전, 전역에 실행 컨텍스트가 생성이 되는데, 이것을 전역 실행 컨텍스트라고 한다. 전역 실행 컨텍스트가 생성이 되면, 실행 컨텍스트 스택(콜 스택)에 추가된다. 그리고, 외부함수가 호출이 되면, 외부함수가 실행되기 전에 외부함수에 대한 실행 컨텍스트가 생성이 되는데, 이것을 함수 실행 컨텍스트라고 한다. 이 외부함수 실행 컨텍스트 또한 실행 컨텍스트 스택에 그 전에 추가된 전역 실행 컨텍스트 위에 쌓이게 된다. 내부함수 또한 호출되면, 내부함수 실행되기 전에 내부함수 실행 컨텍스트가 생성되고, 실행 컨텍스트 스택에 있는 외부함수 실행 컨텍스트 위에 쌓이게 된다. 전체적인 과정에서 봤을때, 코드의 종류(전역코드/함수코드)에 따라 실행 컨텍스트가 생성되고, 실행 컨텍스트 스택에 쌓이는 구조이다. 실행 컨텍스트가 생성되고 코드가 실행되기 전에, 실행 컨텍스트는 3가지 프로퍼티를 가지게 된다. Scope Chain VO(변수객체) thisvalue 실행 컨텍스트가 생성이 되면, 먼저 Scope Chain이라는 전역 객체 또는 활성 객체를 가리키는 리스트가 생성되고 초기화 된다. 리스트는 배열처럼 ‘0’: {}, ‘1’: {}, 이런 방식으로 생성되는데, ‘0’은 자기자신(위치)를 가리키고, 1은 자기 위치의 상위 지역을 가리킨다. 예를 들어, 외부함수의 Scope Chain의 ‘0’은 자기 자신인 외부함수를 가리키고, ‘1’은 외부함수의 상위지역인 전역코드를 가리킨다. 좀 더 구체적으로 말하면, ‘0’은 자기자신(외부함수)가 가지고 있는 활성객체(A0)를 가리키고, ‘1’은 상위지역인 전역코드가 가지고 있는 전역객체(GO)를 가리킨다. 그리고, 변수 객체(VO)가 생성되어, 각 코드(전역코드/함수코드)가 가지고 있는 객체를 담는다. 전역코드의 경우, 전역함수와 전역변수를 가지고 있고, 함수코드의 경우, arguments, 내부함수, 지역변수 등을 가지고 있다. this의 값은 문맥에 따라 결정이 되는데, 예외사항이 아니면 전역객체를 가리킨다. 위 내용을 요약하면 다음과 같다. 순서 브라우저안에 기본적으로 전역객체(window)가 존재 (브라우저에서) 코드가 실행되기전, 전역 실행 컨텍스트가 생성 전역 실행 컨텍스트가 생성되면서, Scope Chain의 리스트 생성 및 초기화(이때, Scope Chain의 리스트 ‘0’은 전역객체를 가리킨다) 변수객체의 생성후, 변수객체에 전역변수 및 전역함수를 추가 전역함수를 추가할 때, 전역 함수 객체는 [[Scopes]] 프로퍼티를 가짐(이 프로퍼티는 함수 객체만이 소유하는 내부 프로퍼티로, 함수 객체가 실행되는 환경을 가리킨다.) this 값이 결정되기 이전에 this는 전역 객체를 가리키다가, 함수 호출 패턴에 의해 this에 할당되는 값이 결정됨 전역코드가 실행(예를 들어, 전역변수에 값이 할당되고, 전역함수가 호출됨) 외부함수가 호출되면, 외부함수에 대한 실행 컨텍스트 생성 외부함수도 전역 실행 컨텍스트와 같은 방식으로 진행 이때, 외부함수의 변수객체에는 arguments, 내부함수, 지역변수 등이 포함됨 외부함수 실행 내부함수도 위와 동일 위에서 생성된 각 실행 컨텍스트가 순서대로 실행 컨텍스트 스택에 하나씩 쌓이고, 함수 실행이 끝나면, 해당 함수의 실행 컨텍스트가 제거된다. 전역 실행 컨텍스트는 애플리케이션이 종료될 때까지 유지된다.!!","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://cheonmro.github.io/categories/Javascript/"}],"tags":[{"name":"Execution Context","slug":"Execution-Context","permalink":"https://cheonmro.github.io/tags/Execution-Context/"}]},{"title":"let & const & var","slug":"let-and-const","date":"2018-10-31T13:45:37.000Z","updated":"2018-10-31T13:45:37.821Z","comments":true,"path":"2018/10/31/let-and-const/","link":"","permalink":"https://cheonmro.github.io/2018/10/31/let-and-const/","excerpt":"","text":"var와 let/const의 차이점 ES5까지는 var를 사용했으나, var가 가지고 있는 단점들을 보완하기 위해 ES6에서는 let 과 const를 사용할 수 있다. var는 중복선언이 가능했으나, let과 const는 불가능하다. var a = 3; 이렇게 선언을 했어도, 다시 var a = 10; 이런식으로 중복 선언이 가능하다. 이는 의도치 않게 변수값을 변경하는 문제가 발생하게 된다. 하지만, let과 const로 선언을 할 경우, 중복선언을 하려고 하면, 에러가 발생하게 된다. 이렇게, let과 const를 사용하게 되면 중복선언을 미리 막을 수 있다. 유효범위가 다르다. var를 이용한 변수 선언은 유효범위가 함수레벨이다. 즉, 함수내에서는 지역변수이고, 함수 밖에서는 전역변수이다.let과 const를 이용한 변수 선언은 유효범위가 블록레벨이다. 즉, 블록내에서는 지역변수이고, 블록 밖에서는 전역변수이다. let 과 const 차이점 const는 상수(변하지 않는 값)를 위해 사용한다.(그렇다고 꼭 상수만을 위한 것은 아니다.) let은 재할당이 가능하고, const는 불가능하다. const는 반드시 선언과 동시에 할당이 이루어져야 한다. 그렇지 않으면, 문법에러가 발생한다. const 변수의 객체인 경우도 재할당이 불가능하다. 즉, 객체에 대한 참조를 변경하지 못한다는 것을 의미한다. 그러나, 할당된 객체의 프로퍼티 및 값은 변경할 수 있다.12345const user = &#123; name: &apos;Kim&apos; &#125;;user = &#123;&#125;; // TypeError: Assignment to constant variable.// 객체의 내용은 변경할 수 있다.user.name = &apos;Ro&apos;; var 와 let 과 const 활용 let: 재할당이 필요한 변수에 사용한다.const: 재할당이 필요없는 변수에 사용한다.var: ES6에서는 사용하지 않는다.","categories":[{"name":"ES6","slug":"ES6","permalink":"https://cheonmro.github.io/categories/ES6/"}],"tags":[{"name":"let","slug":"let","permalink":"https://cheonmro.github.io/tags/let/"},{"name":"const","slug":"const","permalink":"https://cheonmro.github.io/tags/const/"},{"name":"var","slug":"var","permalink":"https://cheonmro.github.io/tags/var/"}]},{"title":"브라우저 동작원리","slug":"how-browser-works","date":"2018-10-31T12:59:40.000Z","updated":"2018-10-31T12:59:40.291Z","comments":true,"path":"2018/10/31/how-browser-works/","link":"","permalink":"https://cheonmro.github.io/2018/10/31/how-browser-works/","excerpt":"","text":"브라우저 동작원리(How Browser Works) 브라우저와 서버와의 통신은 다음과 같이 진행된다. 출처: How Browser Works 브라우저의 핵심 기능은 사용자가 브라우저에서 URL 입력창에 어떤 사이트를 입력하게 될 때, 그 사이트의 서버에 요청(Request)을 하고, 서버로부터 응답(Response)을 받아 브라우저에 그 사이트의 웹페이지를 표시하는 것이다. 이때, 브라우저는 서버로부터 HTML, CSS, Javascript, 그리고 이미지 파일 등을 받는데, 그 과정은 다음과 같다. 브라우저가 서버에 첫 요청을 하고, 서버는 먼저 index.html을 응답으로 브라우저에 보낸다. 브라우저의 렌더링 엔진에 있는 HTML 파서에 의해 파싱(해독)되어, DOM 트리를 생성한다. HTML 파서가 html 파일을 파싱할 때, css 태그를 만나면 다시 서버에 요청하고, 서버는 css 파일을 응답으로 브라우저에 보내준다. 그러면, 브라우저의 렌더링 엔진에 있는 CSS 파서에 의해 파싱되어, CSSOM 트리를 생성한다. 또한, HTML 파서는 script 태그를 만나게 되면, 자바스크립트 코드를 실행하기 위해, DOM 생성 프로세스를 중지하고, 자바스크립트 엔진으로 제어 권한을 넘긴다. 그리고, 다시 서버에 요청해, 응답으로 자바스크립트 파일을 응답받아, 자바스크립트 엔진은 자바스크립트 파일을 파싱하여 실행한다. 자바스크립트의 실행이 완료되면, 다시 HTML 파서로 제어 권한을 넘겨서 브라우저가 중지했던 시점부터 DOM 생성을 재개한다. DOM 생성이 완료되면, DOM과 CSSOM 트리는 최종적으로 렌더 트리로 결합하게 된다. 이 렌더 트리를 기반으로 브라우저는 웹페이지를 화면에 표시하게 된다. 이처럼, 브라우저는 동기적으로 HTML/CSS/Javascript를 처리한다. 이는 script 태그의 위치에 따라 블로킹이 발생하여, DOM 생성이 지연될 수 있다는 것을 의미한다. 즉, script 태그의 위치는 중요하다. 그래서, body 요소의 가장 아래에 자바스크립트 태그를 위치시키는 것이 좋다. 그 이유는 다음과 같다. HTML 요소들이 자바스크립트 로딩 지연으로 인해 렌더링에 지장 받는 일이 발생하지 않기 때문에, 웹페이지 로딩 시간이 단축되기 때문이다. DOM이 완성되지 않은 상태에서 자바스크립트가 DOM을 조작하게 된다면, 에러가 발생할 수 있기 때문이다.","categories":[{"name":"Network","slug":"Network","permalink":"https://cheonmro.github.io/categories/Network/"}],"tags":[{"name":"Browser","slug":"Browser","permalink":"https://cheonmro.github.io/tags/Browser/"}]},{"title":"정렬(sort) 알고리즘","slug":"sort-algorithms","date":"2018-10-31T06:54:39.000Z","updated":"2018-10-31T06:54:39.373Z","comments":true,"path":"2018/10/31/sort-algorithms/","link":"","permalink":"https://cheonmro.github.io/2018/10/31/sort-algorithms/","excerpt":"","text":"정렬 알고리즘 정렬 알고리즘이란, 원소들을 번호순이나 사전 순서와 같이 일정한 순서대로 열거하는 알고리즘이다. 정렬 알고리즘은 명함을 어떤 순서로 정리할까?와 같은 문제이다.1만장의 명함이 있고, 가나다 순으로 정리되어 있는데, 어느 날 새로운 명함을 받았다면, 그 명함을 가나다 순에 맞춰 끼워 넣어야 한다면 그 뒤에 명함들은 한 칸씩 뒤로 밀어야 하는 번거로움이 있다. 밀리는 명함이 1장일 수도 있고, 수천장일 수도 있다. 즉, 가나다 순으로 명함을 정리해두는 것이 머릿속에서는 편리하다고 생각되더라도 실제 관리하기에는 여간 불편한 것이 아니다. 정렬 알고리즘에서 중요한 점은 2가지다. 어떤 데이터를 사용하는가? 어떤 정렬 조건을 사용하는가? 데이터를 정렬할 때, 무조건 하나의 정렬 알고리즘을 사용하는 것은 바람직하지 않다. 데이터를 정렬할 여러 가지 조건(데이터의 개수, 사용할 수 있는 메모리의 양 등)을 분석해서 가장 합당한 정렬 알고리즘을 선택하는 지혜가 필요하다. 정렬 알고리즘 종류 퀵 정렬 알고리즘(Quick Sort) 병합 정렬 알고리즘(Merge Sort) 버블 정렬 알고리즘(Bubble Sort) 선택 정렬 알고리즘(Selection Sort) 퀵 정렬 알고리즘(Quick Sort) 퀵 정렬 알고리즘: 리스트의 한 요소를 피벗(Pivot: 기준값)으로 선정한 다음, 피벗보다 작은 요소를 하위(왼쪽) 리스트로, 피벗보다 큰 요소를 상위(오른쪽) 리스트로 이동시키는 알고리즘이다. 예를 들어, 배열 [3, 9, 4, 7, 5, 0, 1, 6, 8, 2] 있다고 해보자. 여기서 피벗을 5라고 정하고, 5보다 작은 요소를 왼쪽으로, 큰 요소를 오른쪽으로 보내는 작동 방식에 대해 알아보자. 왼쪽 맨끝을 s(시작 포인트), 오른쪽 맨끝을 e(끝 포인트)라고 하자. s부터 피벗과 비교해서, s가 피벗보다 작으면 s는 오른쪽으로 한칸 이동후, 피벗과 비교한다. 만약, s가 피벗보다 크면 잠깐 멈춰있고, e를 피벗과 비교하기 시작한다. e가 피벗보다 크면 e는 왼쪽으로 한칸 이동후, 피벗과 다시 비교한다. 만약, e가 피벗보다 작으면 잠깐 멈춘후, 아까 멈춘 s의 값과 서로 바꾼다.(swap) 위 배열에서 s는 9가 되고, e는 2가 된다. 이 두 개의 숫자를 서로 바꾼다. 그럼, [3, 2, 4, 7, 5, 0, 1, 6, 8, 9] 배열이 된다. 그리고, 다시 s를 한칸 오른쪽으로 이동후, 피벗과 비교한다. 만약, s의 값이 피벗보다 클 경우, 잠깐 멈춰있고, e도 피벗과 비교하기 시작한다. 이런식으로 1바퀴를 돌게 되면 배열은 다음과 같다. [3, 2, 4, 1, 0, 5, 7, 6, 8, 9] s와 e가 서로 정한 범위를 벗어나게 되면, 이 루프가 끝나게 된다. 그러면 총 2개의 partition(smaller/bigger)이 만들어진다. 그 다음에는, 양쪽 배열(partition)을 가지고 반복적으로 퀵 정렬 함수를 재귀적으로 호출하면, partition의 값이 1개가 될 때까지 계속적으로 반복해서 작은 값과 큰값의 위치를 바꾸게 된다. 이때, partition이 왼쪽/오른쪽에 1개면 더이상 재귀호출을 하지 않는다. 퀵 정렬 알고리즘은 큰 데이터 집합을 가장 빨리 정렬할 수 있는 알고리즘이다.1234567891011121314151617181920212223242526function qSort(arr) &#123; if (arr.length == 0) &#123; return []; &#125; let left = []; let right = []; const pivot = arr[0]; for (let i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return qSort(left).concat(pivot, qSort(right));&#125;console.log(qSort([3, 9, 4, 7, 0, 1, 5, 8, 6, 2])); // [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]// random input array for testvar a = [];for (var i = 0; i &lt; 10; ++i) &#123; a[i] = Math.floor((Math.random()*100)+1);&#125;console.log(a);console.log(qSort(a)); 위 코드의 시간복잡도를 계산하면 T(n) = nlogn 이다. 이것을 Big-O 표기법으로 나타내면 O(nlogn)이다. partion을 나누는 수가 n번인데, 이는 partion을 계속 나누다 보면, 결국 낱개가 될 때까지 나누기 때문이다. 그런데 1번 나누면, 2번째 나눌 때는 전체에서 2개로 나눈 결과를 가지고 또 나누는 것이기 때문에, 검색해야하는 데이터의 양이 줄어들었다. 마치, 이진 탐색 알고리즘과 같다. 그래서 logn번 검색하게 된다. 즉, n * logn = nlogn인 시간복잡도가 된다. 그러나, 예외도 있다. partion을 나누기 위한 pivot(기준값)이 전체 배열에서 최소값/최대값일 경우, 시간복잡도는 O(n^2)이 된다. 예를 들어, pivot(기준값)이 전체 배열에서 최소값일 경우, 제일 왼쪽으로 들어가고, 나머지 데이터에서 pivot(기준값)이 또 최소값이어서 이런식으로 된다면, 결국 모든 데이터를 모두 돌게 되어, 시간복잡도가 O(n^2)dl 된다. 하지만, 확률적으로 이런 경우는 거의 없기 때문에, 보통의 시간복잡도는 O(n^2)이 된다. 병합 정렬 알고리즘(Merge Sort) 병합 정렬 알고리즘: 함수가 호출 될때마다, 절반씩 잘라서 재귀적으로 함수를 호출하고 맨끝에 제일 작은 조각부터 두 개씩 병합해서 정렬된 배열을 병합해나가는 방식이 병합 정렬 알고리즘이다. 이미 정렬되어 있는 데이터들을 하나로 합해서 정렬하는 방법. 이러한 정렬 방법은 데이터들을 정렬하는 경우에도 사용되지만 파일에 정렬되어 있는 데이터들을 하나로 합쳐서 정렬하는 경우에도 종종 사용된다. 이미 정렬되어 있는 데이터 그룹들 혹은 묶음들을 하나로 합할 때 사용할 수 있다. 병합 정렬 알고리즘을 사용하는 경우 배열 하나에 저장된, 정렬되지 않은 데이터들을 어떤 방식으로 정렬하는 지 알아보자. 예)정렬되지 않은 데이터가 있다고 해보자. 하나의 데이터 배열을 여러 개로 나누어서, 나중에 병합 하기 위해 묶는데, 이 묶은 데이터 그룹을 런(Run)이라고 한다. 2-way 방식은 2개씩 그룹으로 묶는다. 일단 2개씩 묶으면, 각 그룹별로 정렬을 한다. 예를 들어, 6과 1이 하나의 그룹으로 묶였다면, 1이 왼쪽에 오고, 6이 오른쪽에 오는 식으로 정렬을 한다. 그 다음으로는 2개의 런을 묶어서 하나의 런으로 합하도록 정렬한다. 만약 2, 3 런과 5, 7 런이 하나의 런으로 합쳐진 다음, 2, 3, 5, 7 사이에서 정렬이 된다. 이렇게 런(그룹)을 계속 합쳐나가면서 하나의 런으로 모두 합쳐 정렬하는 방식을 병합 정렬 알고리즘이라고 한다. 병합 정렬의 핵심은 1부터 하나의 런에 들어가는 데이터의 수를 2의 배수 기준으로 늘려서 병합하는 과정을 반복하는 것이다. 이와 같이 반복해서 병합하게 되면 결국 전체 데이터를 모두 정렬하게 되는 결과를 얻을 수 있다. 병합 정렬 알고리즘의 성능은 수치적으로만 보면 퀵 정렬 알고리즘과 비슷하다. 퀵 정렬 알고리즘이나 병합 정렬 알고리즘이나 데이터를 나눈 후에 재귀 호출을 사용하기 때문이다. 12345678910111213141516171819202122232425262728293031323334// 퀵정렬과 마찬가지로 분할 정복 알고리즘중 하나이다.function MergeSort(arr) &#123; const len = arr.length; if(len == 1) &#123; return arr; &#125; const middle = Math.floor(len / 2); const left = arr.slice(0, middle); const right = arr.slice(middle, len); function merge(left, right) &#123; let result = []; while(left.length &amp;&amp; right.length) &#123; if( left[0] &lt;= right[0] ) &#123; result.push(left.shift()); &#125; else &#123; result.push(right.shift()); &#125; &#125; while(left.length) &#123; result.push(left.shift()); &#125; while(right.length) &#123; result.push(right.shift()); &#125; return result; &#125; return merge(MergeSort(left), MergeSort(right));&#125; 위 코드의 시간복잡도를 계산하면 T(n) = nlogn 이다. 이것을 Big-O 표기법으로 나타내면 O(nlogn)이다. n개 만큼씩 logn번 돌기 때문에, 병합 정렬 알고리즘의 시간복잡도는 O(nlogn)이 된다. partition이 낱개가 될 때까지 쪼개지니까 n번 호출에, 1번 호출당 검색해야하는 데이터의 양이 절반씩 줄어드니까 logn이다. 따라서 n * logn = nlogn 시간복잡도가 된다. nlogn 시간복잡도는 이진 탐색 알고리즘에서 한 번 돌 때마다 검색 영역에 절반씩 떨어지는 것과 같은 원리이다. 병합 정렬 알고리즘은 물리적으로 배열의 가운데 값으로 partition을 나누기 때문에 최악의 경우에도 시간복잡도는 O(nlogn)이다. 퀵 정렬 알고리즘으로 따지면, pivot(기준값)을 잘 골랐을 때랑 비슷하다. 퀵 정렬 알고리즘도 최악의 경우가 아니라면, 병합 정렬 알고리즘과 같은 시간복잡도는 O(nlogn)이다. 하지만, 병합 정렬 알고리즘은 실행시에 별도의 저장공간을 필요로 하기 때문에, 공간을 사용할 수 없는 경우에는 퀵 정렬 알고리즘을 사용해야 한다. 버블 정렬 알고리즘(Bubble Sort) 버블 정렬 알고리즘: 순차적으로 바로 옆에 있는 데이터와 비교해서 옆의 데이터가 크면 자신과 위치를 바꾼다. 즉, 첫 번째 데이터가 가장 크다면 계속 옆에 있는 데이터와 자리를 바꾸면서 해당 데이터는 결국 맨 끝으로 이동하게 된다. 그리고 두 번째 위치에 있는 데이터를 또다시 옆에 있는 데이터와 비교한다. 이와 같은 과정을 마지막 데이터의 바로 전 데이터까지 반복해서 실행한다. 이 형태가 마치 버블이 부글부글 올라가는 것과 같다고 하여 버블 정렬 알고리즘이라고 한다. 예를 들어, [3, 5, 4, 2, 1] 배열이 있으면, 먼저 3과 5를 비교해서 3이 5보다 크면 둘을 바꾼다. 그런데 여기서는 5가 크므로 그대로 둔다. 그 다음은 5와 4를 비교한다. 이때, 5가 4보다 크므로 그 둘을 바꾼다. 그럼 [3, 4, 5, 2, 1] 배열이 이렇게 바뀐다. 이런식으로 비교하면 결국 5가 제일 마지막으로 이동하게 된다. 즉, [3, 4, 2, 1, 5] 배열이 된다. 그럼 가장 큰 수인 5가 배열에 제일 오른쪽으로 이동하게 되고, 다시 맨 처음부터 이웃 숫자끼리 비교한다. 이런식으로 가장 큰 수를 오른쪽으로 이동시켜 정렬하는 방식을 버블 정렬 알고리즘이라고 한다. 성능이 좋은 편이 아니라, 자주 사용되지는 않는다. 12345678910111213141516171819// 스왑 헬퍼 =&gt; 배열의 위치를 바꾼다.function swap(arr, index1, index2) &#123; let temp = arr[index1]; arr[index1] = arr[index2]; arr[index2] = temp;&#125;// 버블 정렬은 서로 이웃한 데이터들을 비교하며 가장 큰 데이터를 가장 뒤로 보내며 정렬하는 방식function BubbleSort(arr) &#123; let len = arr.length; for(let outer = len; outer &gt; 1; outer--) &#123; for(let inner = 0; inner &lt; outer; inner++) &#123; if( arr[inner] &gt; arr[inner + 1]) &#123; swap(arr, inner, inner+1); &#125; &#125; &#125; return arr;&#125;; 위 코드의 시간복잡도를 계산하면 T(n) = n^2 이다. 이것을 Big-O 표기법으로 나타내면 O(n^2)이다. 앞에서부터 한 개씩 뒤로 가면서 전체 배열 데이터를 돌기 때문에 n^2 만큼 시간이 걸린다. 선택 정렬 알고리즘(Selection Sort) 선택 정렬 알고리즘: 데이터의 처음부터 끝까지 쭉 훑어가면서 가장 작은 값을 찾아 그 값을 첫 번째 데이터와 자리를 바꾸고, 두 번째로 작은 데이터를 찾아 두 번째의 데이터와 자리를 바꾸는 방법으로 구현하는 정렬 알고리즘이다. 예를 들어, [3, 5, 4, 2, 1] 배열이 있으면, 변수 min = 3으로 할당하고, 그 다음 데이터인 5부터 하나씩 비교해 나간다. 이때, 가장 작은 값이 1 이므로 맨 앞에 있는 3과 1을 바꾼다. 그리고, 다시 두번째 요소인 5부터 오른쪽으로 하나씩 비교하면서 가장 작은 값을 찾아 5와 바꾼다. 이런식으로 정렬하는 방식이 선택 정렬 알고리즘이다. 123456789101112131415161718192021// 스왑 헬퍼 =&gt; 배열의 위치를 바꾼다.function swap(arr, index1, index2) &#123; let temp = arr[index1]; arr[index1] = arr[index2]; arr[index2] = temp;&#125;// 선택 정렬은 정렬되지 않은 데이터들에 대해 가장 작은 데이터를 찾아 가장 앞의 데이터와 교환해나가는 방식function SelectionSort(arr) &#123; let min; for(let outer = 0; outer &lt; arr.length -1; ++outer) &#123; min = outer; for(let inner = outer + 1; inner &lt; arr.length; ++inner) &#123; if( arr[inner] &lt; arr[min] ) &#123; min = inner; &#125; &#125; swap(arr, outer, min); &#125; return arr;&#125; 위 코드의 시간복잡도를 계산하면 T(n) = n^2 이다. 이것을 Big-O 표기법으로 나타내면 O(n^2)이다. 앞에서도 한칸씩 가면서 갈때마다 각 배열 요소를 한번씩 다시 돌기 때문에, n^2 만큼 시간이 걸린다.","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"https://cheonmro.github.io/categories/Computer-Science/"}],"tags":[{"name":"sort algorithms","slug":"sort-algorithms","permalink":"https://cheonmro.github.io/tags/sort-algorithms/"}]},{"title":"탐색(search) 알고리즘","slug":"search-algorithms","date":"2018-10-31T02:54:03.000Z","updated":"2018-11-05T07:11:42.623Z","comments":true,"path":"2018/10/31/search-algorithms/","link":"","permalink":"https://cheonmro.github.io/2018/10/31/search-algorithms/","excerpt":"","text":"탐색 알고리즘 탐색 알고리즘이란, 데이터를 탐색하면서 어떤 값을 찾는 알고리즘을 말한다. 탐색 알고리즘 종류 순차 탐색 알고리즘(linear search) 이진 탐색 알고리즘(binary search) 순차 탐색 알고리즘(linear search) 순차 탐색 알고리즘: 맨 앞에서부터 순서대로 탐색을 진행하는 알고리즘1234for(i = 0; i &lt; array.length; i++) &#123; if(array[i] === target) return i;&#125; 위 for문의 경우, 데이터의 수가 n개 일때, 최악의 경우에 해당하는 연산횟수는 n이다. T(n) = n, 시간복잡도는 O(n)이다. 이진 탐색 알고리즘(binary search) 이진 탐색 알고리즘: 데이터가 정렬된 상태에서, 모든 데이터의 중간부터 시작해서 크기 비교를 통해 반씩 쪼개면서 탐색하는 알고리즘이다. 즉, 배열에 저장된 데이터는 정렬되어야 할 수 있는 탐색 알고리즘이다. 예를 들어, array = [1, 2, 3, 4, 5, 6, 7, 8, 9]라는 배열이 있다고 해보자. 이 중에서 데이터 ‘6’(key 값)을 찾는다고 하면, 먼저 배열의 중간인 5와 비교한다. 이때, key 값이 더 크기 때문에 key 값은 중간값인 5를 기준으로 배열에서 오른쪽에 있다는 뜻이다. 그럼 다시 오른쪽 데이터(6, 7, 8, 9) 중에서 중간값 7를 찾아서 key 값과 비교한다. 이때, key 값이 더 작기 때문에 key 값은 중간값인 7보다 앞쪽에 있다는 뜻이다. 결국 key 값 6을 찾을 수 있게 된다. 이렇게 한번 처리가 진행될 때마다, 검색해야 하는 데이터의 양이 절반씩 떨어지는 알고리즘을 이진 탐색 알고리즘이라고 한다. 이를, 시간 복잡도로 나타내면 O(logN)이다.12345678910111213141516171819202122const findAge = (num, array) =&gt; &#123; const midPoint = Math.floor(array.length/2); // 2 if(array[midPoint] === num) &#123; return true; // 1번 실행 &#125; if(array[midPoint] &lt; num) &#123; for (let i = midPoint + 1; i &lt; array.length;) &#123; if(array[i] === num) &#123; return true; &#125; &#125; &#125; else &#123; for (let i = 0; i &lt; midPoint;) &#123; if(array[i] === num) &#123; return true; &#125; &#125; &#125;&#125;const sortedAges = [21, 23, 25, 27, 29];console.log(findAge(27, sortedAges)) // true 위 코드의 시간복잡도를 계산하면 T(n) = 1 + n/2 이다. 이것을 Big-O 표기법으로 나타내면 O(logn)이다. 재귀함수를 이용하면 다음과 같이 작성할 수도 있다.123456789101112131415const binarySearch = (numArray, key) =&gt; &#123; const middleIdx = Math.floor(numArray.length / 2); const middleElem = numArray[middleIdx]; if (middleElem === key) return true; else if (middleElem &lt; key &amp;&amp; numArray.length &gt; 1) &#123; return binarySearch(numArray.splice(middleIdx, numArray.length), key); &#125; else if (middleElem &gt; key &amp;&amp; numArray.length &gt; 1) &#123; return binarySearch(numArray.splice(0, middleIdx), key); &#125; else return false;&#125;console.log(binarySearch([21, 23, 25, 27, 29], 27)); // true","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"https://cheonmro.github.io/categories/Computer-Science/"}],"tags":[{"name":"search algorithms","slug":"search-algorithms","permalink":"https://cheonmro.github.io/tags/search-algorithms/"}]},{"title":"3. Fibonacci","slug":"fibonacci","date":"2018-10-31T01:53:41.000Z","updated":"2018-10-31T01:53:41.173Z","comments":true,"path":"2018/10/31/fibonacci/","link":"","permalink":"https://cheonmro.github.io/2018/10/31/fibonacci/","excerpt":"","text":"What is Fibonacci?Fibonacci 수열이란, 다음 수는 앞의 두 수의 합으로 이루어진 수열을 말한다.규칙에 따라 수를 나열해 보면, 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144…와 같은 수열이 된다. [Problem]피보나치 수는 F(0) = 0, F(1) = 1일 때, 2 이상의 n에 대하여 F(n) = F(n-1) + F(n-2) 가 적용되는 점화식입니다.2 이상의 n이 입력되었을 때, fibonacci 함수를 제작하여 n번째 피보나치 수를 반환해 주세요.예를 들어 n = 3이라면 2를 반환해주면 됩니다. 즉, 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144…에서 3번째 피보나치의 수는 2이다. [Algorithms] n이 0일 경우, 0을 리턴하고, 1일 경우, 1을 리턴한다.(피보나치 수열에서 0번째는 0, 1번째는 1이기 때문이다.) n이 2이상일 경우, 앞의 두 수의 합으로 계산되는 재귀 호출을 사용하여 구현한다. 함수에서 n이라는 정수를 받을 것이고, n은 몇 번째 피보나치 수를 구할 것인지를 의미한다. 예를 들어, n이 3이면, 피보나치 수열 중 3번째 피보나치 수를 구하는 함수를 구현하는 것이고, 그 값은 2이다. [Solution]123456789101112function fibonacci(num)&#123; var a = 1, b = 0, temp; while (num &gt;= 0)&#123; temp = a; a = a + b; b = temp; num--; &#125; return b;&#125; [Best Practice]123456789function fibonacci(num) &#123; if(num === 0) &#123; return 0; &#125; else if(num === 1) &#123; return 1; &#125; return fibonacci(num - 1) + fibonacci(num - 2);&#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://cheonmro.github.io/categories/Algorithms/"}],"tags":[{"name":"Fibonacci","slug":"Fibonacci","permalink":"https://cheonmro.github.io/tags/Fibonacci/"}]},{"title":"Pass-by-Value vs Pass-by-Reference","slug":"pass-by-value-and-pass-by-reference","date":"2018-09-14T03:28:23.000Z","updated":"2018-09-14T03:28:23.071Z","comments":true,"path":"2018/09/14/pass-by-value-and-pass-by-reference/","link":"","permalink":"https://cheonmro.github.io/2018/09/14/pass-by-value-and-pass-by-reference/","excerpt":"","text":"Pass-by-Value 기본자료형의 값은 값(Value)으로 전달한다.(원래 값은 그대로 존재하고, 그 값이 복사되어 전달된다.) 기본자료형의 값은 한번 정해지면 변경할 수 없다.(Immutable, 재할당은 가능하지만 기존의 값은 메모리에 저장되어 있다.) 기본자료형의 값은 런타임(변수 할당 시점)에 메모리의 스택 영역(Stack Segment)에 고정된 메모리 영역을 점유하고 저장된다. 123456789var a = 1;var b = a; // a의 값(1)이 복사되어 전달console.log(a, b); // 1 1console.log(a === b); // truea = 10; // 재할당은 가능하지만, 기존의 값은 메모리에 저장되어 있다.console.log(a, b); // 10 1console.log(a === b); // false Pass-by-Reference 객체형의 값은 실제 값이 아닌 값을 참조하여 전달한다.(값의 주소(address)를 참조한다.) 객체형은 변경 가능(mutable)한 값으로, 프로퍼티를 변경, 추가, 삭제가 가능하다. 객체형의 값은 동적으로 변화할 수 있어서 어느 정도의 메모리 공간이 필요한지를 알 수가 없기 때문에, 런타임(변수 할당 시점)에 메모리 공간을 확보하고, 메모리의 힙 영역(Heap Segment)에 저장된다. 123456789var obj1 = &#123; val: 100 &#125;var obj2 = obj1; // 값을 참조하여 전달console.log(obj1.val, obj2.val); // 100 100console.log(obj1 === obj2); // trueobj2.val = 200; // 객체의 값은 변경 가능console.log(obj1.val, obj2.val); // 200 200console.log(obj1 === obj2); // true 두 변수사이에 같은 내용을 할당하여도, 각 별개의 객체를 생성하여, 서로 다른 참조값을 가진다.12345678910var obj1 = &#123; val: 100 &#125;;var obj2 = &#123; val: 100 &#125;;console.log(obj1.val, obj2.val); // 100 100console.log(obj1 === obj2); // false -&gt; 서로 다른 참조값을 가지기 때문에, 두 변수는 같지 않다.var obj3 = obj2;console.log(obj3.val, obj2.val); // 100 100console.log(obj3 === obj2); // true -&gt; 서로 같은 참조값을 가지기 때문에, 두 변수는 같다. 서로 다른 빈 객체 참조 및 모두 같은 빈 객체 참조(예제)123456789101112// a, b, c는 각각 다른 빈 객체를 참조var a = &#123;&#125;;var b = &#123;&#125;;var c = &#123;&#125;;console.log(a === b, a === c, b === c); // false false false// a, b, c는 모두 같은 빈 객체를 참조a = b = c = &#123;&#125;;console.log(a === b, a === c, b === c); // true true true","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://cheonmro.github.io/categories/Javascript/"}],"tags":[{"name":"Object","slug":"Object","permalink":"https://cheonmro.github.io/tags/Object/"}]},{"title":"알고리즘 성능분석을 위한 복잡도 활용법","slug":"complexity-for-algorithms","date":"2018-09-14T02:55:28.000Z","updated":"2018-10-31T02:14:11.222Z","comments":true,"path":"2018/09/14/complexity-for-algorithms/","link":"","permalink":"https://cheonmro.github.io/2018/09/14/complexity-for-algorithms/","excerpt":"","text":"알고리즘 알고리즘이란, 어떤 목적이나 결과물(프로그램)을 만들어내기 위해 거쳐야 하는 일련의 과정들을 말한다. 어떤 프로그램을 만드는 데 있어서 방법은 여러가지가 있을 수 있다. 예를 들어, 어떤 케익 1개를 100가지 방법으로 자를 수 있는 것처럼, 하나의 문제를 여러가지의 알고리즘으로 풀 수 있다. 그렇기 때문에, 여러 알고리즘 중 최선의 알고리즘으로 하는 것이 좋다. 어떤 프로그램 개발을 위해 코딩을 할 때, 여러가지의 알고리즘으로 풀 수 있지만, 최선의 알고리즘으로 푸는 것이 (웹페이지 등의) 성능을 위해서 좋다. 이때, 이 성능 분석을 위해 필요한 것이 복잡도이다. 복잡도 복잡도에는 크게 2가지가 있다. 시간 복잡도: 알고리즘이 문제를 해결하기 위한 연산의 횟수(얼마나 많은 연산이 수행되는지) 공간 복잡도: 메모리 사용량(얼마나 많은 양의 메모리를 차지하는지) 이런 복잡도를 가지고 작성한 코드 알고리즘의 성능을 분석해서, 어떻게 하면 더 적은 연산으로(시간 복잡도), 더 적은 메모리를 차지하여(공간 복잡도) (웹페이지 등의) 성능을 좋게 할 수 있다. 알고리즘의 성능을 평가하기 위해서는 작성된 코드의 시간복잡도 및 공간복잡도를 계산하고, 이를 점근적 표기법으로 나타내어 평가한다. 이때 점근적 표기법이란, 각 알고리즘이 주어진 데이터의 크기를 기준으로 코드에서의 연산의 횟수 또는 메모리 사용량이 얼마나 되는지를 비교할 수 있는 방법이다. 이 방법에는 Big-O, 오메가, 세타 등이 있다. 이 방법중에서 Big-O 표기법에 대해 알아보자. Big-O 표기법 Big-O 표기법이란, 계산된 복잡도를 O(n) 이런식으로 표기하는 방식인데, 이때, n은 최고차항의 차수가 된다. 예를 들어, T(n) = n^2+ 2n + 1 으로 시간복잡도가 계산되었다면, O(n^2)으로 표기하는 것이 Big-O 표기법이다. 대표적인 복잡도를 Big-O 표기법으로 작성한 것은 다음과 같다. O(1): 상수 시간 입력값 n이 주어졌을 때, 알고리즘이 문제를 해결하는 데 오직 한 단계만 거친다. O(logn): 로그 시간 입력값 n이 주어졌을 때, 문제를 해결하는데 필요한 단계들이 연산마다 특정 요인에 의해 줄어든다. O(n): 직선적 시간 문제를 해결하기 위한 단계의 수와 입력값 n이 1:1 관계를 가진다. O(n^2): 2차 시간 문제를 해결하기 위한 단계의 수는 입력값 n의 제곱이다. O(c^n): 지수 시간 문제를 해결하기 위한 단계의 수는 주어진 상수값 c의 n 제곱이다. 복잡도의 크기는 다음과 같다.1O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) 보통 O(n^2) 이상의 복잡도를 가지는 알고리즘은 좋지 않다. 복잡도 계산하기 O(1): 상수 시간(constant time) 알고리즘이 문제를 해결하는 데 오직 한 단계만 거친다. O(1)은 여러가지 경우가 있겠지만, 예를 들면 다음과 같은 코드들이 있다. 1. 전달되는 인자를 반환하는 경우12345function addTwoNumbers(num1, num2) &#123; return num1 + num2; // 1번 실행&#125;console.log(addTwoNumbers(1, 3)); // 4 시간복잡도를 T(n)이라고 하는데, 위 코드의 시간복잡도를 계산하면 T(n) = 1 이다. 이것을 Big-O 표기법으로 나타내면 O(1)이다. 1인 이유는 Big-O 표기법에서 O(n)의 n은 최고차항의 차수를 나타내는데, 위의 경우 n^0이므로, 1이된다. 2. 정렬되어 있는 배열에서 최소값과 최대값을 구하는 경우12345678const numbers = [1, 2, 3, 4, 5, 10]; // 배열의 요소들이 순서대로 정렬되어 있다.function FindLargestNumber(items) &#123; let smallest = items[0]; // 1번 실행 let largest = items[items.length - 1]; // 1번 실행 return (largest - smallest); // 1번 실행&#125;console.log(FindLargestNumber(numbers)); // 9 위 코드의 시간복잡도를 계산하면 T(n) = 3 이다. 이것을 Big-O 표기법으로 나타내면 O(1)이다. 3. 값을 검색할 때, 객체에서 키를 알거나, 배열에서 인덱스를 알고 있으면 언제나 한 단계만 걸린다.1234567891011function isCryptoCurrency(name) &#123; return cryptoCurrency[name]; // 1번 실행&#125;var cryptoCurrency = &#123; &apos;bitcoin&apos;: true, &apos;ripple&apos;: true, &apos;bitcoinCash&apos;: true&#125;console.log(isCryptoCurrency(&apos;bitcoin&apos;)); // true 위 코드의 시간복잡도를 계산하면 T(n) = 1 이다. 이것을 Big-O 표기법으로 나타내면 O(1)이다. O(logN): 로그 시간(log time) 문제를 해결하는데 필요한 단계들이 연산마다 특정 요인에 의해 줄어든다. 배열에서 값을 찾을 때, 어느 쪽에서 시작할지를 알고 있으면, 검색하는 시간이 줄어든다. 대표적인 것이 이진 검색 알고리즘이다.(binary search)12345678910111213141516171819202122function findAge(num, array) &#123; var midPoint = Math.floor(array.length/2); if(array[midPoint] === num) &#123; return true; // 1번 실행 &#125; if(array[midPoint] &lt; num) &#123; for (let i = midPoint + 1; i &lt; array.length) &#123; if(array[i] === num) &#123; return true; &#125; &#125; n/2번 실행 &#125; else &#123; for (let i = 0; i &lt; midPoint) &#123; if(array[i] === num) &#123; return true; &#125; &#125; n/2번 실행 &#125;&#125;console.log(findAge(27, sortedAges))sortedAges = [21, 23, 25, 27, 29]; 위 코드의 시간복잡도를 계산하면 T(n) = 1 + n/2 이다. 이것을 Big-O 표기법으로 나타내면 O(logn)이다. O(n): 직선적 시간(linear time) 문제를 해결하기 위한 단계의 수와 입력값 n이 1:1 관계를 가진다. for문을 1번 사용하는 경우 예를 들어, 배열이 정렬되어 있지 않을 경우, 최소 및 최대값을 찾기 위해 배열의 모든 숫자를 탐색하여, 비교를 수행한다. 이 경우, 수행시간은 배열의 크기에 따라 늘어난다.123456789101112131415const numbers = [1, 9, 3, 10, 16];function FindLargestGap(items) &#123; let smallest = items[0]; // 1번 실행 let largest = items[0]; // 1번 실행 for (let i = 1; i &lt; items.length; i++) &#123; if (items[i] &lt; smallest) &#123; smallest = items[i]; &#125; else if (items[i] &gt; largest) &#123; largest = items[i]; &#125; &#125; // n번 실행 return (largest - smallest); // 1번 실행&#125;console.log(FindLargestGap(numbers)); 위 코드의 시간복잡도를 계산하면 T(n) = 3 + n 이다. 이것을 Big-O 표기법으로 나타내면 O(n)이다. O(n^2): 2차 시간(quadratic time) 문제를 해결하기 위한 단계의 수는 입력값 n의 제곱이다. 중첩 for 문을 사용할 경우, 첫번째 for 문의 각 요소(n) x 두번째(안에있는) for 문의 각 요소(n) = n x n12345678910111213141516171819const number = [2, 10, 1, 4, 3, 10, 5];function FindLargestGap(items) &#123; let gap; // 1번 실행 let maxGap = 0; // 1번 실행 for (let i = 0; i &lt; items.length; i++) &#123; for(let j = 0; j &lt; items.length; j++) &#123; gap = items[i] - items[j]; if (gap &lt; 0) &#123; gap = gap * -1; &#125; if (gap &gt; maxGap) &#123; maxGap = gap; &#125; &#125; &#125; // n^2번 실행 return maxGap; // 1번 실행&#125;console.log(FindLargestGap(numbers)); // 9 위 코드의 시간복잡도를 계산하면 T(n) = 3 + n^2 이다. 이것을 Big-O 표기법으로 나타내면 O(n^2)이다. O(c^n): 지수 시간(exponential time) 문제를 해결하기 위한 단계의 수는 주어진 상수값 c의 n 제곱이다. 지수 시간은 문제를 풀기 위해, 모든 조합과 방법을 시도할 때 사용된다. 예를 들어, 2^n이 걸리는 피보나치 수열이 있다.123456789function fibonacci(num) &#123; if(num === 0) &#123; return 0; &#125; else if(num === 1) &#123; return 1; &#125; return fibonacci(num - 1) + fibonacci(num - 2);&#125; 위 코드는 함수가 호출될 때마다, 앞의 두 수에 대한 함수를 호출하기 때문에, 두번씩 호출하게 된다.(구조는 트리로 되어 있다.) 위 코드의 시간복잡도를 계산하면 T(n) = 2^n 이다. 이것을 Big-O 표기법으로 나타내면 O(2^n)이다. Worst Case, Best Case, and Average Case 시간 복잡도 계산을 위한 연산 횟수를 카운팅할때, 3가지의 시나리오가 있다. Worst Case: 입력값 n의 규모가 동일할 때, 가장 많은 횟수의 연산으로 처리되는 경우 Best Case: 입력값 n의 규모가 동일할 때, 가장 적은 횟수의 연산으로 처리되는 경우 Average Case: 입력값 n의 규모가 동일할 때, 평균적인 횟수의 연산으로 처리되는 경우 예를 들면 다음과 같은 코드가 있다.12345678910111213function getNumber7(items) &#123; for (let i = 0; i &lt; items.length; i++) &#123; if (i === 7) &#123; return i &#125; &#125;&#125;getNumber7(numbers)// numbers = [7, 5, 3, 1]인 경우, 1번만 실행(Best Case)// numbers = [5, 7, 3, 1]인 경우, 2번만 실행// numbers = [1, 3, 5, 7]인 경우, 4번 모두 실행(Worst Case)","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"https://cheonmro.github.io/categories/Computer-Science/"}],"tags":[{"name":"Complexity","slug":"Complexity","permalink":"https://cheonmro.github.io/tags/Complexity/"},{"name":"Big-O","slug":"Big-O","permalink":"https://cheonmro.github.io/tags/Big-O/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://cheonmro.github.io/tags/Algorithms/"}]},{"title":"Hoisting(호이스팅)이란 무엇인가?","slug":"what-is-hoisting","date":"2018-09-13T06:03:47.000Z","updated":"2018-09-13T06:03:47.142Z","comments":true,"path":"2018/09/13/what-is-hoisting/","link":"","permalink":"https://cheonmro.github.io/2018/09/13/what-is-hoisting/","excerpt":"","text":"Hoisting(호이스팅) Hoisting(호이스팅)이란, Javascript의 모든 선언문(var, let, const, function, function*, class)이 해당 Scope의 최상단으로 옮겨진 것처럼 행동하는 것을 말한다. C 언어 등 C-family 언어와는 다르게, Javascript의 모든 선언문은 ‘호이스팅’이 되는 Javascript만의 특징이 있다.Hoisting에는 크게 2가지가 있다. 변수 호이스팅 함수 호이스팅 변수 호이스팅(Variable Hoisting) 변수 호이스팅이란, Javascript의 변수 선언문(var, let, const)이 해당 Scope의 최상단으로 옮겨진 것처럼 행동하는 것을 말한다. 즉, Javascript의 모든 선언문이 선언되기 전부터, 변수를 참조할 수 있게 된다.1234567console.log(num); // 1. -&gt; undefinedvar num = 100;console.log(num); // 2. -&gt; 100&#123; var num = 5;&#125;console.log(num); // 3. -&gt; 5 위 코드를 처음 봤을 때, 첫줄의 출력 값은 Error가 날 것이라고 예상 할 수 있다. 그러나, 위 Javascript의 코드는 변수 호이스팅이 있기 때문에, undefined를 출력한다. Javascript 엔진이 위 코드를 읽어들일 때, 제일 먼저 선언문부터 읽는다. 그리고, 그 중 제일 첫번째로 선언된 변수를 찾아, 그 변수를 선언하고, 초기화를 한다. 이때, 변수의 호이스팅 때문에, 선언문은 해당 Scope의 최상단, 즉 제일 윗줄로 옮겨진 것처럼 행동하여, ‘num’을 출력(console.log(num)) 하기 전에, 변수가 존재하는 것처럼 행동하고, 이 변수는 선언이 되고, 초기화까지 되었기 때문에(변수를 초기화하면, ‘undefined’를 메모리에 할당한다.), console.log(num)의 결과로는 ‘undefined’가 출력된다. 기본적으로, var 키워드로 선언된 변수는 선언 단계와 초기화 단계가 한번에 이루어진다. 변수가 선언이 될 때, 스코프에 Variable Object가 생성이 되고, 여기에 변수가 등록이 되어있어, 변수 선언문 이전에 변수에 접근해도 에러가 발생하지 않는다. 다만, 초기화 단계에서 변수는 메모리에 공간을 확보한 후, undefined를 저장하기 때문에, undefined를 반환한다. 이후, 변수 할당문(var num = 100;)에 도달하여 값의 할당이 이루어진다. 호이스팅 관점에서 다시 코드를 보자.1234567console.log(num); // 1. -&gt; undefinedvar num = 100;console.log(num); // 2. -&gt; 100&#123; var num = 5;&#125;console.log(num); // 3. -&gt; 5 ‘1.’이 실행되기 이전에 var num = 100;이 호이스팅되어 ‘1.’ 구문 위에(최상단) var num;가 옮겨진 것처럼 된다. 실제로 변수 선언이 코드 레벨로 옮겨 진것은 아니고, 변수 객체(Variable Object)에 등록되고, undefined로 초기화된 것이다. 그러나, 변수 선언 단계와 초기화 단계가 할당 단계와 분리되어 진행되기 때문에, 이 단계에서는 num에 undefined가 할당되어 있다. 변수 num에 값이 할당되는 것은 두번째 행(var num = 100;)에서 실시된다. 마지막 줄에서는 숫자 5가 출력이 되는데, 이는 코드 블록안에서 새롭게 변수가 중복 선언이 되어 num의 값이 5로 바뀌었기 때문이다. Javascript는 function-level scope를 갖기 때문에, 변수의 유효범위가 코드 블록에는 영향이 없다. 함수 호이스팅(Function Hoisting) 함수 호이스팅이란, Javascript의 함수 선언문(function)이 해당 Scope의 최상단으로 옮겨진 것처럼 행동하는 것을 말한다. 즉, Javascript의 모든 선언문이 선언되기 전부터, 함수를 호출할 수 있게 된다. 함수선언의 위치와는 상관없이 코드 내 어느 곳에서든지 호출이 가능하게 만드는 것을 말한다. 단, 함수선언식에만 적용이 된다. 함수선언식으로 정의된 함수는 자바스크립트 엔진이 스크립트가 로딩되는 시점에 바로 초기화하고 이를 VO(variable object)에 저장한다. 즉, 함수 선언, 초기화, 할당이 한번에 이루어진다. 그렇기 때문에 함수 선언의 위치와는 상관없이 소스 내 어느 곳에서든지 호출이 가능하다.12345square(5); // 25function square(number) &#123; return number * number;&#125; 다음은 함수표현식으로 함수를 정의한 경우이다.12345var res = square(5); // TypeError: square is not a functionvar square = function(number) &#123; return number * number;&#125; 위와 같이 에러가 발생한 이유는, 함수표현식의 경우는 함수 호이스팅이 아니라, 변수 호이스팅이 발생하기 때문이다. 함수표현식은 함수선언식과는 달리 스크립트 로딩 시점에 변수 객체(VO)에 함수를 할당하지 않고, runtime에 해석되고 실행된다. 즉, 선언과 초기화까지만 하여, undefined를 호출하는 것과 같기 때문에, 에러가 난다. 그래서, 더글러스 크락포드는 ‘함수표현식’만 사용할 것을 권한다. 왜냐하면, 에러가 나서 미리 호출을 방지하기 때문이다. 왠만하면, 선언문 이전에 호출하지 않는 것이 좋다.변수와 함수의 호이스팅의 차이점: 함수 호이스팅: 함수선언문 이전에 함수가 호출이 된다.(함수 선언식으로 함수를 선언했을 경우) 변수 호이스팅: 함수표현식으로 함수를 선언했을 경우, 함수표현식 이전에 함수를 호출하면, 에러가 난다. 왜냐하면, 함수표현식은 변수 호이스팅을 따르기 때문에, 할당은 안되고, 초기화까지만 되기 때문이다. 즉, 초기화까지만 되면 undefined를 호출하는 것과 같기 때문이다. undefiend() 이런형식으로 나온다는 의미이기 때문에, 에러가 난다.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://cheonmro.github.io/categories/Javascript/"}],"tags":[{"name":"Hoisting","slug":"Hoisting","permalink":"https://cheonmro.github.io/tags/Hoisting/"}]},{"title":"DOM(Document Object Model)이란 무엇인가?","slug":"what-is-dom","date":"2018-09-13T03:01:26.000Z","updated":"2018-09-13T03:01:26.985Z","comments":true,"path":"2018/09/13/what-is-dom/","link":"","permalink":"https://cheonmro.github.io/2018/09/13/what-is-dom/","excerpt":"","text":"DOM(Document Object Model) DOM이란, 브라우저가 서버에게 요청하여, 응답으로 받은 웹 문서(HTML, XML, SVG 등)를 브라우저의 렌더링 엔진이 로드하고, 파싱하여 브라우저가 이해할 수 있는 형태로 구성된 것을 말한다. 이 DOM은 자바스크립트를 이용해 동적으로 변경이 가능하고, 이 변경된 DOM은 렌더링에 반영된다. 이때, 자바스크립트로 이 DOM에 접근하고 수정할 수 있는 DOM API가 있으며, 이 DOM API가 가지고 있는 프로퍼티와 메소드로 정적인 웹페이지에 접근하여 동적으로 변경할 수 있다. DOM은 W3C의 공식 표준이고, HTML, JavaScript에서 정의한 표준이 아니다. DOM의 기능 HTML 문서에 대한 모델 구성 브라우저가 이해할 수 있는 형태로 HTML 문서를 모델로 구성하여 메모리에 생성하는데, 이때 모델은 객체의 트리로 구성된다. HTML 문서 내의 각 요소에 접근 및 수정 객체의 트리로 구성되어있는 모델 내의 각 객체에 접근 및 수정할 수 있는 프로퍼티와 메소드를 제공한다. 이때, DOM이 수정되면, 브라우저를 통해 사용자가 보게 될 내용 또한 변경된다. DOM 구조 DOM 구조는 브라우저가 이해할 수 있는 형태로 HTML 문서를 모델로 구성하여 메모리에 생성하는데, 이때 모델은 객체의 트리로 구성되었다고 하여, DOM tree라고 부른다. DOM tree는 HTML 문서의 모든 요소와 요소의 attribute, text 등을 각각의 객체로 만들고, 이들 객체간에 관계를 부자 관계로 표현하는 tree(나무 가지)처럼 구성되어있다. 출처: DOM 구조 위 구조를 코드로 작성하면 다음과 같다.12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;h1&gt;Cryptocurrency&lt;/h1&gt; &lt;ul&gt; &lt;li id=&quot;one&quot;&gt;Bitcoin&lt;/li&gt; &lt;li id=&quot;two&quot;&gt;Bitcoin Cash&lt;/li&gt; &lt;li id=&quot;three&quot;&gt;Ripple&lt;/li&gt; &lt;li id=&quot;four&quot;&gt;Ethereum&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; DOM tree 노드의 종류DOM tree는 4 종류의 노드로 구성된다. 문서 노드(Document Node) 요소 노드(Element Node) 어트리뷰트 노드(Attribute Node) 텍스트 노드(Text Node) 문서 노드(Document Node) Document Node란, DOM tree에 접근하기 위한 시작점(entry point)이다.DOM tree의 최상위에 존재하고, DOM tree에 있는 요소, 어트리뷰트, 또는 텍스트 노드 등에 접근하기 위해서는 Document Node를 통해 접근해야 한다. Document Node의 프로퍼티 및 메소드는 MDN에서 확인할 수 있다. 요소 노드(Element Node) Element Node란, html, body, div 등 HTML 요소를 말한다. Element Node는 서로 부자 관계를 가지며, 이 부자 관계를 통해 정보를 구조화한다. Attribute Node 또는 Text Node에 접근하기 위해서는 먼저 Element Node에 접근해야 한다. 모든 Element Node는 요소별 특성을 표현하기 위해 HTMLElement 객체를 상속한 객체로 구성된다. Element Node의 프로퍼티 및 메소드는 MDN에서 확인할 수 있다. 어트리뷰트 노드(Attribute Node) Attribute Node란, HTML 요소의 어트리뷰트로, HTML 요소의 자식이 아닌 일부이다. Attribute Node의 프로퍼티 및 메소드는 MDN에서 확인할 수 있다. 텍스트 노드(Text Node) Text Node란, 텍스트로 표현된 Element Node의 자식 요소이다. DOM tree의 최하단에 있는 Node로, Text Node는 자식 노드를 가질 수 없다. Text Node의 프로퍼티 및 메소드는 MDN에서 확인할 수 있다. DOM tree의 객체 구성 출처: DOM tree의 객체 구성 DOM tree의 객체는 위 그림과 같이 구성되어 있다. 또한, 모든 Element Node는 HTMLElement 객체를 상속한 객체로 구성되어 있다.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://cheonmro.github.io/categories/Javascript/"}],"tags":[{"name":"DOM","slug":"DOM","permalink":"https://cheonmro.github.io/tags/DOM/"}]},{"title":"==와 ===의 차이점","slug":"strict-equal-operator-difference","date":"2018-09-12T03:33:31.000Z","updated":"2018-09-12T03:33:31.421Z","comments":true,"path":"2018/09/12/strict-equal-operator-difference/","link":"","permalink":"https://cheonmro.github.io/2018/09/12/strict-equal-operator-difference/","excerpt":"","text":"[ ==와 ===의 차이점 ] ==는 Equal Operator이고, ===는 Strict Equal Operator이다. ==는 a == b 라고 할때, a와 b의 값이 같은지를 비교해서, 같으면 true, 다르면 false라고 한다.(값만 같으면 true이다.) ===는 Strict, 즉 엄격한 Equal Operator로써, “엄격하게” 같음을 비교할 때 사용하는 연산자이다. ===는 a === b 라고 할때, 값과 값의 종류(Data Type)가 모두 같은지를 비교해서, 같으면 true, 다르면 false라고 한다. [기본자료형(Primitive)] 값은 똑같이 1이지만 값의 종류가 숫자냐, 문자열이냐에 따라 === 연산자를 사용할 때 결과가 false라고 나온다.1234var a = 1;var b = &quot;1&quot;;console.log(a == b); // trueconsole.log(a === b); // false null과 undefined는 공통적으로 값이 없음을 뜻하지만, 값의 종류(Data Type)가 다르기 때문에, === 연산자를 사용할 때 결과가 false라고 나온다.12console.log(null == undefined); // trueconsole.log(null === undefined); // false 기본적으로 1은 true, 0은 false로 나타낼 수 있지만, 데이터 타입은 다르다.12console.log(true == 1); // trueconsole.log(true === 1); // false 숫자 0과 문자열 “0”, “”1234console.log(0 == &quot;0&quot;); // trueconsole.log(0 === &quot;0&quot;); // falseconsole.log(0 == &quot;&quot;); // trueconsole.log(0 === &quot;&quot;); // false NaN은 Not a Number라는 뜻으로, 숫자가 아닌 것을 의미하지만 그 값 자체끼리는 같지 않다.12console.log(NaN == NaN); // falseconsole.log(NaN === NaN); // false 배열, 또는 객체 등의 경우는 어떨까? [객체형(Object type)] 배열을 할당할때, 각 변수는 각 메모리의 주소를 참조한다. 두 변수 a, b의 값과 데이터 타입이 같지만, 이와 상관없이 참조하는 메모리의 주소가 다르기 때문에 두 a, b는 같지 않다.1234var a = [1,2,3];var b = [1,2,3];console.log(a == b); // falseconsole.log(a === b); // false 새로운 변수 c에 변수 b를 할당해주면, 변수 c도 b가 참조하는 같은 메모리의 주소를 참조하게 되어, 두 변수 c, b는 같다. 이때, c, b의 값과 데이터 타입이 같기 때문에, ==와 ===의 결과값이 동일하다.12345var a = [1,2,3];var b = [1,2,3];var c = b;console.log(b === c); // trueconsole.log(b == c); // ture 객체도 마찬가지다.1234567var x = &#123;&#125;;var y = &#123;&#125;;var z = y;console.log(x == y) // falseconsole.log(x === y) // falseconsole.log(y === z) // trueconsole.log(y == z) // true","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://cheonmro.github.io/categories/Javascript/"}],"tags":[{"name":"Equal Operator","slug":"Equal-Operator","permalink":"https://cheonmro.github.io/tags/Equal-Operator/"}]},{"title":"올바른 코딩을 위한 문제해결 프로세스","slug":"problem-solving-process","date":"2018-09-12T02:42:49.000Z","updated":"2018-09-12T02:42:49.651Z","comments":true,"path":"2018/09/12/problem-solving-process/","link":"","permalink":"https://cheonmro.github.io/2018/09/12/problem-solving-process/","excerpt":"","text":"Process of Problem Solving Computational Thinking Flow Chart Pseudo Code Algorithm(Write Code) 1. Computational Thinking What? 정답이 정해지지 않은 문제에 대한 해답을 다양한 시나리오별로 경우의 수를 따져서, 하나하나씩 논리적으로 답을 찾아가는 과정 How? 문제인지: 문제가 무엇인가? 문제분해 -&gt; 문제 조직화: 문제를 다양한 시나리오별로 구조화하는 것: 문제를 해결하기 위해서 어떻게 해야겠다. 시나리오 1(첫번째 경우의 수) 시나리오 1-1 시나리오 1-2 시나리오 2(두번째 경우의 수) 시나리오 2-1 시나리오 2-2 패턴인지: 이 문제를 해결하기 위해서는 어떻게(시나리오) 해결하면 되겠구나. 일반화/추상화: 어떤 문제를 해결하기 위해서는 {변수}를 어떻게(어디/무엇 등) 해결한다. Example123456789101112131415문제: array의 모든 element의 합을 구해라.1. 문제인지: array의 모든 element의 합을 구해야한다.2. 문제분해: array의 각 element에 접근해서 총합을 구한다. 1. 총합 sum = 0을 선언한다. 2. array의 element가 없다면? 1. sum을 리턴한다. 3. array의 element가 존재한다면? 1. 반복문을 이용해서 sum에 첫 element(i = 0)부터 마지막 element(array.length-1)까지 모두 더한다. 2. sum을 리턴한다.3. 패턴인지: array의 모든 element의 합을 구하려면, 반복문을 이용하면 구할 수 있다.4. 일반화/추상화: array의 모든 element의 합은 반복문을 통해 &#123;&#123;i번째 element&#125;&#125;에 접근하여 그 값을 &#123;&#123;sum&#125;&#125;에 쌓음으로써 구현한다. 2. Flow Chart What? Computational Thinking을 통해 작성한 시나리오를 하나의 흐름으로 이해하기 위해 작성하는 순서도 How? 문제가 생기는 점(Start)에서 문제가 해결되는 점(End)까지 각 경우의 수에 따라 Yes/No를 기본으로 순서도를 작성. Example 3. Pseudo Code What? 프로그램이 수행할 내용을 인간이 이해할 수 있는 언어로 작성하는 것. 의사코드를 작성하면 좋은점? 프로그램을 설계할 때, 밑그림(스케치)의 역할을 하여, 실제 코딩하기 전 사고를 좀 더 명확하게 정립을 할 수 있다. 의사코드로 소스코드 실행없이 상세 설계를 검토할 수 있어, Code Review가 더 쉬워진다. 코드 수정을 좀 더 용이하게 만든다. 일부 의사코드 몇 줄을 수정하는 것은 한 페이지 전체의 코드를 수정하는 것 보다 쉽다. 코드입력, 테스트, 디버그 등의 수정 단계에서 작업하는 것 보다 의사코드 설계 단계에서 미리 오류를 수정하는 것이 훨씬 경제적이다. 의사코드는 소스코드의 코멘트(주석)가 되기 때문에, 나중에 따로 코멘트를 작성하지 않아도 된다. 의사코드를 효과적으로 작성하는 방법 프로그래밍 문법에 맞게 작성한다. 조건문(if-else), 반복문(while, for) 등을 사용한다. 변수(n)를 사용한다. 간결하게 쓰되, 구체적으로 작성한다. 의사코드에서 많이 사용되는 영어 단어를 사용한다. 의사코드에서 많이 쓰이는 영어 단어 입력: GET, READ, OBTAIN 출력: PRINT, DISPLAY, SHOW 초기화: SET, INIT 계산: COMPUTE, CALCULATE, DETERMINE 반복: WHILE, FOR 조건문: IF-THEN-ELSE, CASE 마지막에 조건문이 있는 반복문: REPEAT-UNTIL 요소를 추가: INCREMENT, BUMP 부울: TRUE/FALSE 선형적으로 증가할 때: SEQUENCE 그외: REPEAT - UNTIL RETURN BEGIN / EXCEPTION / END Example 1234567891. Get an array of integers from user ==&gt; arr, i =02. Set sum of all elements of an array ==&gt; sum = 03. If size of array == 0, then return 04. WHILE i is less than size of array, 1. Add element(arr[i]) to sum 2. if i == size of array, then return sum 4. Algorithm What? 목표를 달성하거나 결과물을 생산하기 위해 필요한 과정들 How? 미리 작성한 의사코드를 바탕으로 Write Code! Example123456789101112131415function simpleArraySum(ar) &#123; var sum = 0; if(ar.length === 0) &#123; return 0; &#125; for(var i =0; i &lt; ar.length; i++) &#123; sum += ar[i]; &#125; return sum;&#125;","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"https://cheonmro.github.io/categories/Computer-Science/"}],"tags":[{"name":"Problem Solving","slug":"Problem-Solving","permalink":"https://cheonmro.github.io/tags/Problem-Solving/"}]},{"title":"2. Queue Using Two Stacks","slug":"queue-stack","date":"2018-09-12T01:39:44.000Z","updated":"2018-09-12T01:42:26.168Z","comments":true,"path":"2018/09/12/queue-stack/","link":"","permalink":"https://cheonmro.github.io/2018/09/12/queue-stack/","excerpt":"","text":"[Problem]Create a queue using two stacks. [Algorithms] Create a stack. Create a queue with two instances of Stack( ). For dequeue of Queue, Move elements from stack1(inbox) to stack2(outbox), and return the highest element in outbox. [Solution]12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// STACKfunction Stack() &#123; var items = []; this.push = function() &#123; items.push.apply(items, arguments); &#125;; this.pop = function() &#123; return items.pop.apply(items, arguments); &#125;; this.size = function() &#123; return items.length; &#125;; this.peek = function() &#123; return items; &#125;; this.isEmpty = function() &#123; return items.length === 0;&#125;;&#125;// STACK TESTSvar stack = new Stack();stack.push(1, 2, 3, 4, 5);console.log(stack.peek()); // [ 1, 2, 3, 4, 5 ]stack.pop();console.log(stack.peek()); // [ 1, 2, 3, 4 ]// QUEUEfunction Queue() &#123; var inbox = new Stack(); var outbox = new Stack(); this.eneque = function() &#123; inbox.push.apply(inbox, arguments); &#125;; this.dequeue = function() &#123; if (outbox.size() === 0) &#123; while (inbox.size()) outbox.push(inbox.pop()); &#125; return outbox.pop(); &#125;; this.size = function()&#123; return inbox.size() + outbox.size(); &#125;; this.peek = function() &#123; return outbox.peek(); &#125;; this.isEmpty = function() &#123; return inbox.length + outbox.length === 0; &#125;; this.front = function() &#123; if (outbox.size() === 0) &#123; while (inbox.size()) outbox.push(inbox.pop()); &#125; return outbox.peek()[0]; &#125;;&#125;// QUEUE TESTSvar queue = new Queue();console.log(queue.size()); // 0queue.eneque(10, 20, 30, 40, 50, 60);console.log(queue.size()); // 6console.log(queue.peek()); // [] Not move to outbox yetconsole.log(queue.dequeue()); // 10console.log(queue.dequeue()); // 20console.log(queue.peek()); // [ 60, 50, 40, 30 ]console.log(queue.front()); // 60console.log(queue.size()); // 4console.log(queue.dequeue()); // 30console.log(queue.dequeue()); // 40console.log(queue.peek()); // [ 60, 50 ] [What I learned]Use the value of array.pop() as parameter of other array.push()1234567this.dequeue = function() &#123; if (outbox.size() === 0) &#123; while (inbox.size()) outbox.push(inbox.pop()); &#125; return outbox.pop();&#125;;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://cheonmro.github.io/categories/Algorithms/"}],"tags":[{"name":"Queue","slug":"Queue","permalink":"https://cheonmro.github.io/tags/Queue/"},{"name":"Stack","slug":"Stack","permalink":"https://cheonmro.github.io/tags/Stack/"}]},{"title":"1. Fizzbuzz","slug":"fizzbuzz","date":"2018-09-11T10:29:27.000Z","updated":"2018-09-11T10:29:27.637Z","comments":true,"path":"2018/09/11/fizzbuzz/","link":"","permalink":"https://cheonmro.github.io/2018/09/11/fizzbuzz/","excerpt":"","text":"[Problem]Write a function that takes an integer and returns an array [A, B, C], where A is the number of multiples of 3 (but not 5) below the given integer, B is the number of multiples of 5 (but not 3) below the given integer and C is the number of multiples of 3 and 5 below the given integer. For example, solution(20) should return [5, 2, 1]123function solution(number)&#123;&#125; [Algorithms] Declare variables for the number of multiples below the given integer(3, 5, 15) Add counts for the number of multiples below the given integer using ‘for’ statement get an array of the variables [Solution]12345678910111213141516function solution(number)&#123; var num3 = 0; var num5 = 0; var num15 = 0; for(var i = 1; i &lt; number; i++) &#123; if((i % 3 === 0) &amp;&amp; (i % 5 !== 0)) &#123; num3 += 1; &#125; else if((i % 5 === 0) &amp;&amp; (i % 3 !== 0)) &#123; num5 += 1; &#125; else if(i % 15 === 0) &#123; num15 += 1; &#125; &#125; var result = [num3, num5, num15]; return result;&#125; [Best Practice]1234567function solution(n) &#123; --n; const c15 = Math.floor(n / 15); const c3 = Math.floor(n / 3) - c15; const c5 = Math.floor(n / 5) - c15; return [c3, c5, c15];&#125; [What I learned] Math.floor [Source]CodeWars - Fizz/Buzz","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://cheonmro.github.io/categories/Algorithms/"}],"tags":[{"name":"Fizzbuzz","slug":"Fizzbuzz","permalink":"https://cheonmro.github.io/tags/Fizzbuzz/"}]},{"title":"Event Object(이벤트 객체)","slug":"event-object","date":"2018-09-03T23:57:18.000Z","updated":"2018-09-03T23:57:18.837Z","comments":true,"path":"2018/09/04/event-object/","link":"","permalink":"https://cheonmro.github.io/2018/09/04/event-object/","excerpt":"","text":"Event Object(이벤트 객체)란 무엇인가? 이벤트 객체란, 이벤트를 발생시킨 요소와 발생한 이벤트에 대한 정보를 제공하는 것을 말한다. 이벤트가 발생하면, 이벤트 객체는 동적으로 생성되어, 이벤트 핸들러에 인자로 암묵적으로 전달된다. 1234567891011121314// HTML&lt;div class=&quot;parent&quot;&gt; &lt;button id=&quot;btn1&quot;&gt;button 1&lt;/button&gt; &lt;button id=&quot;btn2&quot;&gt;button 2&lt;/button&gt;&lt;/div&gt;// Javascript function getColor(e) &#123; e.target.style.color = &apos;red&apos;;&#125;var parent = document.querySelector(&apos;.parent&apos;);parent.addEventListener(&apos;click&apos;, getColor); 위 코드에서 ‘e’가 이벤트 객체인데, 위 코드처럼 이벤트 핸들러를 선언할 때, 이벤트 객체를 전달받을 첫번째 매개변수를 명시적으로 선언해야 한다. 그 이름은 위와 같이 ‘e’가 되든, ‘event’가 되든 상관이 없다. 이벤트도 객체이기 때문에, 프로퍼티와 메소드를 가진다. Event Property Event.target &amp;&amp; Event.currentTarget Event.target: 실제로 이벤트를 발생시킨 요소 Event.currentTarget: 이벤트에 바인딩된 DOM 요소(addEventListener 메소드 앞에 기술된 객체) 버튼 2개를 자식요소로 가지고 있는 parent 요소가 있다고 해보자.1234567891011121314151617// HTML&lt;div class=&quot;parent&quot;&gt; &lt;button id=&quot;btn1&quot;&gt;button 1&lt;/button&gt; &lt;button id=&quot;btn2&quot;&gt;button 2&lt;/button&gt;&lt;/div&gt;// Javascriptfunction getEventTarget(e) &#123; console.log(e.target); // &lt;button id=&quot;btn1&quot;&gt;button 1&lt;/button&gt; console.log(e.currentTarget); // &lt;div class=&quot;parent&quot;&gt;...&lt;div&gt; console.log(this); // &lt;div class=&quot;parent&quot;&gt;...&lt;div&gt; console.log(e.currentTarget === this); // true&#125;var parent = document.querySelector(&apos;.parent&apos;);parent.addEventListener(&apos;click&apos;, getEventTarget); 만약 첫번째 버튼(button 1)을 클릭하게 되면 결과는 위와 같이 나온다. e.target은 실제로 이벤트를 발생시킨 요소로, 첫번째 버튼(button 1)이 된다. 그러나, e.currentTarget은 이벤트에 바인딩된 DOM 요소(addEventListener 메소드 앞에 기술된 객체)로, 이벤트가 발생된 곳은 첫번째 버튼이지만, 이벤트에 바인딩된 DOM 요소는 parent(부모요소)이기 때문에, e.currentTarget은 parent 요소가 된다. 또한, addEventListener 함수에서 지정한 이벤트 핸들러 내부의 this는 Event Listener에 바인딩된 요소(parent)를 가리킨다. 이것은 이벤트 객체의 currentTarget 프로퍼티와 같다. Event.type &amp;&amp; Event.keyCode Event.type: 발생한 이벤트의 종류 Event.keyCode: 발생한 이벤트의 키보드 번호 123456789101112131415// HTML&lt;div class=&quot;parent&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;val&quot;&gt; &lt;button id=&quot;btn&quot;&gt;button&lt;/button&gt;&lt;/div&gt;// Javascriptfunction getEventType(e) &#123; console.log(e.type); // keyup console.log(e.keyCode); // 13&#125;var inputBox = document.querySelector(&apos;.val&apos;);inputBox.addEventListener(&apos;keyup&apos;, getEventType); 어떤 알파벳 하나를 입력하고, 키보드에서 ‘enter’를 입력하게 되면 e.type은 ‘keyup’이 되고, e.keyCode는 13이 된다. 즉, 발생한 이벤트의 타입은 ‘keyup’이고, 발생한 이벤트의 키보드 번호(enter의 키보드 번호)는 13이다. Event.preventDefault() &amp;&amp; Event.stopPropagation() Event.preventDefault(): 이벤트의 기본 동작을 중단 Event.stopPropagation(): 이벤트의 전파(버블링/캡처링)를 중단 Event.preventDefault() 12345678910111213// HTML &lt;a href=&quot;https://cheonmro.github.io/&quot;&gt;블로그로 이동&lt;/a&gt;// Javascriptvar elem = document.querySelector(&apos;a&apos;); elem.addEventListener(&apos;click&apos;, function (e) &#123; console.log(e.cancelable); // true // 이벤트의 기본 동작을 중단 e.preventDefault();&#125;); 원래는 ‘a’태그를 클릭하면 블로그로 이동을 해야하지만, 위와 같이 e.preventDefault()를 사용하게 되면, 이벤트의 기본 동작을 중단할 수 있다. 단, Event.cancelable가 true일 경우만 가능하다. Event.cancelable는 이벤트 객체의 프로퍼티로, 요소의 기본 동작을 중단할 수 있는지에 대한 여부(true/false)를 나타낸다. Event.stopPropagation() 어느 한 요소를 이용하여 이벤트를 처리한 후, 이벤트가 부모 요소로 이벤트가 전파되는 것을 중단하기 위해 사용되는 메소드이다. 1234567891011121314151617181920212223// HTML&lt;div id=&quot;divBox&quot;&gt; &lt;p id=&quot;paraBox&quot;&gt;블로그 &lt;a id=&quot;linkBox&quot; href=&quot;https://cheonmro.github.io/&quot;&gt;클릭&lt;/a&gt; &lt;/p&gt;&lt;/div&gt;// Javascriptdocument.getElementById(&quot;divBox&quot;).addEventListener(&quot;click&quot;, clickDiv);document.getElementById(&quot;paraBox&quot;).addEventListener(&quot;click&quot;, clickPara);document.getElementById(&quot;linkBox&quot;).addEventListener(&quot;click&quot;, clickLink);function clickDiv(event) &#123; console.log(&apos;Event for div&apos;);&#125;function clickPara(event) &#123; console.log(&apos;Event for p&apos;);&#125;function clickLink(event) &#123; event.stopPropagation(); // 이벤트의 전파를 중단함. console.log(&apos;Stop Propagation!&apos;)&#125; 위 코드에서 paraBox 요소를 클릭하게 되면, 부모요소로 이벤트가 전파된다. 그러나, linkBox 요소를 클릭하게 되면, 이벤트는 부모요소로 전파되지 않는다.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://cheonmro.github.io/categories/Javascript/"}],"tags":[{"name":"Event Object","slug":"Event-Object","permalink":"https://cheonmro.github.io/tags/Event-Object/"}]},{"title":"Event Flow(이벤트의 흐름)","slug":"event-flow","date":"2018-09-03T05:38:03.000Z","updated":"2018-09-03T05:38:03.785Z","comments":true,"path":"2018/09/03/event-flow/","link":"","permalink":"https://cheonmro.github.io/2018/09/03/event-flow/","excerpt":"","text":"Event Flow(이벤트의 흐름)이란 무엇인가? Event Flow란, 어떤 요소에서 이벤트가 발생했을 때, 그 이벤트를 전파하여 감지하는 흐름을 말한다. 이벤트의 흐름은 아래와 같이, 버블링과 캡처링 방식으로 이벤트를 감지한다. 출처: Event Flow Event Delegation(이벤트 위임) Event Delegation이란, 다수의 자식 요소에 각각 이벤트 핸들러를 바인딩하는 대신에, 하나의 부모 요소에 이벤트 핸들러를 바인딩하는 방법이다. 이벤트 위임을 하게 되면, 개별 자식 요소에 이벤트 핸들러를 바인딩할 필요가 없을 뿐 아니라, DOM 트리에 새로운 자식 요소가 추가되더라도, 이벤트 처리는 이벤트가 위임된 부모 요소에서 하기 때문에 코드도 간단해지고, 실행속도도 좋아지게 된다. 아래의 코드를 보자. 12345678910111213141516// HTML&lt;ul id=&quot;parent&quot;&gt; &lt;li id=&quot;content1&quot;&gt;HTML&lt;/li&gt; &lt;li id=&quot;content2&quot;&gt;CSS&lt;/li&gt; &lt;li id=&quot;content3&quot;&gt;JAVASCRIPT&lt;/li&gt;&lt;/ul&gt;// JavascriptgetColor() &#123; console.log(&apos;get color&apos;);&#125;var con1 = document.querySelector(&apos;#content1&apos;).addEventListener(&apos;click&apos;, getColor);var con2 = document.querySelector(&apos;#content2&apos;).addEventListener(&apos;click&apos;, getColor);var con3 = document.querySelector(&apos;#content3&apos;).addEventListener(&apos;click&apos;, getColor); 만약 이벤트 위임을 안한다면, 위 코드처럼 모든 자식 요소에 이벤트 핸들러를 바인딩해줘야 한다. 위 코드처럼 3개는 크게 문제가 안될 수도 있지만, 만약 10개, 100개면 어떨까? 그렇게 되면 자식요소가 너무 많아지기 때문에, 각 자식요소에 이벤트 핸들러를 바인딩하는 것도 힘들고, 코드 가독성도 안좋게 되고, 결국 실행속도도 저하가 된다. 위 코드를 이벤트 위임을 하면 아래와 같다.12345678910111213// HTML&lt;ul id=&quot;parent&quot;&gt; &lt;li id=&quot;content1&quot;&gt;HTML&lt;/li&gt; &lt;li id=&quot;content2&quot;&gt;CSS&lt;/li&gt; &lt;li id=&quot;content3&quot;&gt;JAVASCRIPT&lt;/li&gt;&lt;/ul&gt;// JavascriptgetColor() &#123; console.log(&apos;get color&apos;);&#125;var allContents = document.querySelector(&apos;#parent&apos;).addEventListener(&apos;click&apos;, getColor); 위와 같이 부모요소 1개에만 이벤트 핸들러를 바인딩하게 되면, 어떤 자식(하위)요소에서 이벤트가 발생하게 되면 그 이벤트를 부모요소가 감지하여 addEventListener의 콜백함수가 실행되게 된다. 이렇게 하위요소에서 이벤트가 발생하여 상위요소로 전달되어 상위요소가 그 이벤트를 감지하는 것을 버블링이라고 한다. 그 반대 방향으로 감지하는 것을 캡처링이라고 한다. 이부분을 잘 이해해야 이벤트 위임을 잘 할 수 있다. Event Bubbling(이벤트 버블링) &amp; Event Capturing(이벤트 캡처링) 브라우저가 이벤트를 감지하는 방식은 2가지가 있다. Event Bubbling(이벤트 버블링) Event Capturing(이벤트 캡처링) Event Bubbling(이벤트 버블링) 이벤트 버블링이란, 자식(하위)요소에서 발생한 이벤트가 부모(상위)요소로 전파(이벤트 전파: Event Propagation)되는 것을 말한다. 아래의 코드를 보자.12345678910111213141516171819202122232425// HTML&lt;div id=&quot;ancestor&quot;&gt; &lt;ul id=&quot;parent&quot;&gt; parent &lt;li id=&quot;child&quot;&gt;child&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;// Javascriptvar divAncestor = document.querySelector(&apos;#ancestor&apos;);var ulParent = document.querySelector(&apos;#parent&apos;);var liChild = document.querySelector(&apos;#child&apos;);divAncestor.addEventListener(&apos;click&apos;, function() &#123; console.log(&apos;Event for div&apos;);&#125;)ulParent.addEventListener(&apos;click&apos;, function() &#123; console.log(&apos;Event for ul&apos;);&#125;)liChild.addEventListener(&apos;click&apos;, function() &#123; console.log(&apos;Event for li&apos;);&#125;) 위 코드에서 ‘child’(li 요소)를 클릭하면, 아래와 같은 결과가 나온다.123Event for liEvent for ulEvent for div 자식요소인 li를 클릭하면, li에서 이벤트가 발생하고, 그 부모요소인 ul에서 이벤트가 발생하고, ul의 부모요소인 div에서 이벤트가 발생한다. 즉, 이벤트가 발생한 곳부터 위로 하나씩 이벤트가 발생하게 된다. 이때, 어떤 요소에 이벤트가 없을 경우(addEventListener가 없을 경우), 그 요소에서는 이벤트가 발생하지 않는다. 예를 들어, 아래의 코드를 보자.1234567891011121314151617181920// HTML&lt;div id=&quot;ancestor&quot;&gt; &lt;ul id=&quot;parent&quot;&gt; parent &lt;li id=&quot;child&quot;&gt;child&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;// Javascriptvar divAncestor = document.querySelector(&apos;#ancestor&apos;);var liChild = document.querySelector(&apos;#child&apos;);divAncestor.addEventListener(&apos;click&apos;, function() &#123; console.log(&apos;Event for div&apos;);&#125;)liChild.addEventListener(&apos;click&apos;, function() &#123; console.log(&apos;Event for li&apos;);&#125;) 위 코드에서 ‘child’(li 요소)를 클릭하면, 아래와 같은 결과가 나온다.12Event for liEvent for div 즉, ul요소는 이벤트가 없기 때문에(addEventListener가 없다.), 이벤트가 발생하지 않고, 그 부모요소인 div요소로 넘어가 div요소의 이벤트가 발생하게 된다. 또한, li요소가 아닌, ul을 클릭하게 되면, ul요소에서 이벤트가 발생하고, 그 부모요소인 div요소에서 이벤트가 전달된다. 즉, 이벤트가 발생한 요소부터 시작하여 상위요소로 이벤트가 발생하는 방식을 이벤트 버블링이라고 한다. 그럼 여기서 이벤트 위임을 하는 코드를 확인해보자.1234567891011121314// HTML&lt;div class=&quot;parent&quot;&gt; &lt;button id=&quot;btn1&quot;&gt;button 1&lt;/button&gt; &lt;button id=&quot;btn2&quot;&gt;button 2&lt;/button&gt;&lt;/div&gt;// Javascript function getColor(e) &#123; e.target.style.color = &apos;red&apos;;&#125;var parent = document.querySelector(&apos;.parent&apos;);parent.addEventListener(&apos;click&apos;, getColor); 위 코드에서는, 모든 자식요소에 이벤트 핸들러를 바인딩하는 대신에, 부모요소 1개에만 이벤트핸들러를 바인딩했는데, 이것을 이벤트 위임이라고 한다. 따라서, 자식요소가 button1, button2 둘 중 어느 곳을 클릭을 하더라도, 이벤트가 부모요소로 전달되어, 부모요소인 parent 요소에서 이벤트를 감지하고 이벤트를 발생시킨다. Event Capturing(이벤트 캡처링) 이벤트 캡처링이란, 자식 요소에서 발생한 이벤트가 부모 요소부터 시작하여 이벤트를 발생시킨 자식 요소까지 도달하는 것을 말한다. 아래의 코드를 보자.12345678910111213141516171819202122232425// HTML&lt;div id=&quot;ancestor&quot;&gt; &lt;ul id=&quot;parent&quot;&gt; parent &lt;li id=&quot;child&quot;&gt;child&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;// Javascriptvar divAncestor = document.querySelector(&apos;#ancestor&apos;);var ulParent = document.querySelector(&apos;#parent&apos;);var liChild = document.querySelector(&apos;#child&apos;);divAncestor.addEventListener(&apos;click&apos;, function() &#123; console.log(&apos;Event for div&apos;);&#125;, true)ulParent.addEventListener(&apos;click&apos;, function() &#123; console.log(&apos;Event for ul&apos;);&#125;, true)liChild.addEventListener(&apos;click&apos;, function() &#123; console.log(&apos;Event for li&apos;);&#125;, true) 참고로, 캡처링을 적용하려면, addEventListener 메소드의 세번째 매개변수에 true를 설정해야 한다. 설정하지 않으면 default로 버블링이다. 위 코드에서 ‘child’(li 요소)를 클릭하면, 아래와 같은 결과가 나온다.123Event for divEvent for ulEvent for li 자식요소인 li를 클릭하면, 최상위 부모요소인 div에서 먼저 이벤트가 발생하고, 아래 방향으로 하나씩 이벤트가 발생한다. 즉, 버블링과 반대로, 이벤트가 발생한 곳은 자식요소이나, 이벤트를 감지하는 곳은 최상위 부모요소부터 시작하여 실제로 이벤트가 발생한 요소까지 도달하는데, 이런식으로 이벤트를 감지하는 것을 이벤트 캡처링이라고 한다. 예를 들어, 아래의 코드를 보자.1234567891011121314151617181920// HTML&lt;div id=&quot;ancestor&quot;&gt; &lt;ul id=&quot;parent&quot;&gt; parent &lt;li id=&quot;child&quot;&gt;child&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;// Javascriptvar divAncestor = document.querySelector(&apos;#ancestor&apos;);var liChild = document.querySelector(&apos;#child&apos;);divAncestor.addEventListener(&apos;click&apos;, function() &#123; console.log(&apos;Event for div&apos;);&#125;)liChild.addEventListener(&apos;click&apos;, function() &#123; console.log(&apos;Event for li&apos;);&#125;) 위 코드에서 ‘child’(li 요소)를 클릭하면, 아래와 같은 결과가 나온다.12Event for divEvent for li 즉, ul요소는 이벤트가 없기 때문에(addEventListener가 없다.), 이벤트가 발생하지 않고, 그 부모요소인 div요소부터 이벤트가 발생하고, 그 다음 li요소에서 이벤트가 발생하게 된다. 또한, li요소가 아닌, ul을 클릭하게 되면, 최상위 요소인 div요소에서 이벤트가 발생하여, 이벤트가 발생한 ul요소까지 이벤트가 도달하게 된다. 즉, 이벤트가 어디서 발생하는 것과는 상관없이, 최상위 부모요소에서부터 이벤트가 발생하기 시작하여, 실제로 이벤트가 발생한 곳까지 가는 방식을 이벤트 캡처링이라고 한다.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://cheonmro.github.io/categories/Javascript/"}],"tags":[{"name":"Event Flow","slug":"Event-Flow","permalink":"https://cheonmro.github.io/tags/Event-Flow/"}]},{"title":"Event Binding(이벤트 바인딩)과 Event Handler(이벤트 핸들러)","slug":"event-binding-and-event-handler","date":"2018-09-02T23:58:00.000Z","updated":"2018-09-02T23:58:00.626Z","comments":true,"path":"2018/09/03/event-binding-and-event-handler/","link":"","permalink":"https://cheonmro.github.io/2018/09/03/event-binding-and-event-handler/","excerpt":"","text":"Event Binding 바인딩이란, 서로 묶어서 연결해 준다는 뜻이다. 이벤트 바인딩이란, 발생하는 이벤트와 그 후에 어떤 일이 벌어질지 알려주는 함수(콜백함수)와 묶어서 연결해 준다는 뜻이다. 예를 들어, 어떤 버튼을 사용자가 클릭하게 되면, 클릭(‘click’)이벤트가 발생하게 되고, 그 이벤트가 발생했을 때 어떤 일이 벌어진다는 것을 알려주는 콜백함수를 실행하게 된다. 이때, 이 콜백함수를 이벤트 핸들러라고 한다. 이벤트 바인딩에는 대표적으로 3가지 방식이 있다. HTML 이벤트 핸들러 전통적인 DOM 이벤트 핸들러 Event Listener를 이용한 이벤트 핸들러 1~2번의 단점을 보완한 방식이 Event Listener를 이용한 이벤트 핸들러 방식이다. 1. HTML 이벤트 핸들러HTML 요소의 이벤트 Attribute에 이벤트 핸들러를 대응시키는 방법이다.12345&lt;button onclick=&quot;clickBtn()&quot;&gt;Click me&lt;/button&gt;function clickBtn() &#123; alert(&apos;Button clicked!&apos;);&#125; 옛날 코드를 보게 되면 위와 같은 방식을 사용한 코드가 있다. 그래서 혹시 모를 상황에 대비해 알아둘 필요는 있지만, 현재 이 방식은 사용되지 않고, 사용해서도 안된다. 또한, 이렇게 되면 HTML과 Javascript가 혼용이 되는데, 이 둘은 관심사가 다르기 때문에 같이 사용하는 것을 피해야 한다. HTML 이벤트 핸들러 내부의 thisHTML 이벤트 핸들러 방식의 경우, 이벤트 핸들러 내부의 this는 window를 가리킨다. 1234567&lt;button onclick=&quot;clickBtn()&quot;&gt;Click me&lt;/button&gt;function clickBtn() &#123; alert(&apos;Button clicked!&apos;); console.log(this); // window console.log(event.currentTarget); // &lt;button onclick=&quot;clickBtn()&quot;&gt;Click me&lt;/button&gt;&#125; 2. 전통적인 DOM 이벤트 핸들러HTML Event Handler의 보완점: HTML과 Javascript가 혼용되는 문제는 해결 단점: 이벤트 핸들러에 하나의 함수만을 바인딩할 수 있다. 함수에 인수를 전달할 수 없다. 바인딩된 이벤트 핸들러가 2개 이상일 경우, 제일 마지막에 추가된 코드의 바인딩된 이벤트 핸들러만 실행된다. 12345678910111213&lt;button id=&quot;myBtn&quot;&gt;Click me&lt;/button&gt;var myBtn = document.getElementById(&apos;myBtn&apos;);// 첫번째 바인딩된 이벤트 핸들러 =&gt; 실행되지 않는다.myBtn.onclick = function () &#123; alert(&apos;Button clicked 1&apos;);&#125;;// 두번째 바인딩된 이벤트 핸들러myBtn.onclick = function () &#123; alert(&apos;Button clicked 2&apos;);&#125;; 전통적인 DOM 이벤트 핸들러 내부의 this전통적인 DOM 이벤트 핸들러 방식에서 이벤트 핸들러 내부의 this는 이벤트에 바인딩된 요소를 가리킨다. 이것은 이벤트 객체의 currentTarget 프로퍼티와 같다. 12345678&lt;button id=&quot;myButton&quot;&gt;Click me!!!&lt;/button&gt;var myBtn = document.getElementById(&apos;myButton&apos;);myBtn.onclick = function() &#123; console.log(this); // &lt;button id=&quot;myButton&quot;&gt;Click me!!!&lt;/button&gt; console.log(event.currentTarget); // &lt;button id=&quot;myButton&quot;&gt;Click me!!!&lt;/button&gt; console.log(this === event.currentTarget); // true&#125;; myButton이란 id를 가진 button 요소(myBtn)가 이벤트에 바인딩된 요소를 말한다. 이것은 이벤트 객체의 currentTarget 프로퍼티와 같다. 3. Event Listener를 이용한 이벤트 핸들러addEventListener 함수를 이용하여 대상 요소(Event Target)에 이벤트를 바인딩하고, 해당 이벤트가 발생했을 때 실행될 콜백 함수를 지정한다. 1234target.addEventListener(type, listener[, useCapture]);var el = document.getElementById(&quot;outside&quot;);el.addEventListener(&quot;click&quot;, function()&#123;modifyText(&quot;four&quot;)&#125;, false); addEventListener 함수의 인수: type: 이벤트 타입 listener: 이벤트 핸들러, 즉 이벤트가 발생했을 때, 실행될 콜백함수 useCapture: true면 Capturing, false면 Bubbling(Default: false) Event Listener를 이용한 이벤트 핸들러의 장점 하나의 이벤트에 대해 하나 이상의 핸들러를 추가할 수 있다. 캡처링(Capturing)과 버블링(Bubbling)을 지원한다. HTML 요소뿐만아니라 모든 DOM 요소에 대해 동작한다. 1234567&lt;label for=&apos;email&apos;&gt;Your Email&lt;/label&gt;&lt;input type=&apos;text&apos; id=&apos;email&apos;&gt;var elem = document.getElementById(&apos;email&apos;);elem.addEventListener(&apos;blur&apos;, function() &#123; alert(&apos;Your Email!&apos;);&#125;); 참고로, addEventListener 함수는 IE 9 이상에서 동작한다. IE 8 이하에서는 attachEvent 함수를 사용한다. 만약 addEventListener 함수 앞에 대상요소(elem)를 지정하지 않으면, blur 이벤트는 전역객체 window에 바인딩된다. Event Listener를 이용한 이벤트 핸들러 내부의 thisaddEventListener 함수에서 지정한 이벤트 핸들러 내부의 this는 Event Listener에 바인딩된 요소(currentTarget)를 가리킨다. 이것은 이벤트 객체의 currentTarget 프로퍼티와 같다. 12345678&lt;button id=&quot;myBtn&quot;&gt;Click me!!!&lt;/button&gt;var myBtn = document.getElementById(&apos;myBtn&apos;);myBtn.addEventListener(&apos;click&apos;, function (event) &#123; console.log(this); // &lt;button id=&quot;myBtn&quot;&gt;Click me!!!&lt;/button&gt; console.log(event.currentTarget); // &lt;button id=&quot;myBtn&quot;&gt;Click me!!!&lt;/button&gt; console.log(this === event.currentTarget); // true&#125;);","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://cheonmro.github.io/categories/Javascript/"}],"tags":[{"name":"Event Binding","slug":"Event-Binding","permalink":"https://cheonmro.github.io/tags/Event-Binding/"}]},{"title":"Event와 Event 종류","slug":"event-type","date":"2018-09-02T05:29:53.000Z","updated":"2018-09-02T05:29:53.438Z","comments":true,"path":"2018/09/02/event-type/","link":"","permalink":"https://cheonmro.github.io/2018/09/02/event-type/","excerpt":"","text":"Event(이벤트)란 무엇인가? 이벤트는 어떤 사건을 말한다. 브라우저에서 사건(Event)이란, 예를 들어, 사용자가 어떤 웹페이지에서 버튼을 클릭했을 ‘때’ 또는 어떤 박스에서 값을 입력했을 ‘때’를 의미한다. 이벤트는 이벤트가 발생했을 때, 그에 맞는 대응을 하도록 코드를 작성해야 한다. 이를 위해서는 보통, 이벤트는 함수에 연결되며 그 함수는 이벤트가 발생하기 전에는 실행되지 않다가 이벤트가 발생하면 실행되는데, 이 함수(콜백함수)를 이벤트 핸들러라고 한다.1234var elem = document.getElementById(&apos;alertButton&apos;);elem.addEventListener(&apos;click&apos;, function() &#123; alert(&apos;Hello World&apos;);&#125;); id가 alertButton인 DOM 요소의 버튼을 클릭했을 때(이벤트), ‘Hello World’를 보여주는 alert가 실행되는 콜백함수가 이벤트 핸들러이다. Event 종류 브라우저에 사용하는 이벤트는 다양하지만, 자주 사용되거나 대표적인 이벤트만 정리한다. 1. UI Event Event Description load 웹페이지의 로드가 완료되었을 때 unload 웹페이지가 언로드될 때(주로 새로운 페이지를 요청한 경우) error 브라우저가 자바스크립트 오류를 만났거나 요청한 자원이 존재하지 않는 경우 resize 브라우저 창의 크기를 조절했을 때 scroll 사용자가 페이지를 위아래로 스크롤할 때 select 텍스트를 선택했을 때 load 이벤트를 사용하는 예제123window.addEventListener(&quot;load&quot;, function(event) &#123; console.log(&quot;All resources finished loading!&quot;);&#125;); 2. Keyboard Event Event Description keydown 키를 누르고 있을 때 keyup 누르고 있던 키를 뗄 때 keypress 키를 누르고 뗏을 때 keyup 이벤트를 사용하는 예제12345inputTodo.addEventListener(&apos;keyup&apos;, function (e) &#123; if (e.keyCode !== 13 || !inputTodo.value) return; addTodo(inputTodo.value); inputTodo.value = &apos;&apos;;&#125;); 3. Mouse Event Event Description click 마우스 버튼을 클릭했을 때 dbclick 마우스 버튼을 더블 클릭했을 때 mousedown 마우스 버튼을 누르고 있을 때 mouseup 누르고 있던 마우스 버튼을 뗄 때 mousemove 마우스를 움직일 때 (터치스크린에서 동작하지 않는다) mouseover 마우스를 요소 위로 움직였을 때 (터치스크린에서 동작하지 않는다) mouseout 마우스를 요소 밖으로 움직였을 때 (터치스크린에서 동작하지 않는다) click 이벤트를 사용하는 예제1234todoList.addEventListener(&apos;click&apos;, function (e) &#123; if (!e.target || e.target.nodeName !== &apos;SPAN&apos; || e.target.parentNode.nodeName === &apos;LABEL&apos;) return; removeTodo(e.target.dataset.id);&#125;); 4. Focus Event Event Description focus 요소가 포커스를 얻었을 때 blur 요소가 포커스를 잃었을 때 focus와 blur 이벤트를 사용하는 예제12345678var form = document.getElementById(&quot;form&quot;);form.addEventListener(&quot;focus&quot;, function( event ) &#123; event.target.style.background = &quot;pink&quot;;&#125;, true);form.addEventListener(&quot;blur&quot;, function( event ) &#123; event.target.style.background = &quot;&quot;;&#125;, true); 5. Form Event Event Description input input 또는 textarea 요소의 값이 변경되었을 때 change select box, checkbox, radio button의 상태가 변경되었을 때 submit form을 submit할 때 (버튼 또는 키) reset reset 버튼을 클릭할 때 (최근에는 사용 안함) change 이벤트를 사용하는 예제12345678910todoList.addEventListener(&apos;change&apos;, function (e) &#123; toggleTodoComplete(e.target.id);&#125;);var toggleTodoComplete = function (id) &#123; todos = todos.map(function (todo) &#123; return todo.id === +id ? Object.assign(&#123;&#125;, todo, &#123; completed: !todo.completed &#125;) : todo; &#125; ); renderTodos();&#125;; 6. Clipboard Event Event Description cut 콘텐츠를 잘라내기할 때 copy 콘텐츠를 복사할 때 paste 콘텐츠를 붙여넣기할 때 copy 이벤트를 사용하는 예제12345document.addEventListener(&apos;copy&apos;, function(e)&#123; e.clipboardData.setData(&apos;text/plain&apos;, &apos;Hello, world!&apos;); e.clipboardData.setData(&apos;text/html&apos;, &apos;&lt;b&gt;Hello, world!&lt;/b&gt;&apos;); e.preventDefault(); // We want our data, not data from any selection, to be written to the clipboard&#125;); 7. Websocket Event Event Description open 웹소켓 연결이 되었을 때 message 웹소켓을 통해 메세지가 전달되었을 때 error 몇개의 메세지가 전달이 안된 상태로 웹소켓 연결이 끝났을 때 close 웹소켓 연결이 끝났을 때 8. CSS Animation Event Event Description animationstart CSS 애니메이션이 시작되었을 때 animationend CSS 애니메이션이 끝났을 때 animationiteration CSS 애니메이션이 반복될 때 이외에 다른 이벤트는 MDN에서 확인할 수 있다.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://cheonmro.github.io/categories/Javascript/"}],"tags":[{"name":"Event","slug":"Event","permalink":"https://cheonmro.github.io/tags/Event/"}]},{"title":"Event Loop(이벤트루프)와 Javascript Concurrency(동시성)","slug":"event-loop-and-concurrency","date":"2018-09-02T03:09:06.000Z","updated":"2018-09-02T03:09:06.542Z","comments":true,"path":"2018/09/02/event-loop-and-concurrency/","link":"","permalink":"https://cheonmro.github.io/2018/09/02/event-loop-and-concurrency/","excerpt":"","text":"Browser Architecture 출처: Browser Architecture Browser안에는 위와 같이 자바스크립트엔진 뿐만 아니라 다른 것들이 같이 포함되어 있다. 자바스크립트엔진(크롬: V8) Heap과 Stack으로 구성되어있고, 자바스크립트가 브라우저에서 실행되는 곳이 자바스크립트엔진, 정확히는 Stack이다. Web APIs 비동기 방식으로 호출되는 것들(Timer 함수/DOM Event/Ajax)이 정의되는 영역이다. Callback Queue Web APIs으로부터 옮겨와 자바스크립트엔진의 Stack으로 이동하기 위해 기다리는 곳이다. Event Loop Callback Queue에서 기다리고 있는 비동기 방식으로 호출되는 것들(Timer 함수/DOM Event/Ajax)을 Stack이 완전히 비어있을 때 이동시키는 역할을 한다. 자바스크립트 기본 특징 자바스크립트는 싱글쓰레드(single-threaded), 즉 1개의 쓰레드를 가지고있다. 1개의 쓰레드를 가지고 있다는 말은 한번에 하나일을 처리한다는 것이다. 자바스크립트엔진의 Stack에서 한번에 하나의 일(함수 호출)을 처리한다는 뜻이다. 그런데, 실제로 자바스크립트 기반의 애플리케이션은 여러가지일이 동시에 일어난다. 왜 그럴까? 이걸 전문적으로 말하면 자바스크립트는 동시성(Concurrency)을 지원한다는 것인데, 어떻게 그럴 수 있을까? 여기서 이벤트루프(Event Loop)에 대한 개념이 나온다. 먼저 동기적(한번에 하나의 일을 처리)으로 작동하는 기본적인 자바스크립트 코드가 돌아가는 원리를 알아보자. (기본) 자바스크립트 동작 원리 다시 한번 Architecture를 보자. 출처: Browser Architecture 비동기로 호출되는 것들(Timer 함수/DOM Event/Ajax)이 없는 자바스크립트 코드의 경우, 자바스크립트엔진의 Stack에서만 하나씩 호출되어 코드가 돌아간다. 즉, Web AIPs, Callback Queue, 그리고 Event Loop 등을 사용하지 않는다. 아래 동기적 코드를 보자.123456789function multiply(a, b) &#123; return a*b;&#125;function square(a) &#123; const sq = multiply(a, a); console.log(sq);&#125;square(3); 이 코드는 어떤 순서로 호출되어 값이 나오게 될까? 호출되는 순서는 다음과 같다. square(3) 때문에, square 함수가 먼저 호출된다. sq에 multiply 함수를 할당하기 위해, multiply 함수가 호출된다. multiply의 return 값이 나온다. console.log(sq)의 결과값이 나온다. 이 순서를 Stack에서 확인해보자. 출처: 동기적 자바스크립트 위 그림과 같이, Stack에서 push로 하나씩 함수가 쌓이고, pop으로 마지막에 쌓인 것부터 하나씩 호출되어 실행되고, 제거된다. 이런식으로, 한번에 하나씩 순서대로 일이 진행되어, 결과값이 나오게 된다. 이게 동기적 방식이다. Error: Maximum call stack size exceededStack안에 쌓이는 각 함수를 Stack Frame이라고 한다. 보통, 이런 각 Stack Frame은 ms(1초=1000ms)안에 동작이 끝난다. 그런데, Stack에는 Stack Frame의 수가 정해져 있고, 이 수를 넘게되면 에러가 발생하게 된다. 아래 코드를 보자. 1234function foo() &#123; return foo();&#125;foo(); 위 코드를 작성하고 실행하게 되면, 다음과 같은 에러가 발생한다.1RangeError: Maximum call stack size exceeded 이 에러의 원인은 Stack안에 정해진 Stack Frame의 수를 초과했다는 뜻이다. 즉, foo 함수가 호출될 때, return 값으로 foo 함수가 호출되기 때문에, 계속해서 호출되게 되고, 그 말은 Stack에 계속해서 foo 함수가 쌓인다는 뜻이다. 그래서 정해진 Stack Frame의 수를 초과하게 되어, 위와 같은 에러가 발생하게 된다. 이런 자바스크립트의 Stack에 대한 개념을 모르게되면, 이 에러가 발생했을 때 해결하기가 어려울 수 있다. 그럼, 자바스크립트에 동시성(Concurrency)을 어떻게 지원하는지 알아보자. 비동기적 자바스크립트 동작 원리 다시 한번 Architecture를 보자. 출처: Browser Architecture 비동기로 호출되는 것들(Timer 함수/DOM Event/Ajax)이 있는 자바스크립트 코드의 경우, 자바스크립트엔진의 Stack에서 Web AIPs로 이동하게 되고, 다시 Callback Queue로 이동하게 된다. 그리고 Stack에 있는 모든 함수가 제거되고 난뒤, Event Loop로 인해 Stack으로 이동되어, 함수가 호출되고 제거된다. 아래 비동기적 코드를 보자.12345console.log(&quot;Print this 1st&quot;);setTimeout(() =&gt; &#123; console.log(&quot;Print this 3rd&quot;);&#125;, 500);console.log(&quot;Print this 2nd&quot;); 이 코드는 어떤 순서로 호출되어 값이 나오게 될까?123&quot;Print this 1st&quot;&quot;Print this 2nd&quot;&quot;Print this 3rd&quot; 비동기 함수인 setTimeout 함수가 0.5초뒤에 실행되니, 그 전에 마지막 console.log가 먼저 출력되어, 순서가 저렇게 된것일까? 이 과정을 정확하게 위해서는 이벤트루프(Event Loop) 개념을 이해해야 한다. 이 순서를 Architecture에서 확인해보자.위 코드가 실제로 실행되는 과정은 아래와 같다. 출처: 비동기적 자바스크립트 먼저, 첫번째 console.log가 호출되고, 제거된다. 그리고, 비동기 함수인 setTimeout 함수가 호출된뒤, Web APIs로 이동한다. 이와 동시에, Stack에서 다음 console.log가 쌓인다. 이동한 setTimeout 함수는 Web APIs에서 0.5초(500ms) 동안 있다가, Callback Queue로 이동한다. Event Loop는 Stack에 있는 모든 함수가 제거된 것을 확인한 후, Callback Queue에 있는 setTimeout 함수를 Stack으로 보내고 실행한다. 그리고, 그 setTimeout 함수는 Stack에서 제거된다. 자바스크립트에서의 비동기적 방식은 위와 같이 진행되기 때문에, 비동기 함수보다 다른 일반 함수들이 먼저 실행되고, 그 다음에 비동기 함수가 진행된다. 결국, 자바스크립트엔진 밖에 있는 Web APIs, Callback Queue, 그리고 Event Loop가 비동기 함수를 따로 관리함으로써 자바스크립트에 동시성이 가능하게 된다. 따라서, 자바스크립트 기반의 애플리케이션은 여러가지 일들이 동시에 발생할 수 있는 것이다. 만약, setTimeout 함수의 두번째 인수가 ‘0’초면 어떻게 될까?아래 코드를 보자.12345console.log(&quot;Print this 1st&quot;);setTimeout(() =&gt; &#123; console.log(&quot;Print this 3rd&quot;);&#125;, 0);console.log(&quot;Print this 2nd&quot;); 이 코드는 어떤 순서로 호출되어 값이 나오게 될까?123&quot;Print this 1st&quot;&quot;Print this 2nd&quot;&quot;Print this 3rd&quot; 이 또한 setTimeout 함수의 두번째 인수가 0.5초일때와 동일하게 나온다. 즉, timer 함수의 시간과 상관없이, 이벤트루프는 Stack에 있는 다른 모든 함수가 제거된 뒤, timer 함수를 Stack으로 이동시키기 때문이다. 단지, Wep APIs에서 0.5초 걸리느냐, 0초 걸리느냐에 차이이다. 다른 비동기인 DOM 이벤트의 경우는 어떻게 될까?아래 코드를 보자.12345678910111213141516171819202122function func1() &#123; console.log(&apos;func1&apos;); func2();&#125;function func2() &#123; // &lt;button id=&quot;bar&quot;&gt;bar&lt;/button&gt; var elem = document.getElementById(&apos;bar&apos;); elem.addEventListener(&apos;click&apos;, function () &#123; this.style.backgroundColor = &apos;blue&apos;; console.log(&apos;func2&apos;); &#125;); func3();&#125;function func3() &#123; console.log(&apos;func3&apos;);&#125;func1(); 위 코드의 실행순서는 다음과 같다. 함수 func1()이 호출되면 함수 func1()은 Stack에 쌓인다. 함수 func1()은 함수 func2를 호출하므로 함수 func2()가 Stack에 쌓이고 addEventListener가 호출된다. 이 addEventListener는 Wep APIs로 이동한다. Stack에는 func3()가 쌓인다. 이때, 만약 bar 버튼이 클릭되면, ‘click’ 이벤트가 발생하게 되어, addEventListener는 Callback Queue로 이동하게 된다. Stack에 있던 모든 함수가 제거되어 완전히 비어지면, 이벤트 루프는 이 addEventListener를 Stack으로 이동시키고, 실행하게 된다.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://cheonmro.github.io/categories/Javascript/"}],"tags":[{"name":"Event Loop","slug":"Event-Loop","permalink":"https://cheonmro.github.io/tags/Event-Loop/"}]},{"title":"Ajax란 무엇인가?","slug":"ajax","date":"2018-08-31T00:48:40.000Z","updated":"2018-10-31T15:06:57.854Z","comments":true,"path":"2018/08/31/ajax/","link":"","permalink":"https://cheonmro.github.io/2018/08/31/ajax/","excerpt":"","text":"Ajax란? Ajax는 Asynchronous JavaScript And XML의 약자로, XMLHttpRequest 객체를 이용하여 비동기 방식으로 서버와 통신을 하는 것을 말한다. 웹 브라우저의 클라이언트와 서버간 통신은 url를 이용한 http 통신으로 이루어진다. 즉 브라우저가 서버로 request를 날리기 위해서는 해당 브라우저의 url 주소를 변경하여야 하는데 이때는 페이지 이동이 일어나게 된다. 하지만 ajax 의 경우 브라우저의 url 주소의 변경을 이용하지 않고 내부적으로 통신하여 response 를 받아오기 때문에 특정 데이터만 불러오거나 비동기로 데이터를 불러와야하는 경우 사용된다. 이때 Same Origin Policy 정책으로 인해 cross domain 을 허용하지 않기 때문에 외부 도메인을 사용하여야 하는경우 JSONP, XML 등을 이용하여야 한다. 비동기적이란, 서버에 요청을 하고 그냥 기다리는 것이 아닌, 기다림과 동시에 다른 작업을 할 수 있다는 것을 말한다. Ajax가 가지고 있는 중요 특징은 바로 이 비동기성으로, 서버로부터 웹페이지가 반환될 때, 화면 전체를 갱신하지 않고, 페이지 일부만을 갱신하게 해준다. 즉, 페이지 이동이나 새로고침 없이 페이지 일부만을 갱신할 수 있다. 예를 들어, 사용자가 페이지에서 어떤 이벤트를 발생시키면, 페이지 전체가 아닌 페이지 일부분만을 업데이트해서 보여주기 때문에, 페이지 전체가 Refresh 되지 않아, 사용자가 그 일부의 데이터를 기다리면서, 다른 일을 하여도 문제가 없다. Ajax를 사용하는 대표적인 애플리케이션이 페이스북 타임라인이다. 페이스북 타임라인을 밑으로 내려가면서 보면, 그 페이스북 페이지 자체는 그대로 있는데, 필요한 타임라인 데이터만 받아올 수 있다. 웹 사이트 중 페이지 전환없이 새로운 데이터를 불러오는 사이트는 대부분 Ajax 기술을 사용하고 있다. JSON이란? JSON은 JavaScript Object Notation의 약자로, 클라이언트와 서버간에 데이터를 교환하기 위해 필요한 데이터 포맷을 말한다. 예전에는 데이터 교환을 위한 데이터 포맷으로 XML을 사용했으나, 요즘에는 데이터 구조화도 잘 되어있고, 가볍고 가독성이 좋은 JSON을 사용한다. JSON의 형태는 자바스크립트의 객체 리터럴과 비슷하지만, 순수 문자열로 구성된 규칙이 있는 구조화된 데이터 포맷이다. 12345&#123; &quot;id&quot;: 1, &quot;content&quot;: &quot;HTML&quot;, &quot;completed&quot;: false&#125; JSON의 이름(key)는 반드시 큰따옴표(“”)로 둘러싸야 한다.(작은따옴표(‘’)는 사용이 안된다.) JSON.parse() &amp; JSON.stringify() 클라이언트와 서버간에 통신을 할때는, JSON 형태, 즉 문자열로 데이터를 주고 받는다. 그러나, 서버로부터 응답받은 데이터를 클라이언트(브라우저)에서 사용하기 위해서는 JSON 형태의 문자열을 객체로 바꿔줘야 한다. 이를 역직렬화(Deserializing)이라고 하는데, 이를 위해서는 내장 객체 JSON의 static 메소드인 JSON.parse()를 사용해야 한다. 이와 반대로, 클라이언트(브라우저)에서 서버로 데이터를 보내기 위해서는 객체를 문자열로 바꿔줘야 한다. 이때는 JSON.stringify()를 사용해야 한다. JSON.stringify()에 대해 자세히 확인해보자. Ajax Request &amp; Response Javascript를 이용해서 서버로 보내는 Ajax Request를 만들기 위해서는 XMLHttpRequest 객체를 사용해서 Ajax 요청을 생성하고 전송한다. 서버로부터 응답을 받을때도 XMLHttpRequest 객체를 사용해서 처리한다. 즉, XMLHttpRequest 객체의 프로퍼티 및 메소드를 사용하여 코드를 작성한다. 코드 작성시, 크게 3가지로 나눌 수 있다. 서버로 요청 보내기 서버로 요청보낼때, Request Header 보내기 서버로부터 받은 응답 처리하기 1. Ajax Request 보내기 XMLHttpRequest 객체를 사용해서 Ajax 요청 처리에 대한 코드는 다음과 같다. 123var xhr = new XMLHttpRequest();xhr.open(&apos;GET&apos;, &apos;/users&apos;);xhr.send(); 1-1. XMLHttpRequest 인스턴스 생성 12// XMLHttpRequest 생성자로 xhr 인스턴스를 생성var xhr = new XMLHttpRequest(); XMLHttpRequest 객체는 다양한 프로퍼티 및 메소드를 가지고 있다. 1-2. XMLHttpRequest.open()으로 요청 준비 12// XMLHttpRequest가 가지고 있는 open 메소드로 요청을 준비xhr.open(&apos;GET&apos;, &apos;/users&apos;); XMLHttpRequest.open 메소드를 사용할 때, 인수는 다음과 같다. 첫번째 인수: HTTP Method(GET/POST/PUT/PATCH/DELETE 등)를 사용 두번째 인수: 요청 보낼 URL 세번째 인수(옵션): async로 비동기를 나타낸다.(true면 비동기, false면 동기인데, 아무것도 작성안하면 default로 비동기이다.) 1-3. XMLHttpRequest.send()로 요청 전송 12// XMLHttpRequest가 가지고 있는 send 메소드로 요청을 전송xhr.send(); 서버에 요청을 준비하는 단계를 보자.1xhr.open(&apos;GET&apos;, &apos;/users&apos;); 이때 HTTP Method로 ‘GET’을 사용하게 되면, URL의 일부분인 query string(쿼리문자열)로 데이터를 서버로 전송하기 때문에, send 메소드에 인수로 데이터를 보낼 필요가 없다. send 메소드에 인수를 Request Body라고 하는데, 이부분이 null이 되어, 무시된다. 그럼 만약, ‘GET’이 아닌 ‘POST’를 하게되면 어떻게 될까? 2. 서버로 요청보낼때, Request Header 보내기 ‘POST’의 경우, 데이터(payload)를 Request Body에 담아 전송한다.1234xhr.send((&#123; name: &quot;donald&quot;, country: &quot;United States&quot;&#125;)); 이럴 경우, XMLHttpRequest.setRequestHeader() 메소드를 사용해서, HTTP Request Header의 값을 설정해야 한다. 이때, setRequestHeader 메소드는 open 메소드 다음에, send 메소드 전에 호출해야 한다. 다음과 같이 작성하면 된다.123456xhr.open(&apos;POST&apos;, &apos;/users&apos;);xhr.setRequestHeader(&apos;Content-type&apos;, &apos;application/json&apos;);xhr.send(&#123; name: &quot;donald&quot;, country: &quot;United States&quot;&#125;); setRequestHeader 메소드를 사용할 때, 인수는 다음과 같다. 첫번째 인수: 자주 사용하는 Request Header인 Content-type 또는 Accept을 사용한다. 두번째 인수: MIME 타입 예를 들어, 아래와 같은 코드를 보자.1xhr.setRequestHeader(&apos;Content-type&apos;, &apos;application/json&apos;); ‘Content-type’은 Request Body에 담아 전송할 데이터의 MIME-type을 지정할 때 사용한다.MIME-type은 아래 테이블에 있는 타입들이며, 사용시에는 아래 서브타입처럼 작성한다. 타입 서브타입 text 타입 text/plain, text/html, text/css, text/javascript Application 타입 application/json, application/x-www-form-urlencode File 업로드하기 위한 타입 multipart/formed-date Request Body에 담아 전송할 데이터의 MIME-type을 지정하는 예제 코드는 다음과 같다.123456xhr.open(&apos;POST&apos;, &apos;/users&apos;);xhr.setRequestHeader(&apos;Content-type&apos;, &apos;application/json&apos;);xhr.send(JSON.stringify(&#123; name: &quot;donald&quot;, country: &quot;United States&quot;&#125;); ‘Accept’은 HTTP 클라이언트가 서버에 요청할 때, 서버가 센드백할 데이터의 MIME-type을 지정할 때 사용한다.예를 들어, 아래와 같이 작성한다.1xhr.setRequestHeader(&apos;Accept&apos;, &apos;application/json&apos;); 만약 ‘Accept’ 헤더를 설정하지 않을 경우, send 메소드가 호출될 때, ‘Accept’ 헤더가 /와 함께 전송된다.(/은 모든 MIME 타입을 의미한다.) 자세한 ‘Accept’에 대한 개념은 MDN에서 확인해보자. 클라이언트와 서버사이에서의 Request &amp; Response Message는 다음과 같다. 출처: HTTP Request and Resopnse Message 3. 서버로부터 받은 응답 처리하기 XMLHttpRequest 객체를 사용해서 Ajax 응답 처리에 대한 코드는 다음과 같다. 123456789xhr.onreadystatechange = function (e) &#123; if (xhr.readyState === XMLHttpRequest.DONE) &#123; if(xhr.status === 200) &#123; console.log(xhr.responseText); &#125; else &#123; console.log(&apos;Error!&apos;); &#125; &#125;&#125;; 3-1. XMLHttpRequest.onreadystatechange 호출XMLHttpRequest가 가지고 있는 readyState 프로퍼티가 변경(사용자로부터 이벤트 발생) 될 때마다, XMLHttpRequest가 가지고 있는 프로퍼티인 onreadystatechange(이벤트 핸들러)를 호출한다.123xhr.onreadystatechange = function (e) &#123; // readyState 프로퍼티가 변경될 때마다, 이 함수를 호출&#125; 3-2. XMLHttpRequest.readyState로 서버가 응답했는지 확인123if (xhr.readyState === XMLHttpRequest.DONE) &#123; // readyState가 완료되면, 이 함수를 호출&#125; XMLHttpRequest.readyState의 값은 아래와 같다. Value State Description 0 UNSENT XMLHttpRequest.open() 메소드 호출 이전 1 OPENED XMLHttpRequest.open() 메소드 호출 완료 2 HEADERS_RECEIVED XMLHttpRequest.send() 메소드 호출 완료 3 LOADING 서버 응답 중(XMLHttpRequest.responseText 미완성 상태) 4 DONE 서버 응답 완료 xhr.readyState의 값이 4(DONE)이면, 서버가 응답을 완료했다는 뜻이다. 3-3. XMLHttpRequest.status로 정상 응답인지 확인12345if(xhr.status === 200) &#123; console.log(xhr.responseText);&#125; else &#123; console.log(&apos;Error!&apos;);&#125; 응답코드가 200번 대 숫자면 정상 응답이므로, xhr.status가 정상적인 응답코드이면, 서버로부터 전송되는 데이터가 담겨 있는 xhr.responseText가 클라이언트로 전달된다.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://cheonmro.github.io/categories/Javascript/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"https://cheonmro.github.io/tags/Ajax/"}]},{"title":"REST API란 무엇인가?","slug":"rest-api","date":"2018-08-30T04:06:44.000Z","updated":"2018-08-30T04:06:44.265Z","comments":true,"path":"2018/08/30/rest-api/","link":"","permalink":"https://cheonmro.github.io/2018/08/30/rest-api/","excerpt":"","text":"REST API란? REpresentational State Transfer의 약자로, 서버의 자원을 정의하고, 자원에 대한 주소를 지정하는 방법(표기법)을 말한다. 2000년, 아파치 HTTP 서버 프로젝트의 공동설립자인 Roy fielding(로이 필딩)에 의해 처음 소개가 되었는데, 이 분은 HTTP/1.0,1.1 스펙 작성에 참여하신 분이다. 그는 웹의 장점을 최대한 활용할 수 있는 Architecture로써 REST를 소개하면서, REST API 규칙을 만들었다. 이런 REST API 규칙을 잘 지킨 서비스 디자인을 “RESTful”하다고 표현한다. REST API는 HTPP 프로토콜을 정확히 의도에 맞게 활용하여 디자인하게 유도하기 때문에, 디자인 기준이 명확해지고, 의미적인 범용성을 지닌다. 즉, 서버가 이해하기 쉽게 자원에 대한 주소를 지정하는 표기법이 REST API이다. REST API 구성 요소 REST API를 구성하는 것은 다음과 같이 3가지가 있다. 자원(Resource) 행위(Verb) 표현(Representation) 자원(Resource) 자원(Resource)이란, 해당 소프트웨어가 관리하는 모든 것이 될 수 있다.JSON, XML 등의 문서가 될 수 있고, 그림파일이 될 수도 있다.즉, 어떤 데이터(문서, 파일, 비디오 등)를 말한다. 예를 들어, 서버 데이터베이스에 사용자들에 대한 정보가 들어가 있다면, 이 사용자들의 정보가 데이터이기 때문에, 자원(Resource)이 된다. 이때, 이 사용자들에 대한 데이터를 대표하는 이름을 users라고 해보자. 만약, 이 사용자들 중에서 어떤 한 명의 사용자에 대한 자원을 얻고자 한다면 어떻게 해야할까? 그럴때는, users/id 처럼, 사용자들 중 특정 id로 사용자를 구분해서 사용할 수 있다. 자원(Resource)은 HTTP URI로 표현한다. 예를 들어, http://localhost:4000/users/1 이런식으로 작성하며, 이 URI를 이용하여 원하는 자원(Resource)에 접근할 수 있다. 행위(Verb) REST API에서 말하는 행위(Verb)는 자원에 대한 행위를 말한다. 즉, HTTP Method를 사용해서 자원을 얻거나, 만들거나, 변경하거나, 삭제하는 등의 행위를 할 수 있다. HTTP Method 중 대표적으로 자주 사용되는 메서드는 다음과 같다. GET : 서버 자원을 가져오고자 할 때 사용한다.(Retrieve: 모든/특정 자원을 조회) POST : 서버에 자원을 새로 등록하고자 할 때 사용한다.(Create: 자원을 생성) PUT : 서버의 자원을 새로 요청한 자원으로 변경하고자 할 때 사용한다.(Update: 자원을 갱신) PATCH : 서버 자원의 일부만 수정하고자 할 때 사용한다. DELETE : 서버의 자원을 삭제하고자 할 때 사용한다.(Delete: 자원을 삭제) 위 4가지(GET/POST/PUT/DELETE)를 이용해서 CRUD를 구현할 수 있다. 표현(Representation) 표현(Representation)은 자원에 대한 행위의 내용을 말하는데, 이때 내용은 서버에 요청할 때 무엇인가를 새로 생성하거나, 변경할 때 필요한 내용을 말한다. 이때, HTTP Message인 payload를 사용한다. 서버 자원에 무언가 새로운 것을 생성할 때, HTTP Method 중 POST와 함께 payload를 같이 요청한다. 예를 들어, 사용자들에 대한 정보가 있는 users에 새로운 사용자 정보를 생성하고 싶다면, 이 새로운 사용자에 대한 정보를 새로 만들어서 추가해줘야 하는데, 이것을 payload라고 한다. 1234567POST http://localhost:4000/users/&#123; &quot;id&quot;: 1, &quot;name: &quot;Ro&quot;, &quot;country&quot;: &quot;Korea&quot;&#125; 위 객체를 payload라고 하는데, 위 자원(http://localhost:4000/users/) 에 POST 방식으로 위 payload(객체)와 함께 서버에 요청을 해야한다. REST API 중심 규칙 위와 같은 내용을 잘 정리한 것이 REST API 중심 규칙이다.REST한 API를 설계하기 위한 중심 규칙은 대표적으로 2가지이다. 1. URI는 정보의 자원을 표현해야 한다. URI는 정보의 자원을 표현하는데 중점을 두어야 하기 때문에, 어떤 행위를 나타내는 동사보다는 자원의 의미를 명확히 전달하기 위해 명사를 사용해야 한다. id가 1인 사용자에 대한 자원을 얻고 싶다면, 다음과 같이 작성해야 한다. 1GET /users/1 행위를 나타내는 다음과 같은 URI는 잘못된 방법이다. 12GET /getUsers/1GET /users/show/1 2. 자원에 대한 행위는 HTTP Method로 표현한다. 1DELETE /users/1 REST API Architecture REST API는 자원과 메서드만 보고 요청의 내용을 명확하게 알 수 있다는 것이 장점이다. 이런 REST API의 Architecture를 보면 다음과 같다. 출처: REST API Architecture 어떤 클라이언트(웹브라우저/안드로이드 앱/ios 앱)에서 서버에 요청을 할 때 HTTP 통신을 하고, HTTP Method를 사용하여 원하는 행위를 하여 서버로부터 응답을 받는다. REST API 사용 예제 Ajax를 사용하여 REST API를 어떻게 사용하는지 알아보자. 사용자에 대한 정보인 users 데이터는 다음과 같다고 해보자. 123456789101112131415161718192021222324&#123; &quot;users&quot;: [ &#123; &quot;id&quot;: 1, &quot;name&quot;: &quot;Ro&quot;, &quot;country&quot;: &quot;Korea&quot; &#125;, &#123; &quot;id&quot;: 2, &quot;name&quot;: &quot;John&quot;, &quot;country&quot;: &quot;Canada&quot; &#125;, &#123; &quot;id&quot;: 3, &quot;name&quot;: &quot;Doh&quot;, &quot;country&quot;: &quot;China&quot; &#125;, &#123; &quot;id&quot;: 4, &quot;name&quot;: &quot;Hitaro&quot;, &quot;country&quot;: &quot;Japan&quot; &#125; ]&#125; 1. GET 1-1. users 자원에서 모든 사용자의 정보를 가져온다.(모든 사용자)1GET http://localhost:4000/users 위와 같이 users에 대한 자원을 GET하게 되면 다음과 같이 모든 users에 대한 정보를 가져올 수 있다. 12345678910111213141516171819202122[ &#123; &quot;id&quot;: 1, &quot;name&quot;: &quot;Ro&quot;, &quot;country&quot;: &quot;Korea&quot; &#125;, &#123; &quot;id&quot;: 2, &quot;name&quot;: &quot;John&quot;, &quot;country&quot;: &quot;Canada&quot; &#125;, &#123; &quot;id&quot;: 3, &quot;name&quot;: &quot;Doh&quot;, &quot;country&quot;: &quot;China&quot; &#125;, &#123; &quot;id&quot;: 4, &quot;name&quot;: &quot;Hitaro&quot;, &quot;country&quot;: &quot;Japan&quot; &#125; ] 이것을 코드로 작성하면 다음과 같다. 12345678910111213var req = new XMLHttpRequest();req.open(&apos;GET&apos;, &apos;http://localhost:4000/users&apos;);req.send();req.onreadystatechange = function (e) &#123; if (req.readyState === XMLHttpRequest.DONE) &#123; if(req.status === 200) &#123; console.log(req.responseText); &#125; else &#123; console.log(&quot;Error!&quot;); &#125; &#125;&#125;; 1-2. users 자원에서 id가 1인 사용자의 정보를 가져온다.(특정 사용자)1GET http://localhost:4000/users/1 위와 같이 users 자원에서 id가 1인 사용자에 대한 자원을 GET하게 되면 다음과 같이 id가 1인 사용자에 대한 정보를 가져올 수 있다. 12345&#123; &quot;id&quot;: 1, &quot;name&quot;: &quot;Ro&quot;, &quot;country&quot;: &quot;Korea&quot;&#125; 이것을 코드로 작성하면 다음과 같다. 12345678910111213var req = new XMLHttpRequest();req.open(&apos;GET&apos;, &apos;http://localhost:4000/users/1&apos;);req.send();req.onreadystatechange = function (e) &#123; if (req.readyState === XMLHttpRequest.DONE) &#123; if(req.status === 200) &#123; console.log(req.responseText); &#125; else &#123; console.log(&quot;Error!&quot;); &#125; &#125;&#125;; 2. POSTusers 자원에 새로운 사용자의 정보를 생성한다.123POST http://localhost:4000/users&quot;Content-Type: application/json&quot;&apos;&#123;&quot;name&quot;: &quot;donald&quot;, &quot;country&quot;: &quot;United States&quot;&#125;&apos; 새로운 사용자의 정보를 생성하기 위해서는 payload가 필요하며, 위와 같이 Content-Type 등을 추가로 작성해야 한다. 12345&#123; &quot;name&quot;: &quot;donald&quot;, &quot;country&quot;: &quot;United States&quot;, &quot;id&quot;: 5&#125; 이것을 코드로 작성하면 다음과 같다. 1234567891011121314151617var req = new XMLHttpRequest();req.open(&apos;POST&apos;, &apos;http://localhost:4000/users&apos;);req.setRequestHeader(&apos;Content-type&apos;, &apos;application/json&apos;);req.send(JSON.stringify(&#123; name: &quot;donald&quot;, country: &quot;United States&quot;&#125;));req.onreadystatechange = function (e) &#123; if (req.readyState === XMLHttpRequest.DONE) &#123; if(req.status === 201) &#123; console.log(req.responseText); &#125; else &#123; console.log(&quot;Error!&quot;); &#125; &#125;&#125;; 3. PUTusers 자원에서 새로 추가된 name을 jack으로 변경한다.123PUT http://localhost:4000/users/5&quot;Content-Type: application/json&quot;&apos;&#123;&quot;name&quot;: &quot;jack&quot;, &quot;country&quot;: &quot;United States&quot;&#125;&apos; PUT은 특정 id에 대한 어떤 정보를 변경할 때, payload에 모든 정보를 포함해서 보내준다. 12345&#123; &quot;name&quot;: &quot;jack&quot;, &quot;country&quot;: &quot;United States&quot;, &quot;id&quot;: 5&#125; 이것을 코드로 작성하면 다음과 같다. 1234567891011121314151617var req = new XMLHttpRequest();req.open(&apos;PUT&apos;, &apos;http://localhost:4000/users/5&apos;);req.setRequestHeader(&apos;Content-type&apos;, &apos;application/json&apos;);req.send(JSON.stringify(&#123; name: &apos;jack&apos;, country: &quot;United States&quot;&#125;));req.onreadystatechange = function (e) &#123; if (req.readyState === XMLHttpRequest.DONE) &#123; if(req.status === 200) &#123; console.log(req.responseText); &#125; else &#123; console.log(&quot;Error!&quot;); &#125; &#125;&#125;; 4. DELETEusers 자원에서 id가 5인 사용자를 삭제한다.1DELETE http://localhost:4000/users/5 사용자의 id까지 포함해서 DELETE 해야한다. 1&#123;&#125; 이것을 코드로 작성하면 다음과 같다. 12345678910111213var req = new XMLHttpRequest();req.open(&apos;DELETE&apos;, &apos;http://localhost:4000/users/5&apos;);req.send();req.onreadystatechange = function (e) &#123; if (req.readyState === XMLHttpRequest.DONE) &#123; if(req.status === 200) &#123; console.log(req.responseText); &#125; else &#123; console.log(&quot;Error!&quot;); &#125; &#125;&#125;;","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://cheonmro.github.io/categories/Javascript/"}],"tags":[{"name":"REST API","slug":"REST-API","permalink":"https://cheonmro.github.io/tags/REST-API/"}]},{"title":"트랜스파일링을 위한 typescript 개발환경 구축 방법","slug":"typescript-compiler","date":"2018-08-08T06:19:55.000Z","updated":"2018-08-08T06:19:55.741Z","comments":true,"path":"2018/08/08/typescript-compiler/","link":"","permalink":"https://cheonmro.github.io/2018/08/08/typescript-compiler/","excerpt":"","text":"Typescript와 트랜스파일링 자바스크립트의 문제점을 보완하기 위해 typescript을 사용한다. 그러나, typescript으로 작성한 파일은 브라우저에서 동작하지 않는다. 따라서, typescript로 작성한 파일을 자바스크립트로 변환해야 하는데, 이를 트랜스파일링 또는 컴파일이라고 한다. 트랜스파일링을 하기 위해서는 typescript 컴파일러를 설치하여 사용하는 typescript 개발환경을 구축해야한다. typescript 컴파일러 설치 방법 다음과 같이 typescript를 전역에 설치한다.1npm install -g typescript 설치가 완료되면, typescript의 버전 체크를 하여, typescript 컴파일러 설치가 제대로 되었는지 확인한다.1tsc -v typescript 컴파일러로 트랜스파일링 하기 typescript로 작성된 파일(.ts)을 자바스크립트 파일로 트랜스파일링 하기 위해서는, 위에서 설치한 typescript 컴파일러(tsc)를 사용한다. 1개의 파일 트랜스파일링 하기 아래의 코드를 작성하고, 확장자를 .ts로 하는 typescript 파일로 만든다.1234567891011121314class Cafe &#123; private name: string; constructor(name: string) &#123; this.name = name; &#125; greeting() &#123; return &quot;Welcome to&quot; + this.name; &#125;&#125;const cafe = new Cafe(&apos;Starbucks&apos;);console.log(cafe.greeting()); 위 typescript 파일을 트랜스파일링하여 자바스크립트로 만들기 위해서는 아래의 명령어를 작성하면 된다.1tsc cafe tsc 다음에 위 파일(cafe.ts)의 이름(cafe)을 입력하면 된다. 그러면, 트랜스파일링이 되어, 또 하나의 자바스크립트 파일이 생성된다.1234567891011121314&quot;use strict&quot;;exports.__esModule = true;var Cafe = /** @class */ (function () &#123; function Cafe(name) &#123; this.name = name; &#125; Cafe.prototype.greeting = function () &#123; return &quot;Welcome to&quot; + this.name; &#125;; return Cafe;&#125;());exports.Cafe = Cafe;var cafe = new Cafe(&apos;Starbucks&apos;);console.log(cafe.greeting()); 그런데, 트랜스파일링된 자바스크립트 파일은 ES3 버전으로 생성되는데, 이는 트랜스파일링해서 생성되는 기본 버전이 ES3이기 때문이다. target 컴파일 옵션을 사용해서 원하는 버전으로 트랜스파일링 하기 만약 원하는 버전으로 트랜스파일링 하고 싶다면, typescript 컴파일 옵션중 –target또는 -t를 사용하면 된다.1tsc cafe -t es6 ES6 버전은 아래와 같이 나온다.12345678910class Cafe &#123; constructor(name) &#123; this.name = name; &#125; greeting() &#123; return &quot;Welcome to&quot; + this.name; &#125;&#125;const cafe = new Cafe(&apos;Starbucks&apos;);console.log(cafe.greeting()); 그러면, 처음에 생성된 ES3 버전의 자바스크립트 파일이 ES6 버전의 자바스크립트 파일로 코드의 내용이 변경된다. 2개의 파일 트랜스파일링 하기 2개의 typescript 파일을 작성하여, 트랜스파일링을 해보자.123456789101112131415// cafe.tsexport class Cafe &#123; protected name: string; constructor(name: string) &#123; this.name = name; &#125; greeting() &#123; return &quot;Welcome to&quot; + this.name; &#125;&#125;const cafe = new Cafe(&apos;Starbucks&apos;);console.log(cafe.greeting()); 123456789101112// bakery.tsimport &#123; Cafe &#125; from &apos;./cafe&apos;;class Bakery extends Cafe &#123; bake(): string &#123; return `$&#123;this.name&#125; is baking bread. Wow!!`; &#125;&#125;const bakery = new Bakery(&apos;Starbucks&apos;);console.log(bakery.greeting());console.log(bakery.bake()); 위 두개의 typescript 파일들을 트랜스파일링 하기 위한 명령어를 작성하면 된다.1tsc cafe bakery 그러면, 두개의 typescript 파일들이 두개의 자바스크립트 파일로 트랜스파일링 된다. 3개 이상의 파일 트랜스파일링 하기 3개 이상의 모든 typescript 파일들을 한번에 트랜스파일링 하기위해서는 와일드카드(*)를 사용해야 한다.1tsc *.ts 자동으로 트랜스파일링 하기 typescript 컴파일 옵션 중 —watch 또는 -w 를 사용하면, 파일의 내용이 변경되었을 때, 이를 감지하여 자동으로 그 파일이 트랜스파일링 된다.1tsc bakery —watch","categories":[{"name":"typescript","slug":"typescript","permalink":"https://cheonmro.github.io/categories/typescript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://cheonmro.github.io/tags/typescript/"},{"name":"typescript compiler","slug":"typescript-compiler","permalink":"https://cheonmro.github.io/tags/typescript-compiler/"}]},{"title":"typescript란 무엇인가?","slug":"what-is-typescript","date":"2018-08-07T13:36:53.000Z","updated":"2018-08-28T11:45:51.125Z","comments":true,"path":"2018/08/07/what-is-typescript/","link":"","permalink":"https://cheonmro.github.io/2018/08/07/what-is-typescript/","excerpt":"","text":"typescript란 무엇인가? typescript는 자바스크립트에서 좀 더 확장된 언어로, 자바스크립트의 문법을 포함하면서 자바스크립트가 가지고 있는 문제를 보완하기 위한 문법을 가진 언어이다. 2012년에 마이크로소프트에서 발표한 오픈소스로써, C#을 개발한 아네르스 하일스베르가 개발하였다. 위 그림과 같이, 타입스크립트는 ES5, ES6를 모두 포함하는 자바스크립트의 상위집합이기 때문에, 타입스크립트에서 기존의 자바스크립트 문법을 그대로 사용할 수 있다. 또한, 타입스크립트는 아직 ECMAScript 표준에 포함되지는 않았지만(2018년 7월 기준), ECMAScript의 업그레이드에 따른 새로운 기능(스펙)을 계속 추가하기 때문에, ECMAScript의 표준을 따라가는 것처럼 보인다. typescript를 왜 사용할까? C나 JAVA와 같은 C-family 언어와는 다른 자바스크립트만의 특성이 있다. 프로토타입 기반 객체지향 언어 스코프와 this 동적 타입 언어 이와 같은 특성들은 클래스 기반 객체지향 언어(C, JAVA 등)에 익숙한 개발자에게는 혼란스럽다.또한, 할당하는 값에 따라 타입이 바뀌는 문제도 있어, 꼭 타입 체크를 해줘야 하는 점도 있다. 이런 문제들을 보완하기 위해, 타입스크립트에는 클래스, 정적 타이핑 등이 포함되어있다. 자바스크립트의 프레임워크인 Angular는 주력 언어로 타입스크립트를 채용했기 때문에, Angular를 사용하는 개발자는 타입스크립트를 이해하는 것이 필수적이다. 즉, Angular는 타입스크립트 뿐만 아니라, 자바스크립트, Dart 등으로도 작성이 가능하지만, Angular 사이트에 나와있는 문서나 커뮤니티 활동에서도 가장 많이 사용되고 있어, Angular를 사용하고 싶다면 타입스크립트를 아는 것이 좋다.","categories":[{"name":"typescript","slug":"typescript","permalink":"https://cheonmro.github.io/categories/typescript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://cheonmro.github.io/tags/typescript/"}]},{"title":"hexo 블로그 포스트 작성 및 배포하는 방법","slug":"how-to-write-posts","date":"2018-08-05T15:37:33.000Z","updated":"2018-08-05T15:37:33.768Z","comments":true,"path":"2018/08/06/how-to-write-posts/","link":"","permalink":"https://cheonmro.github.io/2018/08/06/how-to-write-posts/","excerpt":"","text":"hexo 블로그에 포스트 작성 및 배포하는 방법 새 포스트 작성을 위한 글제목 명령어를 입력한다. 1hexo new option 글제목 이 명령어를 작성하게 되면, 글제목 폴더와 글제목.md 파일이 만들어진다.이미지는 글제목 폴더에서 관리하고, 글의 내용은 글제목.md 파일에서 관리한다.만약, 글제목 폴더가 만들어지지 않는다면, _config.yml에서 post_asset_folder: true를 추가하면 된다. 이때, option에는 ‘post’ 또는 ‘draft’가 올 수 있다. 만약 작성한 글을 바로 배포하려면 ‘post’라고 쓴다.1hexo new post 글제목 바로 배포하지 않고, 초안으로 보관만 하려고 할 때는 ‘draft’라고 쓴다.1hexo new draft 글제목 draft 글을 배포하기 위해서 _posts 폴더로 이동시킨다. ‘draft’를 사용하여 명령어를 입력하게 되면, source/_drafts 폴더에 저장된다.이 폴더에 저장이 되면, 배포 대상에서 제외되기 때문에, 원래 사용하던 ‘hexo server’로는 확인할 수 없고 ‘–draft’라는 옵션을 추가해여 로컬 서버에서 확인이 가능하다.1hexo server --draft 초안이 다 완성이 되어 배포를 하고 싶을 경우, 해당 파일과 폴더가 source/_posts 폴더에 있어야 한다.이때, 아래와 같은 명령어를 입력하면 해당 파일과 폴더과 source/_posts로 이동하게 된다.1hexo publish post 글제목 _posts 폴더에 있는 글을 블로그에 배포한다. 최종적으로, source/_posts안에 있는 모든 글들을 배포하기 위해 아래의 명령어를 입력한다.1hexo generate --deploy","categories":[{"name":"hexo","slug":"hexo","permalink":"https://cheonmro.github.io/categories/hexo/"}],"tags":[{"name":"hexo posts","slug":"hexo-posts","permalink":"https://cheonmro.github.io/tags/hexo-posts/"}]},{"title":"hexo를 이용해서 블로그를 설치하는 방법","slug":"how-to-setup-hexo","date":"2018-08-05T15:24:54.000Z","updated":"2018-08-05T15:24:54.154Z","comments":true,"path":"2018/08/06/how-to-setup-hexo/","link":"","permalink":"https://cheonmro.github.io/2018/08/06/how-to-setup-hexo/","excerpt":"","text":"hexo를 이용해서 블로그 설치하기 hexo 설치하기 hexo 설치하기 위해서는 기본적으로 설치해야할 것이 2가지가 있다. Node.js Git 위 2개를 설치했다면, 먼저 npm을 사용해서 hexo를 설치해야 한다.나같은 경우에는 git을 관리하는 dev 폴더안에서 설치했다.1npm install hexo-cli -g 본인이 원하는 이름(나의 경우: myblog)으로 hexo init을 하고, npm을 설치한다.123hexo init myblogcd myblognpm install hexo 서버를 통해 구축된 hexo 기본 사이트를 확인한다.1hexo server 위와 같이 따라서 설치하면 기본적인 hexo 블로그를 로컬 호스트로 구축을 할 수 있다. Github에서 제공하는 github.io로 사이트 구축하기 hexo 블로그를 사용하기 위해서는 깃헙에서 제공하는 블로그용 깃헙사이트가 필요하다. Github에서 블로그용으로 만들 repo를 생성한다.repo를 username.github.io 이런식으로 만들면 된다. 내 컴퓨터로 클론한다.나같은 경우 dev 폴더안에서 클론했다.1git clone https://github.com/cheonmro/cheonmro.github.io.git _config.yml에서 세팅하기 실제 사이트 url로 배포하기 위해 기본적인 세팅이 필요하다.세팅 관련해서는 항상 _config.yml에서 한다. 앞으로 hexo 블로그를 이용해서 작성할 모든 내용들을, 위에서 생성한 블로그용 깃헙에서 관리를 할 것이기 때문에, 아래와 같이 type에 git으로 하고, repository에 자신의 블로그용 깃헙 주소를 작성한다.1234deploy: type: git repository: https://github.com/cheonmro/cheonmro.github.io branch: master 구축한 사이트 배포하기 지금까지 구축한 hexo 블로그를 배포(deploy)한다.1hexo deploy 위 명령어를 실행하게 되면, 자동으로 commit, push가 되어, 깃헙과 웹사이트(블로그)에 파일들이 generate되어, 기본적인 사이트 구축이 완성되게 된다.(웹사이트 자체를 배포할 때 사용한다.) 위에서 구축한 사이트를 직접 확인한다.1https://cheonmro.github.io/ hexo 블로그의 테마를 바꾸는 방법 위와 같이, 기본적인 hexo 블로그 설치는 간단한다.기본적으로 themes 폴더안에 있는 landscape 테마를 바탕으로한 기본 사이트가 구축된다. hexo 블로그에서 테마를 바꾸고 싶을 때는, 원하는 테마를 themes 안에 가져오고, _config.yml에서 theme의 이름만 바꿔주면 된다. 원하는 테마를 themes 폴더안으로 git clone 한다.(나같은 경우는 hexo-theme-hipaper 테마를 사용했다.)1git clone https://github.com/iTimeTraveler/hexo-theme-hipaper.git _config.yml에서 theme 옆에 이름을 새로 변경할 테마의 이름으로 바꾼다.1theme: hexo-theme-hipaper 기존 테마를 지우고, 새로 변경할 테마로 바꾸려면, hexo 블로그를 다시 배포(deploy)해야한다.1hexo deploy 위와같이 하면, Github의 파일들이 새로 변경할 테마의 내용들로 바뀌고, 사이트 또한 새롭게 변경된다. 만약, “Deployer not found: git” 이라는 에러가 난다면, deployer를 설치하면 된다.1npm install hexo-deployer-git --save 그리고, 다시 배포한다.1hexo deploy","categories":[{"name":"hexo","slug":"hexo","permalink":"https://cheonmro.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://cheonmro.github.io/tags/hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-08-05T13:24:49.289Z","updated":"2018-08-05T13:24:49.289Z","comments":true,"path":"2018/08/05/hello-world/","link":"","permalink":"https://cheonmro.github.io/2018/08/05/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}