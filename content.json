{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"Cheon","url":"https://cheonmro.github.io"},"pages":[{"title":"About Me","date":"2018-08-28T11:57:15.000Z","updated":"2018-10-31T09:41:42.690Z","comments":true,"path":"about/index.html","permalink":"https://cheonmro.github.io/about/index.html","excerpt":"","text":"안녕하세요, 영향력있는 개발자 노천명입니다. Email: cheonmro@gmail.com About Projects #3. Banking System DApp 프로젝트 목표: Core 뱅킹 시스템 웹서비스 DApp 개발 기간: 2018.10.15 ~ 2018.10.19 기술 스택: Javascript, HTML, CSS, Web3.js, Meteor, Solidity 협업 방식: 프론트엔드 개발자 1명과 백엔드 개발자 3명 전반적인 기획 및 smart contract 기능은 공동으로 구현 프론트엔드는 1명이 웹서비스의 전반적인 UI 기능 구현 백엔드는 3명이 서버와 Geth로 트랜잭션 관리 및 구현 나의 역할: 입금 및 출금 기능을 smart contract로 구현 웹서비스의 전반적인 UI 기능 구현 web3.js를 이용해 Ethereum 클라이언트와 연동 구현 동영상 #1. Deposit &amp; Withdrawal #2. Transfer 기능구현 1. Deposit(입금) 목표 로그인한 사용자의 계좌에 입력한 금액만큼의 토큰을 입금하는 기능 구현 접근법 클라이언트: Deposit form에서 입력한 값(계좌주소와 토큰값)과 사용자 id를 받아서 서버에 요청 서버: web3를 이용해서 배포한 컨트랙트 중 Deposit 함수를 호출하고 서버에 변경된 내용 저장 Issues &amp; Solutions #1: 클라이언트 Issue: 입력한 값들을 변수로 선언하여, 서버에 요청해야하는데, Meteor에서 서버로 요청하는 방법을 모름 Solution: Meteor에서 서버로 요청하는 방법에 대한 Document를 먼저 이해한 후, 적용하여 성공하면, alert를 띄우는 방식으로 코드를 작성 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// deposit send buttonTemplate.deposit.events(&#123; // when clicking &apos;Deposit&apos; button &quot;click button[name=send-deposit]&quot; (evt,tmpl)&#123; console.log(&apos;clicked send deposit&apos;); /* 템플릿에서 데이터 가져오기 */ var tokenAmount = tmpl.find(&quot;input[type=number]&quot;).value; document.getElementById(&quot;amountToPay&quot;).innerHTML = &apos;Amount to Pay: &apos; + &apos;$&apos; + tokenAmount + &apos; USD&apos;; &#125;, // when clicking &apos;pay&apos; button &quot;click button[name=pay-deposit]&quot; (evt,tmpl)&#123; console.log(&apos;clicked despoit pay button&apos;); var infoa = &#123; userId: Session.get(&apos;userId&apos;), address: Session.get(&apos;address&apos;), amount: tmpl.find(&quot;input[type=number]&quot;).value &#125; console.log(tmpl.find(&quot;input[type=number]&quot;).value); Meteor.call(&apos;deposit&apos;, infoa, function(error, result)&#123; if (error) &#123; console.log(error); &#125; else &#123; // hide modal $(&apos;#depositModal&apos;) .on(&apos;hidden.bs.modal&apos;, function() &#123; FlowRouter.go(&apos;/accounts&apos;); &#125;) .modal(&apos;hide&apos;); if(result) &#123; console.log(&apos;deposit success&apos;); alert(&apos;depoist was successed!&apos;); &#125; else &#123; console.log(&apos;deposit failed&apos;); alert(&apos;deposit failed&apos;); &#125; &#125; &#125;); &#125;&#125;); #2: 서버 Issue: 컨트랙트에서 정의한 Deposit 함수를 호출하는 방법을 모름. Solution: web3 Docs와 구글링을 통해 배포한 컨트랙트를 호출하는 방법을 찾아 코드를 작성 Code: 123456789101112131415161718192021222324Meteor.methods(&#123; &apos;deposit&apos; : function(infoa) &#123; var userId = infoa.userId; var address = infoa.address; var amount = infoa.amount; if(web3.personal.unlockAccount(bankAddress, bankKey) == true)&#123; if(bankContract.deposit(address, amount, &#123;from: bankAddress, gas: 3000000&#125;)) &#123; var fromAccount = Accounts.findOne(&#123;address: address&#125;); var fromBalance = fromAccount.balance; fromBalance = Number(fromBalance) + Number(amount); Accounts.update(fromAccount, &#123;$set: &#123;balance: fromBalance&#125;&#125;); return true; &#125; else return false; &#125; else return false;&#125;); 2. Modal UI 목표 입금 및 출금 기능이 작동할 때, Modal을 띄워 진행하는 기능 구현 접근법 Bootstrap Modal 코드를 사용하여 Deposit 버튼 클릭시, Modal을 띄우기 Issues &amp; Solutions Issue: Modal은 띄웠으나, Deposit 기능이 모두 수행된 후에도, 여전히 focus가 Modal에 가 있어서, 다른 화면의 기능들을 사용할 수가 없게됨. Solution: modal의 ‘hide’ 기능을 하는 코드를 추가하여, modal을 숨기게 하여, 이동된 화면에 focus가 가게함. Code: 123456// hide modal $(&apos;#depositModal&apos;) .on(&apos;hidden.bs.modal&apos;, function() &#123; FlowRouter.go(&apos;/accounts&apos;); &#125;) .modal(&apos;hide&apos;); 3. Smart Contract for Deposit &amp; Withdrawal 목표 스마트 컨트랙트의 기능 중 입금 및 출금에 대한 컨트랙트 함수 기능 구현 접근법 입금 또는 출금되는 토큰의 값이 현재 가지고 있는 토큰의 양보다 적을 경우에만 적용되는 코드를 작성 만약 위 내용이 true이면, 입금 또는 출금되는 계좌의 토큰에서 +-를 하고, 전체 계좌(운영자 계좌)에서 토큰의 양이 +-되는 방식으로 코드를 작성 Issues &amp; Solutions Issue: payable의 사용여부에 대해 불확실함 Solution: 돈을 받거나 보내는 함수를 작성할 때는 항상 payable가 필요함. Code: 1234567891011121314151617181920212223// depositfunction deposit(address _from, uint256 _amount) payable returns (bool) &#123; if(balances[bankAddress] &gt;= _amount) &#123; balances[bankAddress] -= _amount; balances[_from] += _amount; return true; &#125; else &#123; return false; &#125;&#125;// withdrawfunction withdraw(address _from, uint256 _amount) payable returns (bool)&#123; //require(balances[msg.sender] &gt;= _amount); if(balances[_from] &gt;= _amount) &#123; balances[bankAddress] += _amount; balances[_from] -= _amount; return true; &#125; else &#123; return false; &#125;&#125; #2. CryptoCurrency History Chart 프로젝트 목표: Top 100개의 암호화폐의 가격을 쉽게 볼 수 있는 차트 페이지 개발(개인 프로젝트) 기간: 2018.09.24 ~ 2018.09.28 기술 스택: Angular, Typescript, Javascript, CSS, HTML 핵심 기능: 암호화폐 시가총액 및 가격 랭킹 테이블 암호화폐의 가격 차트 각 암호화폐의 기간별 가격 차트 활용한 라이브러리 및 API: coincap.io, chart.js 동영상 기능구현 1. 암호화폐 랭킹 테이블 목표 Top 100개의 암호화폐 시가총액 및 가격을 랭킹별로 보여주는 테이블 기능 구현 각 암호화폐를 클릭하면, 클릭한 암호화폐의 가격 차트를 보여주는 기능 구현 접근법 coincap.io API에서 모든 암호화폐에 대한 시가총액 및 가격을 가져옴. 암호화폐 랭킹 테이블에서 어떤 암호화폐를 클릭시, 클릭한 암호화폐에 대한 가격 차트를 보여주기 위해, coincap.io에서 각 암호화폐에 맞는 API를 가져와 사용 Issues &amp; Solutions #1 Issue: 암호화페 랭킹 테이블에서 어떤 암호화폐를 처음 클릭시, 처음에는 차트가 표시가 안된다. Solution: 원인은 httpclient로 서버에 요청을 보낼 때, 비동기이기 때문에 다른 코드가 먼저 실행된다. 그래서 서버에서 데이터를 받기 전에 차트가 표현되는 함수가 호출되어, 날짜(this.dates)가 undefined로 나타나게 되었기 때문에, 차트가 만들어지지 않게 되었다. 이를 해결하기 위해, httpclient에 subscribe안에서, 함수를 바로 호출하여 dates, prices 등을 가져왔고, 그럼으로써 dates가 만들어져 차트가 나타나게 구현되었다. Code: 12345678910111213141516171819202122232425262728293031323334353637383940// get a chart from api of coin clickedgetCoinChart() &#123; this.http.get(`http://coincap.io/history/$&#123;this.coinSymbol&#125;`).subscribe(element =&gt; &#123; this.convertDates(element); this.convertPrices(element); this.coinChart(this.coinName); &#125;, error =&gt; &#123; console.log(&apos;can\\&apos;t get all days data&apos;); &#125; );&#125;&lt;!-- dates가 있어야 차트가 나타난다. --&gt;// show a chart of the coin clicked after clicking the coin in the ranking tablecoinChart(crytoName: string) &#123; if (this.dates) &#123; // -- coin chart starts -- this.type = &apos;line&apos;; this.chartData = &#123; labels: [...this.dates], // ...this.dates datasets: [ &#123; label: `$&#123;crytoName&#125; price`, data: [...this.prices], // ...this.prices borderColor: &apos;rgb(255, 99, 132)&apos; &#125; ] &#125;; this.options = &#123; responsive: true, maintainAspectRatio: false, &#125;; // -- coin chart ends -- &#125; // if (this.dates)&#125; #2 Issue: 시가총액 및 가격에 대한 날짜 데이터를 가져왔지만, 날짜 형태가 아닌 숫자로 나와 있었음. Solution: 사람이 알아볼 수 있는 날짜 형태로 전환하기 위해, new Date()를 생성하고, Date 함수의 메소드를 이용해서 숫자를 날짜 형태로 전환함. Code: 123456convertDates(data: any) &#123; this.dates = data.price.map(element =&gt; &#123; const eachDate = new Date(element[0]); return `$&#123;eachDate.getFullYear()&#125;/$&#123;eachDate.getMonth()&#125;/$&#123;eachDate.getDay()&#125;`; &#125;);&#125; 2. 암호화폐 가격 차트 목표 암호화폐별, 그리고 각 암호화폐의 history를 보여줄 수 있는 기간별 기능 구현 접근법 chart.js 라이브러리를 활용하여 기간에 따른 가격을 보여주는 차트 기능 구현 Issues &amp; Solutions #1 Issue: 차트 라이브러리는 처음 사용해봐서 어떻게 사용해야 하는지 잘 몰랐음. Solution: chart.js docs를 보면서 최대한 간단한 차트 예제를 활용하여 적용함. Code: 12345678910111213141516171819202122232425coinChart(crytoName: string) &#123; if (this.dates) &#123; // -- coin chart starts -- this.type = &apos;line&apos;; this.chartData = &#123; labels: [...this.dates], // ...this.dates datasets: [ &#123; label: `$&#123;crytoName&#125; price`, data: [...this.prices], // ...this.prices borderColor: &apos;rgb(255, 99, 132)&apos; &#125; ] &#125;; this.options = &#123; responsive: true, maintainAspectRatio: false, &#125;; // -- coin chart ends -- &#125;&#125; #1. 야놀자 펜션 클론 프로젝트 목표: 야놀자 펜션 웹사이트의 핵심 기능 위주로 MVP 개발 기간: 2018.07.30 ~ 2018.08.23 기술 스택: Angular, Typescript, Javascript, CSS, HTML 협업 방식: 프론트엔드 개발자 3명과 백엔드 개발자 3명 프론트엔드 개발자끼리는 핵심 기능을 역할분담하여 정해진 각 기간에 따라 각자 구현하고 코드를 Git으로 합치면서 진행 백엔드 개발자와는 데이터를 서버와 잘 주고 받기 위해 협업하면서 진행 나의 역할: 야놀자 펜션의 펜션 룸을 예약하는 예약페이지 및 결제 방식에 따라 결제하는 결제페이지 구현 동영상 기능구현(예약페이지 &amp; 결제페이지) 1. Calendar 목표 오늘 날짜를 기준으로 이미 지난 날짜들은 Calendar에서 선택을 못하게 하는 기능 구현 선택한 날짜에 따라 그 날짜에 해당하는 펜션 룸 Table 정보를 보여줌으로써, 각 날짜의 각 펜션 룸들의 예약상태가 ‘예약가능’인지 ‘예약완료’인지 알 수 있게 하는 기능 구현 접근법 Angular Bootstrap에서 Datepicker API를 가져와 사용 Datepicker API “markDisabled” 문법에 따라, Calendar에 있는 모든 날짜와 오늘 날짜를 비교해서 오늘 보다 이전 날짜들에 대해 Calendar에서 선택을 못하게 하는 코드 작성 Calendar에서 날짜를 선택할 때마다, 함수를 호출하여 함수안에 매개변수를 선택한 날짜로 줘서, 그 선택한 날짜를 url로 서버에 요청하여 펜션 룸 Table에 펜션의 룸들의 예약상태를 그 선택한 날짜에 맞게 예약페이지에 보여주는 코드 작성 Issues &amp; Solutions #1 Issue: Datepicker API를 어떤식으로 가져와서 사용해야 할지 감이 안잡힘 Solution: Datepicker API 사이트의 어떤 1개의 Example Calendar를 그대로 가져와 그 Example에서 사용된 코드를 Datepicker API 문법을 보면서 전반적으로 이해하려고 노력하면서 감을 잡음 #2 Issue: Calendar에 있는 모든 날짜와 오늘 날짜를 비교하기 위해 Date 함수를 가지고 어떻게 날짜를 비교해야하는지 판단이 어려움 Solution: 처음에는 날짜의 year/month/day를 하나씩 비교해가면서 작성했으나 코드의 양이 너무 많아짐. 그래서 좀 더 간단히 비교할 수 있는 방법을 찾기 위해 Date 함수의 메소드를 찾다가 getTime() 메소드를 알게됨. 즉, 날짜를 비교할 때, milliseconds의 총합으로 비교하면 간단히 날짜를 비교할 수 있다는 것을 알게되어 이 메소드를 코드에 적용해서 해결함. Code: 12345678910111213141516171819// HTML// Use markDisabled in Datepicker&lt;ngb-datepicker #dp (select)=&quot;changeDate.emit($event)&quot; class=&quot;date-picker&quot; [firstDayOfWeek]=&quot;firstDayOfWeek&quot; [markDisabled]=&quot;isDisabled&quot; [dayTemplate]=&quot;t&quot;&gt;&lt;/ngb-datepicker&gt;// Javascript// Disable the dates bofre today &amp; the months that are NOT current monthisDisabled(date: NgbDateStruct, current: &#123;month: number&#125;) &#123; const eachDate = new Date(date.year, date.month - 1, date.day + 1); const todayDate = new Date().getTime(); return eachDate.getTime() &lt; todayDate || date.month !== current.month;&#125; #3 Issue: 선택한 날짜를 가지고 어떻게 url을 만들어서 서버와 통신할지에 대한 고민 Solution: 선택한 날짜의 year/month/day로 문자열을 만들어서 http client를 사용해 url로 코드를 작성 Code: 12345678910111213141516171819// HTML// Use event binding to get the date selected from calendar&lt;app-yapen-calendar(changeDate)=&quot;onDateSelection($event)&quot;[selectedDate]=&quot;selectedDate&quot;&gt;&lt;/app-yapen-calendar&gt;// Javascript// when selecting a date, change to the date selected and to room statusonDateSelection(date: NgbDateStruct) &#123; this.selectedDate = date; this.checkInDate = date; const calendarSelectedDate = `$&#123;date.year&#125;-$&#123;date.month&#125;-$&#123;date.day&#125;`; this.http.get&lt;Pension&gt;(`$&#123;this.urlDate&#125;/$&#123;this.pensionPk&#125;/$&#123;calendarSelectedDate&#125;/`) .subscribe(pension =&gt; this.rooms = pension.rooms);&#125; 배운점 개발할 때, 밑바닥부터 모든 것을 코딩하는 것이 아닌 필요한 기능들에 대한 API를 찾아보고, 실제로 어떻게 적용하는 것인지를 경험함. Date 함수를 이용해 날짜를 비교하는 방법을 알게됨. 서버와 어떻게 통신하여 데이터를 화면에 보여주는 방법을 알게됨. 2. 펜션 룸 Table 목표 선택한 펜션 룸에서 선택한 기간에 맞춰 전체 가격이 변경되는 기능 구현 성인, 아동, 유아의 총 인원수가 선택한 방의 최대 인원수보다 많을 경우 경고창을 보내는 기능 구현 추가되는 성인, 아동, 유아의 인원수마다 전체 가격이 추가되는 기능 구현 접근법 기간을 선택할 수 있는 select 박스에 선택한 기간을 값으로 하는 매개변수로 하는 함수를 호출하여 전체 가격을 계산하는 코드 작성 성인, 아동, 유아의 인원수를 선택할 수 있는 select 박스에 선택한 인원수를 값으로 하는 매개변수로 하는 함수를 호출한 후, 성인, 아동, 유아의 인원수의 총합과 선택한 방의 최대 인원수와 비교하는 코드를 작성 성인, 아동, 유아의 인원수를 선택할 수 있는 select 박스에서 선택한 인원수와 각 성인, 아동, 유아 추가 금액(extra charge)을 계산하여 전체 가격에 더해서 총 가격을 보여주는 코드 작성 Issues &amp; Solutions #1 Issue: 선택한 기간의 값은 함수의 매개변수로 전달받았으나, 모든 룸이 아닌 사용자가 선택한 펜션 룸만의 기본 가격을 어떻게 가져와야 하는지 고민 Solution: 모든 펜션 룸의 pk 중에서 선택한 룸의 pk와 같은 룸만을 filter하여 그 룸의 가격을 찾게 하도록 코드를 작성 Code: 123456789101112131415161718192021222324// HTML&lt;!-- for period --&gt;&lt;div class=&quot;stay-div&quot;&gt; &lt;select class=&quot;stay-select&quot; [attr.id]=&quot;room.pk&quot; class=&quot;selectStayBox&quot; [disabled]=&quot;!(room.pk===checkedPk)&quot; [class.disabled-select]=&quot;!(room.pk===checkedPk)&quot; (change)=&quot;selectPeriod($event.target.value)&quot; #selectStayNum&gt; &lt;ng-container *range=&quot;[1, 6] let stayNum;&quot;&gt; &lt;option [value]=&quot;stayNum&quot;&gt;&#123;&#123; stayNum &#125;&#125;박&lt;/option&gt; &lt;/ng-container&gt; &lt;/select&gt;&lt;/div&gt;&lt;!-- for period --&gt;// Javascript// When selecting a period(1박)selectPeriod(selectedStayNum: number) &#123; this.stayDayNum = selectedStayNum; const checkedRoom = this.rooms.filter(room =&gt; room.pk === this.checkedPk)[0]; this.totalPrice = checkedRoom.price * this.stayDayNum;&#125; 배운점 select 박스 등의 HTML에서 이벤트 바인딩을 통해 값을 전달하여 변경된 값을 화면에 보여주는 코드를 작성하는 방법을 배움. 3. 결제 Form 목표 예약자 정보 및 선택한 결제 방식(신용카드/무통장)에 맞는 결제 정보를 입력하는 폼 기능 구현 예약자 정보 및 각 결제 정보에 대한 유효성 검증을 하여, 맞지 않게 입력되면, 경고를 주는 폼 에러처리 기능 구현 접근법 Angular에서 제공하는 폼을 이용해서 폼 및 폼 에러처리 기능 코드 작성 Issues &amp; Solutions #1 Issue: Angular에서 제공하는 폼에 대한 이해 및 사용법을 숙지하는데 시간이 걸림 Solution: 한번에 모든 결제 정보의 에러처리 기능을 테스트하기 보다, 하나씩 결제 정보의 에러 기능을 테스트하며 구현함. Code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// HTML&lt;!-- 예약자 이름 --&gt;&lt;tr&gt; &lt;th scope=&quot;row&quot;&gt;예약자 이름&lt;/th&gt; &lt;td&gt; &lt;span&gt; &lt;input type=&quot;text&quot; formControlName=&quot;userName&quot; [style.border-color]=&quot;(isEmptyName ? &apos;rgb(255, 101, 89)&apos; : &apos;&apos;)&quot; #inputUserName&gt; &lt;span class=&quot;help&quot;&gt;예) 홍길동&lt;/span&gt; &lt;/span&gt; &lt;/td&gt;&lt;/tr&gt;&lt;!-- 예약자 이름 --&gt;&lt;!-- 휴대폰번호 --&gt;&lt;tr&gt; &lt;th scope=&quot;row&quot;&gt;휴대폰번호&lt;/th&gt; &lt;td&gt; &lt;span&gt; &lt;input type=&quot;text&quot; formControlName=&quot;userPhone&quot; [style.border-color]=&quot;(isEmptyPhone ? &apos;rgb(255, 101, 89)&apos; : &apos;&apos;)&quot; #inputUserPhone&gt; &lt;span class=&quot;empty-phone-number&quot; *ngIf=&quot;isEmptyPhone&quot;&gt; &#123;&#123; !inputUserPhone.value ? &apos;휴대폰번호가 입력되지 않았습니다.&apos; : &apos;휴대폰번호가 정확히 입력되지 않았습니다.&apos; &#125;&#125; &lt;/span&gt; &lt;span class=&quot;help&quot;&gt;예) 0101234567&lt;/span&gt; &lt;/span&gt; &lt;/td&gt;&lt;/tr&gt;&lt;!-- 휴대폰번호 --&gt;&lt;!-- pay button --&gt;&lt;div class=&quot;pay-btn&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary btn-lg&quot; (click)=&quot;userName.errors ? (userPhone.errors ? isDoubleEmpty() : isEmptyName = true) : (userPhone.errors ? isEmptyPhone = true : getUserInfo(inputUserName.value, inputUserPhone.value))&quot;&gt;결제하기&lt;/button&gt;&lt;/div&gt;&lt;!-- pay button --&gt;// Javascriptthis.userForm = this.fb.group(&#123; userName: [&apos;&apos;, Validators.required], userPhone: [&apos;&apos;, [ Validators.required, Validators.pattern(&apos;[0-9]&#123;11&#125;&apos;) ]]&#125;); 배운점 처음 사용해 보는 기능을 코드에 잘 적용하기 위해서는 사용하려는 기능에 대해 충분히 이해를 하고 하나씩 작은 단위로 테스트 해보면서 하는 것이 결국, 더 정확하게 빠르게 코딩을 할 수 있다는 것을 배움."},{"title":"categories","date":"2018-08-28T12:01:37.000Z","updated":"2018-08-28T12:02:33.051Z","comments":true,"path":"categories/index.html","permalink":"https://cheonmro.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-08-28T12:03:36.000Z","updated":"2018-08-28T12:03:49.565Z","comments":true,"path":"tags/index.html","permalink":"https://cheonmro.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"10. K번째 수(정렬)","slug":"k-number","date":"2018-11-05T11:05:03.000Z","updated":"2018-11-05T11:05:03.692Z","comments":true,"path":"2018/11/05/k-number/","link":"","permalink":"https://cheonmro.github.io/2018/11/05/k-number/","excerpt":"","text":"[Problem]배열 array의 i번째 숫자부터 j번째 숫자까지 자르고 정렬했을 때, k번째에 있는 수를 구하려 합니다. 예를 들어 array가 [1, 5, 2, 6, 3, 7, 4], i = 2, j = 5, k = 3이라면, array의 2번째부터 5번째까지 자르면 [5, 2, 6, 3]입니다. 1에서 나온 배열을 정렬하면 [2, 3, 5, 6]입니다. 2에서 나온 배열의 3번째 숫자는 5입니다. 배열 array, [i, j, k]를 원소로 가진 2차원 배열 commands가 매개변수로 주어질 때, commands의 모든 원소에 대해 앞서 설명한 연산을 적용했을 때 나온 결과를 배열에 담아 return 하도록 solution 함수를 작성하시오. [Algorithms] [Solution]123456789101112function solution(array, commands) &#123; let answer = []; for(let i = 0; i &lt; commands.length; i++) &#123; const sliceArray = array.slice(commands[i][0] - 1, commands[i][1]); // [ 5, 2, 6, 3 ] const sortedArray = sliceArray.sort((a, b) =&gt; &#123; return a - b &#125;); // [ 2, 3, 5, 6 ] const value = sortedArray[commands[i][2] - 1]; // 5 answer.push(value); &#125; return answer;&#125;console.log(solution([1, 5, 2, 6, 3, 7, 4], [[2, 5, 3], [4, 4, 1], [1, 7, 3]])); // [ 5, 6, 3 ]","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://cheonmro.github.io/categories/Algorithms/"}],"tags":[{"name":"sort algorithms","slug":"sort-algorithms","permalink":"https://cheonmro.github.io/tags/sort-algorithms/"}]},{"title":"9. 최대공약수와 최소공배수","slug":"gcd-lcm","date":"2018-11-05T08:37:39.000Z","updated":"2018-11-05T08:37:39.269Z","comments":true,"path":"2018/11/05/gcd-lcm/","link":"","permalink":"https://cheonmro.github.io/2018/11/05/gcd-lcm/","excerpt":"","text":"[Problem]두 수를 입력받아 두 수의 최대공약수와 최소공배수를 반환해주는 gcdlcm() 함수를 작성하시오. 예를 들어, 3과 12의 두 숫자의 최대공약수와 최소공배수를 비교한다고 해보자. 3의 약수는 1, 3이고, 12의 약수는 1, 2, 3, 4, 6, 12이다. 여기서, 최대공약수는 3이다. 3의 배수는 3, 6, 9, 12, 15, 18… 이다. 12의 배수는 12, 24, 36, 48… 이다. 여기서, 최소공배수는 12이다. [Algorithms] [Solution]123456789101112131415function gcdlcm(a, b) &#123; let gcd = 1, lcm = 1; const minNum = Math.min(a,b); // 두 숫자 중에서 작은 값을 찾아, 1부터 그 작은값까지 비교하면서, 두 숫자에 대한 공약수를 찾는다. for (let i = 1; i &lt;= minNum; i++) &#123; if ((a%i == 0) &amp;&amp; (b%i == 0)) &#123; gcd = i &#125; &#125;; // 최소공배수는 두 수의 곱에 최대공약수로 나눈 값이다. lcm = a*b/gcd; return [gcd, lcm]&#125;console.log(gcdlcm(3,12)); // [ 3, 12 ]","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://cheonmro.github.io/categories/Algorithms/"}],"tags":[{"name":"최대공약수","slug":"최대공약수","permalink":"https://cheonmro.github.io/tags/최대공약수/"},{"name":"최소공배수","slug":"최소공배수","permalink":"https://cheonmro.github.io/tags/최소공배수/"}]},{"title":"8. 두 정수 사이의 함","slug":"sum-two-integers","date":"2018-11-05T08:01:52.000Z","updated":"2018-11-05T08:01:52.691Z","comments":true,"path":"2018/11/05/sum-two-integers/","link":"","permalink":"https://cheonmro.github.io/2018/11/05/sum-two-integers/","excerpt":"","text":"[Problem]두 정수 a, b가 주어졌을 때, a와 b 사이에 속한 모든 정수의 합을 리턴하는 함수, sumInt() 함수를 작성하시오. [Algorithms] [Solution]12345678910111213141516171819202122function sumInt(a, b) &#123; let answer = 0; const sortNumber = (a, b) =&gt; &#123; return Array.prototype.slice.call(arguments).sort(function(a,b)&#123; return a - b; &#125;) &#125; const newArray = sortNumber(a, b); // [ 1, 5 ] if (newArray[0] === newArray[1]) &#123; answer = newArray[0]; &#125; else &#123; for (let i = newArray[0]; i &lt;= newArray[1]; i++)&#123; answer += i; &#125; &#125; return answer;&#125;console.log(sumInt(1, 5)); // 15 -&gt; sum of 1 ~ 5","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://cheonmro.github.io/categories/Algorithms/"}],"tags":[{"name":"Sum All Integers Between Two Integers","slug":"Sum-All-Integers-Between-Two-Integers","permalink":"https://cheonmro.github.io/tags/Sum-All-Integers-Between-Two-Integers/"}]},{"title":"7. 나누어 떨어지는 숫자 배열","slug":"divide-array","date":"2018-11-05T07:38:59.000Z","updated":"2018-11-05T07:38:59.906Z","comments":true,"path":"2018/11/05/divide-array/","link":"","permalink":"https://cheonmro.github.io/2018/11/05/divide-array/","excerpt":"","text":"[Problem]array의 각 element 중 divisor로 나누어 떨어지는 값을 오름차순으로 정렬한 배열을 반환하는 함수, solution을 작성하시오. [Algorithms] [Solution]12345678910111213141516171819const solution = (arr, divisor) =&gt; &#123; let answer = []; for (let i = 0; i &lt; arr.length; i++) &#123; if(arr[i]%divisor === 0) &#123; answer.push(arr[i]); &#125; &#125; if (typeof answer !== &apos;undefined&apos; &amp;&amp; answer.length &gt; 0) &#123; answer.sort((a, b) =&gt; &#123; return a - b; &#125;); &#125; else &#123; answer.push(-1); &#125; return answer;&#125;console.log(solution([6, 7, 10, 3, 12], 3)); // [ 3, 6, 12 ]console.log(solution([], 3)); // [ -1 ]","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://cheonmro.github.io/categories/Algorithms/"}],"tags":[{"name":"Divide Array","slug":"Divide-Array","permalink":"https://cheonmro.github.io/tags/Divide-Array/"}]},{"title":"6. 가운데 글자 가져오기","slug":"find-mid-character","date":"2018-11-05T07:28:01.000Z","updated":"2018-11-05T07:28:01.843Z","comments":true,"path":"2018/11/05/find-mid-character/","link":"","permalink":"https://cheonmro.github.io/2018/11/05/find-mid-character/","excerpt":"","text":"[Problem]단어 str의 가운데 글자를 반환하는 함수, solution을 작성하시오. 만약, 단어의 길이가 짝수라면 가운데 두글자를 반환하면 됩니다. [Algorithms] [Solution]1234567891011121314151617181920const solution = str =&gt; &#123; let answer = &apos;&apos;; const stringLen = str.length; const stringHalf = Math.floor(stringLen/2); let stringStart = &apos;&apos;; const stringEnd = stringHalf + 1; if (stringLen % 2 === 0) &#123; stringStart = stringHalf - 1; answer = str.substring(stringStart, stringEnd); &#125; else if (stringLen % 2 === 1) &#123; stringStart = stringHalf; answer = str.substring(stringStart, stringEnd); &#125; return answer;&#125;console.log(solution(&apos;names&apos;)); // mconsole.log(solution(&apos;name&apos;)); // am","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://cheonmro.github.io/categories/Algorithms/"}],"tags":[{"name":"Find Mid Character","slug":"Find-Mid-Character","permalink":"https://cheonmro.github.io/tags/Find-Mid-Character/"}]},{"title":"5. Harmless Ransom Note","slug":"ransom-note","date":"2018-11-05T06:49:03.000Z","updated":"2018-11-05T06:49:03.440Z","comments":true,"path":"2018/11/05/ransom-note/","link":"","permalink":"https://cheonmro.github.io/2018/11/05/ransom-note/","excerpt":"","text":"What is Harmless Ransom Note?FacHarmless Ransom Note란, 중복되는 문자열의 유무를 파악해서 true/false로 확인하는 것을 말한다. [Problem]2개의 문자열 중, 중복되는 문자열의 유무를 파악해서 true/false로 반환하는 함수를 작성하시오. 즉, 왼쪽 문자열의 각 단어들이 오른쪽 문자열에 1개라도 포함이 안되거나, 오른쪽 문자열의 각 동일한 단어보다 더 많을 경우, false를 반환한다. 예를 들어, 왼쪽 문자열이 ‘this is my my note’ 이고, 오른쪽 문자열이 ‘this is is my note’일 때, 왼쪽 문자열의 각 단어 중 my는 왼쪽 문자열에서 2번있는데, 오른쪽에서는 1번 밖에 없으면 false를 반환해야 한다. 또한, 왼쪽 문자열이 ‘this is my special note’ 이고, 오른쪽 문자열이 ‘this is is my note’일 때, 왼쪽 문자열의 special 단어는 오른쪽 문자열에 없어도, false를 반환해야 한다. [Algorithms] [Solution]1234567891011121314151617181920212223242526272829303132333435363738394041424344const harmlessRansomeNote = (noteText, magazineText) =&gt; &#123; //split both string parameters into arrays let noteArr = noteText.split(&apos; &apos;); let magArr = magazineText.split(&apos; &apos;); //create an object to use as a hash table it also avoids exponential time complexity of nested loops let magObj = &#123;&#125;; //forEach to check if word is an word is an object on our property magArr.forEach(word =&gt; &#123; //if not we add it to our object //increment the value if (!magObj[word]) &#123; magObj[word] = 1; &#125; else &#123; //otherwise, if it is there //we just increment the value magObj[word]++; &#125; &#125;); // &#123; this: 1, is: 2, my: 1, note: 1 &#125; //Boolean variable to be return from function let noteIsPossible = true; //use forEach to iterate through each word noteArr.forEach(word =&gt; &#123; //if word is found on the object decrement it if (magObj[word]) &#123; magObj[word]--; //if word value &lt; 0 we can&apos;t make our word so note is NOT possible. if (magObj[word] &lt; 0) &#123; noteIsPossible = false; &#125; //if word is not found then the note is NOT possible. &#125; else &#123; noteIsPossible = false; &#125; &#125;); return noteIsPossible;&#125;;console.log(harmlessRansomeNote(&apos;this is my note&apos;, &apos;this is is my note&apos;)); // true","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://cheonmro.github.io/categories/Algorithms/"}],"tags":[{"name":"Harmless Ransom Note","slug":"Harmless-Ransom-Note","permalink":"https://cheonmro.github.io/tags/Harmless-Ransom-Note/"}]},{"title":"4. Factorial","slug":"factorial","date":"2018-11-05T06:04:00.000Z","updated":"2018-11-05T06:04:00.293Z","comments":true,"path":"2018/11/05/factorial/","link":"","permalink":"https://cheonmro.github.io/2018/11/05/factorial/","excerpt":"","text":"What is Factorial?Factorial이란, 해당하는 수부터 그 이하로 1까지를 모두 곱하는 수를 말한다.예를 들어, 3!이면 3 x 2 x 1 = 6을 말한다. [Problem]Factorial을 구현하는 함수를 작성하시오. [Algorithms] number가 1일 경우, number를 반환한다. number가 2이상이면 number부터 1씩 값을 줄여가면서, 모두 곱한다. 곱한 최종 값을 반환한다. [Solution]1234567891011function factorial(number) &#123; if(number === 1) return number; let result = 1; for (var i = number; i &gt;= 1 ; --i ) &#123; result *= i; &#125; return result;&#125;console.log(factorial(5)); // 120 [Better Practice]123456789function factorial(number) &#123; if(number === 1) &#123; return number; &#125; else &#123; return number * factorial(number-1); &#125;&#125;console.log(factorial(5)); // 120","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://cheonmro.github.io/categories/Algorithms/"}],"tags":[{"name":"Factorial","slug":"Factorial","permalink":"https://cheonmro.github.io/tags/Factorial/"}]},{"title":"String Method","slug":"string-method","date":"2018-11-05T05:34:24.000Z","updated":"2018-11-05T05:34:25.004Z","comments":true,"path":"2018/11/05/string-method/","link":"","permalink":"https://cheonmro.github.io/2018/11/05/string-method/","excerpt":"","text":"1. String.prototype.charAt(index) 매개변수로 전달한 index 번호에 해당하는 위치의 문자를 반환한다. index 번호는 0 ~ (문자열 길이 - 1) 사이의 정수이다. 12345678910const str = &apos;Hello&apos;;console.log(str.charAt(0)); // Hconsole.log(str.charAt(1)); // econsole.log(str.charAt(2)); // lconsole.log(str.charAt(3)); // lconsole.log(str.charAt(4)); // o// 지정한 index가 범위(0 ~ str.length-1)를 벗어난 경우 빈문자열을 반환한다.console.log(str.charAt(5)); // &apos;&apos; 2. String.prototype.concat(index) 매개변수로 전달된 1개 이상의 문자열과 연결하여 새로운 문자열을 반환한다. concat 메소드를 사용하는 것보다는 +, += 할당 연산자를 사용하는 것이 성능상 유리하다. 12345let str = &apos;My name is &apos;;let name = &apos;Cheon&apos;;str = str.concat(name); // str = str + name;console.log(str); // &apos;My name is Cheon&apos; 3. String.prototype.split(string | regular Expression, number) 첫번째 인자에 전달된 문자열 또는 정규표현식을 대상 문자열에서 검색하여 문자열을 구분한 후, 분리된 각 문자열로 이루어진 배열을 반환한다. 원본 문자열은 변경되지 않는다. 인수가 없는 경우, 대상 문자열 전체를 단일 요소로 하는 배열을 반환한다. 12345678910111213141516171819202122232425let str = &apos;How are you doing?&apos;;// 공백으로 구분(단어로 구분)하여 배열로 반환한다let splitStr = str.split(&apos; &apos;);console.log(splitStr); // [ &apos;How&apos;, &apos;are&apos;, &apos;you&apos;, &apos;doing?&apos; ]// 원본 문자열은 변경되지 않는다console.log(str); // How are you doing?// 인수가 없는 경우, 대상 문자열 전체를 단일 요소로 하는 배열을 반환한다.splitStr = str.split();console.log(splitStr); // [ &apos;How are you doing?&apos; ]// 각 문자를 모두 분리한다splitStr = str.split(&apos;&apos;);console.log(splitStr); // [ &apos;H&apos;,&apos;o&apos;,&apos;w&apos;,&apos; &apos;,&apos;a&apos;,&apos;r&apos;,&apos;e&apos;,&apos; &apos;,&apos;y&apos;,&apos;o&apos;,&apos;u&apos;,&apos; &apos;,&apos;d&apos;,&apos;o&apos;,&apos;i&apos;,&apos;n&apos;,&apos;g&apos;,&apos;?&apos; ]// 공백으로 구분하여 배열로 반환한다. 단 요소수는 3개까지만 허용한다splitStr = str.split(&apos; &apos;, 3);console.log(splitStr); // [ &apos;How&apos;, &apos;are&apos;, &apos;you&apos; ]// &apos;o&apos;으로 구분하여 배열로 반환한다.splitStr = str.split(&apos;o&apos;);console.log(splitStr); // [ &apos;H&apos;, &apos;w are y&apos;, &apos;u d&apos;, &apos;ing?&apos; ] 4. String.prototype.substring(start, end) 첫번째 인자에 전달된 index(start)에 해당하는 문자부터 두번째 인자에 전달된 index(end)에 해당하는 문자의 바로 이전 문자까지를 모두 반환한다. 이때 첫번째 인수 &lt; 두번째 인수의 관계가 성립된다. 123456789101112let str = &apos;Hello World&apos;; // str.length == 11let res = str.substring(1, 4);console.log(res); // ell// 첫번째 인수 &gt; 두번째 인수 : 두 인수는 교환된다.res = str.substring(4, 1);console.log(res); // ell// 두번째 인수가 생략된 경우 : 해당 문자열의 끝까지 반환한다.res = str.substring(4);console.log(res); // o World 5. String.prototype.toLowerCase() 대상 문자열의 모든 문자를 소문자로 변경한다. 1234let str = &apos;Hello World!&apos;;const res = str.toLowerCase();console.log(res); // hello world! 6. String.prototype.toUpperCase() 대상 문자열의 모든 문자를 대문자로 변경한다. 1234let str = &apos;Hello World!&apos;;const res = str.toUpperCase();console.log(res); // HELLO WORLD!","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://cheonmro.github.io/categories/Algorithms/"}],"tags":[{"name":"String Method","slug":"String-Method","permalink":"https://cheonmro.github.io/tags/String-Method/"}]},{"title":"Array Method for Advanced","slug":"array-method-advanced","date":"2018-11-05T05:10:12.000Z","updated":"2018-11-05T05:10:12.385Z","comments":true,"path":"2018/11/05/array-method-advanced/","link":"","permalink":"https://cheonmro.github.io/2018/11/05/array-method-advanced/","excerpt":"","text":"1. Array.prototype.forEach(function(elem, index, array)) 배열을 순회하며 배열의 각 요소에 대하여 인자로 주어진 콜백함수를 실행한다. 콜백함수의 매개변수를 통해 배열 요소의 값(elem), 요소 인덱스(index), 순회할 배열(array)을 전달 받을 수 있다. 반환값은 undefined이다. forEach 메소드는 원본배열을 변경하지 않는다. forEach 메소드는 for 문과는 달리 break 문을 사용할 수 없고, 일반 for 구문에 비해 성능이 좋지는 않다. forEach()는 배열을 순회하며 요소 값을 참조하여 무언가를 하기 위한 함수 123456789101112let sum = 0;const arr = [1, 3, 5, 7, 9];arr.forEach(function (elem, index, array) &#123; console.log(&apos;[&apos; + index + &apos;] = &apos; + elem); sum += elem;&#125;);console.log(sum); // 25// 원본배열이 유지된다.console.log(arr); // [ 1, 3, 5, 7, 9 ] 2. Array.prototype.map(function(elem, index, array)) 배열을 순회하며 각 요소에 대하여 인자로 주어진 콜백함수의 반환값(결과값)으로 새로운 배열을 생성하여 반환한다. 원본 배열은 변경되지 않는다. 콜백함수의 매개변수를 통해 배열 요소의 값(elem), 요소 인덱스(index), 순회할 배열(array)을 전달 받을 수 있다. map()은 배열을 순회하며 요소 값을 다른 값으로 맵핑하기 위한 함수이다. 123456789101112const arr = [1, 4, 9];// 배열을 순회하며 각 요소에 대하여 인자로 주어진 콜백함수를 실행const result = arr.map(elem =&gt; &#123; return Math.sqrt(elem);&#125;);// map 메소드는 새로운 배열을 반환한다console.log(result); // [ 1, 2, 3 ]// map 메소드는 원본 배열은 변경하지 않는다console.log(arr); // [ 1, 4, 9 ] 3. Array.prototype.filter(function(elem, index, array)) 배열을 순회하며 각 요소에 대하여 인자로 주어진 콜백함수의 실행 결과가 true인 배열 요소의 값만을 추출한 새로운 배열을 반환한다. 이때 원본 배열은 변경되지 않는다. 콜백함수의 매개변수를 통해 배열 요소의 값(elem), 요소 인덱스(index), 순회할 배열(array)을 전달 받을 수 있다. filter()는 배열에서 특정 케이스만 필터링 조건으로 추출하여 새로운 배열을 만들고 싶을 때 사용한다. 12345678910const arr = [1, 2, 3, 4, 5];const result = arr.filter(function (elem, index, array) &#123; console.log(&apos;[&apos; + index + &apos;] = &apos; + elem); return elem % 2; // 홀수만을 필터링한다 (1은 true로 평가된다)&#125;);console.log(result); // [ 1, 3, 5 ]// 원본배열은 유지된다.console.log(arr); // [ 1, 2, 3, 4, 5 ]","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://cheonmro.github.io/categories/Algorithms/"}],"tags":[{"name":"Array Method","slug":"Array-Method","permalink":"https://cheonmro.github.io/tags/Array-Method/"}]},{"title":"정렬 함수 sort() 사용법","slug":"sort-function","date":"2018-11-05T03:47:14.000Z","updated":"2018-11-05T03:47:15.007Z","comments":true,"path":"2018/11/05/sort-function/","link":"","permalink":"https://cheonmro.github.io/2018/11/05/sort-function/","excerpt":"","text":"Array.prototype.sort() 배열안에 원소를 정렬하는 함수로, 원본 배열을 직접 변경하며 정렬된 배열을 반환한다. sort(compareFunction) 함수는 sort() 안에 인자로 정렬 순서를 정의하는 함수를 넣어서 정렬을 한다. 만약, 생략하게 되면, 기본 문자열에 순서에 따라 정렬이 된다. 즉, ASCII 문자 순서(오름차순)로 정렬된다. 또한, sort() 함수는 정렬하는 원소가 문자열, 숫자, 또는 객체형이냐에 따라 사용법이 조금씩 다르다. sort() 안에 인자인 compareFunction를 지정하면, 값은 아래 중 하나로 반환된다. 첫번째 인수가 두번째 인수보다 작을 경우 -&gt; ‘-‘ 첫번째 인수가 두번째 인수보다 클 경우 -&gt; ‘+’ 두 인수가 같을 경우 -&gt; 0 1. 정렬할 원소가 문자열일 경우 123456789101112131415161718// 오름차순const arr = [&apos;orange&apos;, &apos;apple&apos;, &apos;banana&apos;];console.log(arr.sort()); // [ &apos;apple&apos;, &apos;banana&apos;, &apos;orange&apos; ]// 내림차순(ES6) - 문자열끼리 비교할 때는 비교연산자를 사용한다.(숫자는 뺄셈연산자 사용)console.log(arr.sort((a, b) =&gt; &#123; if(a &gt; b) return -1; else if(b&gt; a) return 1; else return 0;&#125;)); // [ &apos;orange&apos;, &apos;banana&apos;, &apos;apple&apos; ]// 내림차순(ES5) - 문자열끼리 비교할 때는 비교연산자를 사용한다.(숫자는 뺄셈연산자 사용)console.log(arr.sort(function(a, b) &#123; if(a &gt; b) return -1; else if(b&gt; a) return 1; else return 0;&#125;)); // [ &apos;orange&apos;, &apos;banana&apos;, &apos;apple&apos; ] 2. 정렬할 원소가 숫자일 경우 123456789101112131415161718192021222324const arr = [3, 11, 12, 10, 9, 1];// ASCII 문자 순서로 정렬되어 숫자의 크기대로 나오지 않음 -&gt; sort()안에 인자로 함수를 추가해줘야 함console.log(arr.sort()); // [ 1, 10, 11, 12, 3, 9 ]// 오름차순(ES6)console.log(arr.sort((a, b) =&gt; &#123; // [ 1, 3, 9, 10, 11, 12 ] return a - b;&#125;));// 오름차순(ES5)console.log(arr.sort(function(a, b) &#123; // [ 1, 3, 9, 10, 11, 12 ] return a - b;&#125;));// 내림차순(ES6)console.log(arr.sort((a, b) =&gt; &#123; // [ 12, 11, 10, 9, 3, 1 ] return b - a;&#125;));// 내림차순(ES5)console.log(arr.sort(function(a, b) &#123; // [ 12, 11, 10, 9, 3, 1 ] return b - a;&#125;)); 3. 정렬할 원소가 객체일 경우 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const person = [ &#123; name : &quot;john&quot;, age : 25&#125;, &#123; name : &quot;smith&quot;, age : 15&#125;, &#123; name : &quot;ro&quot;, age : 35&#125;, &#123; name : &quot;park&quot;, age : 45&#125;]/* 이름순으로 정렬 */// 문자열끼리 비교할 때는 비교연산자를 사용한다.// 오름차순(ES6)console.log(person.sort((a, b) =&gt; &#123; return a.name &lt; b.name ? -1 : a.name &gt; b.name ? 1 : 0;&#125;)); // [ &#123; name: &apos;john&apos;, age: 25 &#125;, &#123; name: &apos;park&apos;, age: 45 &#125;, &#123; name: &apos;ro&apos;, age: 35 &#125;, &#123; name: &apos;smith&apos;, age: 15 &#125; ]// 오름차순(ES5)console.log(person.sort(function(a, b) &#123; return a.name &lt; b.name ? -1 : a.name &gt; b.name ? 1 : 0;&#125;)); // [ &#123; name: &apos;john&apos;, age: 25 &#125;, &#123; name: &apos;park&apos;, age: 45 &#125;, &#123; name: &apos;ro&apos;, age: 35 &#125;, &#123; name: &apos;smith&apos;, age: 15 &#125; ]// 내림차순(ES6)console.log(person.sort((a, b) =&gt; &#123; return a.name &gt; b.name ? -1 : a.name &lt; b.name ? 1 : 0;&#125;)); // [ &#123; name: &apos;smith&apos;, age: 15 &#125;, &#123; name: &apos;ro&apos;, age: 35 &#125;, &#123; name: &apos;park&apos;, age: 45 &#125;, &#123; name: &apos;john&apos;, age: 25 &#125; ]// 내림차순(ES5)console.log(person.sort(function(a, b) &#123; return a.name &gt; b.name ? -1 : a.name &lt; b.name ? 1 : 0;&#125;)); // [ &#123; name: &apos;smith&apos;, age: 15 &#125;, &#123; name: &apos;ro&apos;, age: 35 &#125;, &#123; name: &apos;park&apos;, age: 45 &#125;, &#123; name: &apos;john&apos;, age: 25 &#125; ]/* 나이순으로 정렬 */// 숫자끼리 비교할 때는 뺄셈연산자를 사용한다.const sortingField = &quot;age&quot;;// 오름차순(ES6)console.log(person.sort((a, b) =&gt; &#123; return a[sortingField] - b[sortingField];&#125;)); // [ &#123; name: &apos;smith&apos;, age: 15 &#125;, &#123; name: &apos;john&apos;, age: 25 &#125;, &#123; name: &apos;ro&apos;, age: 35 &#125;, &#123; name: &apos;park&apos;, age: 45 &#125; ]// 오름차순(ES5)console.log(person.sort(function(a, b) &#123; return a[sortingField] - b[sortingField];&#125;)); // [ &#123; name: &apos;smith&apos;, age: 15 &#125;, &#123; name: &apos;john&apos;, age: 25 &#125;, &#123; name: &apos;ro&apos;, age: 35 &#125;, &#123; name: &apos;park&apos;, age: 45 &#125; ]// 내림차순(ES6)console.log(person.sort((a, b) =&gt; &#123; return b[sortingField] - a[sortingField];&#125;)); // [ &#123; name: &apos;park&apos;, age: 45 &#125;, &#123; name: &apos;ro&apos;, age: 35 &#125;, &#123; name: &apos;john&apos;, age: 25 &#125;, &#123; name: &apos;smith&apos;, age: 15 &#125; ]// 내림차순(ES5)console.log(person.sort(function(a, b) &#123; return b[sortingField] - a[sortingField];&#125;)); // [ &#123; name: &apos;park&apos;, age: 45 &#125;, &#123; name: &apos;ro&apos;, age: 35 &#125;, &#123; name: &apos;john&apos;, age: 25 &#125;, &#123; name: &apos;smith&apos;, age: 15 &#125; ]","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://cheonmro.github.io/categories/Algorithms/"}],"tags":[{"name":"Sort function","slug":"Sort-function","permalink":"https://cheonmro.github.io/tags/Sort-function/"}]},{"title":"Array Method for Basic","slug":"array-method-basic","date":"2018-11-05T02:37:57.000Z","updated":"2018-11-05T02:37:57.989Z","comments":true,"path":"2018/11/05/array-method-basic/","link":"","permalink":"https://cheonmro.github.io/2018/11/05/array-method-basic/","excerpt":"","text":"1. Array.prototype.indexOf() arr.indexOf(searchElement, fromIndex): arr에서 찾아야할 값(searchElement)이 몇번째 인덱스부터(fromIndex) 시작해서 그 찾아야할 값에 대한 index를 찾을 때 사용 indexOf 메소드의 인자로 지정된 요소를 배열에서 검색하여 인덱스를 반환한다. 중복되는 요소가 있는 경우 첫번째 인덱스만 반환된다. 만일 해당하는 요소가 없는 경우, -1을 반환한다. 1234const arr = [1, 2, 2, 3];console.log(arr.indexOf(2)); // 1console.log(arr.indexOf(4)); // -1console.log(arr.indexOf(2, 2)); // 1 2. Array.prototype.concat() concat 메소드의 인수로 넘어온 값들(배열 또는 값)을 자신의 복사본에 요소로 추가하고 반환한다. 이때 원본 배열은 변경되지 않는다. 1234567891011const arr1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];const arr2 = [&apos;x&apos;, &apos;y&apos;, &apos;z&apos;];const c = arr1.concat(arr2);console.log(c); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;x&apos;, &apos;y&apos;, &apos;z&apos;]const d = arr1.concat(&apos;hello&apos;);console.log(d); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;hello&apos;]// 원본 배열은 변하지 않는다.console.log(arr1); // [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos; ] 3. Array.prototype.join() 배열 요소 전체를 연결하여 생성한 문자열을 반환한다. 구분자(separator)는 생략 가능하며 기본 구분자는 ,이다. 이때, 원본 배열은 유지된다. 123456789101112const arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;];const x = arr.join();console.log(x); // &apos;a,b,c,d&apos;;const y = arr.join(&apos;&apos;);console.log(y); // &apos;abcd&apos;const z = arr.join(&apos;:&apos;);console.log(z); // &apos;a:b:c:d&apos;console.log(arr); // [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos; ] 4. Array.prototype.reverse() 배열 요소의 순서를 반대로 변경한다. 이때 원본 배열이 변경된다. 반환값은 변경된 배열이다. 123456const arr1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];const arr2 = arr1.reverse();// 원본 배열이 변경된다console.log(arr1); // [ &apos;c&apos;, &apos;b&apos;, &apos;a&apos; ]console.log(arr2); // [ &apos;c&apos;, &apos;b&apos;, &apos;a&apos; ] 5. Array.prototype.slice(start, end) 인자로 지정된 배열의 부분을 복사하여 반환한다. 원본 배열은 변경되지 않는다. 첫번째 매개변수 start에 해당하는 인덱스를 갖는 요소부터 매개변수 end에 해당하는 인덱스를 가진 요소 전까지 복사된다. 1234567891011121314151617181920const arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];// items[1]부터 items[2] 이전(items[2] 미포함)까지 반환const res2 = arr.slice(1, 2);console.log(res2); // [ &apos;b&apos; ]// items[1]부터 이후의 모든 요소 반환const res3 = arr.slice(1);console.log(res3); // [ &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; ]// 인자가 음수인 경우 배열의 끝에서 2개의 요소를 반환const res4 = arr.slice(-2);console.log(res4); // [ &apos;d&apos;, &apos;e&apos; ]// 모든 요소를 반환 (= 복사본 생성)const res5 = arr.slice();console.log(res5); // [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; ]// 원본은 변경되지 않는다.console.log(arr); // [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; ] 6. Array.prototype.splice(start, end) 기존의 배열의 요소를 제거하고 그 위치에 새로운 요소를 추가한다. 배열 중간에 새로운 요소를 추가할 때도 사용되고, 삭제만 할 때도 사용된다. 123456789const arr = [1, 2, 3, 4, 5, 6];// items[1]부터 2개의 요소를 제거하고 제거된 요소를 배열로 반환const res = arr.splice(1, 2);// 원본 배열이 변경된다.console.log(arr); // [ 1, 4, 5, 6 ]// 제거한 요소가 배열로 반환된다.console.log(res); // [ 2, 3 ] 7. Array.prototype.push()/pop()/shift()/unshift() 4가지 메소드는 모두 원본을 변경한다. 출처: Array push/pop/shift/unshift 8. Array.prototype.includes() arr.includes(searchElement, fromIndex): 배열에 특정 요소가 포함되어 있는지 여부를 확인할 때 사용 1234567const arr = [1,2,3,4];const result1 = arr.includes(3);const result2 = arr.includes(1, 1);console.log(result1); // trueconsole.log(result2); // false// 원본 배열이 유지된다.console.log(arr); // [1,2,3,4] 9. Array.prototype.toString() arr.toString(): 배열에 있는 원소를 문자열로 반환할 때 사용 12345const arr = [1,2,3];const result = arr.toString();console.log(result); // &quot;1,2,3&quot;// 원본 배열이 유지된다.console.log(arr); // [1,2,3]","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://cheonmro.github.io/categories/Algorithms/"}],"tags":[{"name":"Array Method","slug":"Array-Method","permalink":"https://cheonmro.github.io/tags/Array-Method/"}]},{"title":"Javascript Technique for Algorithms","slug":"javascript-technique","date":"2018-11-05T01:41:47.000Z","updated":"2018-11-05T01:41:47.770Z","comments":true,"path":"2018/11/05/javascript-technique/","link":"","permalink":"https://cheonmro.github.io/2018/11/05/javascript-technique/","excerpt":"","text":"배열이나 문자열에서 i번째 인덱스 내용을 삭제해야 하는 경우 1. 원본을 유지하면서, 삭제하는 방법 array 메소드 중, slice()를 사용하면, 원본을 유지하면서, 삭제된 새로운 배열을 생성할 수 있다. 12345const arr = [1,2,3,4,5];const newArr = [...arr.slice(0,3), ...arr.slice(4)]; // 3번째 인덱스 삭제console.log(newArr); // [1,2,4,5]console.log(arr); // [1,2,3,4,5] 2. 원본을 변경하면서, 삭제하는 방법 array 메소드 중, splice()를 사용하면, 특정 요소를 삭제함으로써, 원본이 변경된 배열이 된다. 123const arr = [1,2,3,4,5];arr.splice(3,1); // 3번 인덱스부터 1개를 삭제console.log(arr); // [1,2,3,5] 배열이나 문자열에서 중복을 제거해야 할 때 Set을 사용해서 중복을 제거할 수 있다.(Set은 unique한 자료형만을 저장한다.) 1234567891011// 배열const arr = [1, 3, 2, 9, 9, 1, 5, 1, 4, 5, 2];console.log(new Set(arr)); // &#123; 1, 3, 2, 9, 5, 4 &#125;const newArr = [...new Set(arr)];console.log(newArr); // [ 1, 3, 2, 9, 5, 4 ]// 문자열const str = &quot;abcdacbe&quot;;console.log(new Set(str)); // &#123; &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; &#125;const newStr = [...new Set(str)].join(&apos;&apos;);console.log(newStr); // &quot;abcde&quot; 배열이나 문자열에서 딱 1개만 있는 요소를 찾아야 할 경우 array 메소드 중, filter()와 indexOf()를 사용하면, 딱 1개만 있는 요소를 찾을 수 있다. 123456789// 배열const arr = [3, 3, 3, 7, 3];const filterArr = arr.filter( elem =&gt; arr.indexOf(elem) === arr.lastIndexOf(elem) );console.log(filterArr); // [7]// 문자열const str = &apos;33373&apos;;const filterStr = str.split(&apos;&apos;).filter( elem =&gt; str.indexOf(elem) === str.lastIndexOf(elem) );console.log(filterStr); // [&apos;7&apos;] 배열에 규칙적인 연속된 값 할당해야할 경우 Array()와 fill()를 사용한다. 1234const newArr = Array(5).fill(2);console.log(newArr); // [2, 2, 2, 2, 2]const newArr2 = Array(5).fill(1).map( (elem, i) =&gt; elem + i );console.log(newArr2); // [1,2,3,4,5] 배열에 최대값/최소값을 찾아야 할 경우 Math.max(), Math.min()를 사용한다. 123456789// 최대값const arr = [1, 2, 3];const max = Math.max(...arr); // 3console.log(max);// 최소값const arr = [1, 2, 3];const min = Math.min(...arr); // 3console.log(min); 지정된 숫자를 자신보다 작은, 가까운 정수로 내림해야 할 경우 Math.floor()를 사용한다. 123456789const floor1 = Math.floor(2.9); // 2const floor2 = Math.floor(9.1); // 9const floor3 = Math.floor(-1.9); // -2const floor4 = Math.floor(-9.1); // -10console.log(floor1);console.log(floor2);console.log(floor3);console.log(floor4); 지정된 숫자를 자신보다 큰, 가까운 정수로 올림해야 할 경우 Math.ceil()를 사용한다. 12345const ceil1 = Math.ceil(1.1); // 2const ceil2 = Math.ceil(-1.4); // -1console.log(ceil1);console.log(ceil2);","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://cheonmro.github.io/categories/Algorithms/"}],"tags":[{"name":"Javascript Technique","slug":"Javascript-Technique","permalink":"https://cheonmro.github.io/tags/Javascript-Technique/"}]},{"title":"Hash Table이란 무엇인가?","slug":"what-is-hashtable","date":"2018-11-04T11:53:11.000Z","updated":"2018-11-04T11:53:11.953Z","comments":true,"path":"2018/11/04/what-is-hashtable/","link":"","permalink":"https://cheonmro.github.io/2018/11/04/what-is-hashtable/","excerpt":"","text":"Hash Table(해시 테이블) Hash Table이란, 검색하고자 하는 key 값을 입력받아서 해시함수를 돌려서 반환받은 해시코드를 배열의 인덱스로 환산해서 데이터에 접근하는 방식의 자료구조이다. Hash Table 작동원리 출처: Hash Table 검색하고자 하는 Key 값을 해시함수를 돌리면, 해시코드를 반환받는다.(해시코드는 정수이다) 반환된 해시코드를 배열의 개수로 나머지(%) 연산을 해서 인덱스 번호로 바꾼다. 예를 들어, 어떤 Key 값의 해시코드가 445이고 배열의 크기가 3이면, 445 % 3 = 1이 되어, 인덱스 번호는 1이 된다. 이 인덱스 번호로 배열에 데이터를 저장한다. 예를 들어, 인덱스 번호가 1이라면, 배열에서 배열방 1번에 저장한다. 즉, 해시코드 자체가 배열방의 인덱스로 사용되어 검색이 필요없고, 해시코드로 바로 배열의 데이터에 접근이 가능하다. 각 배열방에 저장되어 있는 데이터들은 연결 리스트로 되어 있어, 배열방에 새로운 데이터가 추가될 때마다, 연결 리스트에 추가가 된다. 어떤 Key 값에 대한 검색 요청이 들어와 인덱스로 환산한 뒤, 어떤 배열방에서 그 Key 값을 찾기 위해서는, 그 배열방에 연결 리스트를 순회화면서 그 Key 값을 찾는다. Hash Table 특징 장점: 해시코드 자체가 배열방의 인덱스로 사용되어 다른 검색이 필요없이 해시코드로 바로 배열의 데이터에 접근이 가능하기 때문에, 시간복잡도가 O(1)이다. 단점: 1개의 배열방에 여러 데이터가 겹쳐서 저장되는 경우를 Collision(충돌)이라고 하는데, 이 경우 시간복잡도는 O(n)이다. 이는, 배열방에서 그 Key 값을 찾기 위해, 그 배열방에 연결 리스트를 순회화면서 그 Key 값을 찾아야 하기 때문이다. 이런 문제가 생기는 경우는 크게 2가지이다. 서로 다른 Key 값이지만, 동일한 해시코드로 반환받는 경우 Key 값은 문자열이고 그 가짓수가 무한한대 반해서 해시코드는 정수개 밖에 제공을 못하기 때문에, 알고리즘이 아무리 좋아도 어떤 Key들은 중복되는 해시코드를 가질 수 밖에 없다. 서로 다른 해시코드이지만, 동일한 인덱스로 바뀌는 경우 배열방은 한정되어 있기 때문에, 서로 다른 해시코드이더라도, 환산할 때 동일한 인덱스를 얻게 되는 경우가 있을 수 있기 때문에, 같은 배열방에 배정받는 경우도 있다. 이런 Collision을 최소화하기 위해서는 좋은 해시 알고리즘을 만드는 것이 중요하다. 즉, 배열방을 나눌 때, 규칙을 잘 만들어야 한다.","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"https://cheonmro.github.io/categories/Computer-Science/"}],"tags":[{"name":"Hash Table","slug":"Hash-Table","permalink":"https://cheonmro.github.io/tags/Hash-Table/"}]},{"title":"리스트(List)란 무엇인가?","slug":"what-is-list","date":"2018-11-04T06:42:53.000Z","updated":"2018-11-04T06:42:53.202Z","comments":true,"path":"2018/11/04/what-is-list/","link":"","permalink":"https://cheonmro.github.io/2018/11/04/what-is-list/","excerpt":"","text":"리스트(List) 리스트란, 자료를 순서대로 한 줄로 저장하는 선형 자료구조이다. head: 리스트에서 제일 처음 데이터를 head라고 한다. tail: 리스트에서 제일 마지막 데이터를 tail이라고 한다. 리스트(List)의 종류 리스트는 구현방식에 따라, 다음과 같이 분류된다. 순차 리스트(Array List): 배열을 기반으로 구현된 리스트 연결 리스트(Linked List 메모리의 동적 할당을 기반으로 구현된 리스트 출처: ArrayList vs. LinkedList 두 리스트의 차이점을 더 자세하게 알고 싶다면, Linked List와 Array의 차이점를 클릭한다. 연결 리스트(Linked List)의 종류 1. Simple Linked List(단순 연결 리스트) 단순 연결 리스트란, 연결의 형태가 한쪽 방향으로 전개되고 시작과 끝이 분명히 존재하는 리스트를 말한다. 출처: Simple Linked List 2. Doubly Linked List(이중/양방향 연결 리스트) 이중/양방향 연결 리스트란, 노드가 양쪽 방향으로 연결된 구조의 리스트를 말한다. 즉, 왼쪽 노드가 오른쪽 노드를 가리킴과 동시에 오른쪽 노드도 왼쪽 노드를 가리키는 구조이다. 출처: Doubly Linked List 3. Circular Linked List(원형/환형 연결 리스트) 원형/환형 연결 리스트란, 단순 연결 리스트에서 마지막 노드가 첫 번째 노드를 가리켜서 연결의 형태가 원을 이루는 리스트를 말한다. 출처: Circular LinkedList","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"https://cheonmro.github.io/categories/Computer-Science/"}],"tags":[{"name":"Data Structures","slug":"Data-Structures","permalink":"https://cheonmro.github.io/tags/Data-Structures/"},{"name":"List","slug":"List","permalink":"https://cheonmro.github.io/tags/List/"}]},{"title":"자료구조(Data Structures)의 분류","slug":"types-of-data-structures","date":"2018-11-04T05:41:46.000Z","updated":"2018-11-04T05:41:46.897Z","comments":true,"path":"2018/11/04/types-of-data-structures/","link":"","permalink":"https://cheonmro.github.io/2018/11/04/types-of-data-structures/","excerpt":"","text":"자료구조(Data Structures) 자료구조란, 자료의 집합으로써, 각 원소들이 논리적으로 정의된 규칙에 의해 나열되며 자료에 대한 처리를 효율적으로 수행할 수 있도록 자료를 구분하여 표현한 것을 말한다. 자료구조의 분류 자료구조는 다음과 같이 분류되어 있다. 출처: Data Structures","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"https://cheonmro.github.io/categories/Computer-Science/"}],"tags":[{"name":"Data Structures","slug":"Data-Structures","permalink":"https://cheonmro.github.io/tags/Data-Structures/"}]},{"title":"Stack과 Queue, 그리고 Deque의 차이점","slug":"stack-vs-queue","date":"2018-11-04T05:20:18.000Z","updated":"2018-11-04T05:20:18.745Z","comments":true,"path":"2018/11/04/stack-vs-queue/","link":"","permalink":"https://cheonmro.github.io/2018/11/04/stack-vs-queue/","excerpt":"","text":"Stack Stack이란, 한쪽 끝에서만 데이터의 삽입, 삭제가 이루어지는 자료구조다. 가장 마지막에 삽입된 항목이 맨 먼저 삭제된다. -&gt; Last In First Out(LIFO) push: Stack에 데이터를 넣는 연산 pop: Stack에 데이터를 꺼내는 연산 peek: Stack에 데이터를 들여다 보는 연산 출처: Stack Stack 구현 1. class를 이용한 Stack 구현(ES6) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// ES6class Stack &#123; constructor() &#123; this.count = 0; this.dataStore = []; &#125; push(element) &#123; this.dataStore[this.count] = element; this.count++; &#125; pop() &#123; if(this.count &gt;= 1) &#123; let val = this.dataStore[this.count - 1]; this.count--; return val; &#125; return null; &#125; peek() &#123; return this.dataStore[this.count - 1]; &#125; size() &#123; return this.count; &#125; isEmpty() &#123; return this.count === 0; &#125; clear() &#123; this.count = 0; this.dataStore = []; &#125;&#125;// for Testconst stack = new Stack();console.log(stack); // &#123; count: 0, dataStore: [] &#125;stack.push(&apos;ro1&apos;);stack.push(&apos;ro2&apos;);stack.push(&apos;ro3&apos;);console.log(stack.peek()); // ro3console.log(stack.pop()); // ro3console.log(stack.pop()); // ro2console.log(stack.size()); // 1console.log(stack.isEmpty()); // falseconsole.log(stack.pop()); // ro1console.log(stack.pop()); // null 2. 생성자 함수를 이용한 Stack 구현(ES5) 123456789101112131415161718192021222324252627282930313233343536373839404142434445// ES5function Stack() &#123; var dataStore = []; var count = 0; this.push = function(element) &#123; dataStore[count] = element; count++; &#125;; this.pop = function() &#123; if(count &gt;= 1) &#123; let val = dataStore[count - 1]; count--; return val; &#125; return null; &#125;; this.peek = function() &#123; return dataStore[count - 1]; &#125;; this.size = function() &#123; return count; &#125;; this.isEmpty = function() &#123; return count === 0; &#125;;&#125;// for Testvar stack = new Stack();console.log(stack); // &#123; push: [Function], pop: [Function], peek: [Function], size: [Function], isEmpty: [Function] &#125;stack.push(&apos;ro1&apos;);stack.push(&apos;ro2&apos;);stack.push(&apos;ro3&apos;);console.log(stack.peek()); // ro3console.log(stack.pop()); // ro3console.log(stack.pop()); // ro2console.log(stack.size()); // 1console.log(stack.isEmpty()); // falseconsole.log(stack.pop()); // ro1console.log(stack.pop()); // null Queue Queue란, 데이터의 삽입이 한쪽 끝(뒤, rear)에서 이루어지고, 삭제는 다른 쪽(앞, front)에서 이루어지는 자료구조다. 가장 처음 삽입된 항목이 맨 먼저 삭제된다. -&gt; First In First Out(FIFO) enqueue: Queue에 데이터를 넣는 연산 dequeue: Queue에 데이터를 꺼내는 연산 출처: Queue Queue 구현(2개의 Stack으로 Queue 구현) 1. class를 이용한 Queue 구현(ES6) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// Stackclass Stack &#123; constructor() &#123; this.count = 0; this.dataStore = []; &#125; push(element) &#123; this.dataStore[this.count] = element; this.count++; &#125; pop() &#123; if(this.count &gt;= 1) &#123; let val = this.dataStore[this.count - 1]; this.count--; return val; &#125; return null; &#125; peek() &#123; return this.dataStore[this.count - 1]; &#125; size() &#123; return this.count; &#125; isEmpty() &#123; return this.count === 0; &#125; clear() &#123; this.count = 0; this.dataStore = []; &#125;&#125;// Queueclass Queue &#123; constructor() &#123; this.inbox = new Stack(); this.outbox = new Stack(); this.size = 0; &#125; eneque(element) &#123; this.inbox.push(element); &#125; dequeue() &#123; if(this.outbox.size() === 0) &#123; while(this.inbox.size()) &#123; this.outbox.push(this.inbox.pop()); &#125; &#125; return this.outbox.pop(); &#125; size() &#123; return this.inbox.size() + this.outbox.size(); &#125;&#125;// for Testconst queue = new Queue();console.log(queue); // &#123; inbox: Stack &#123; count: 0, dataStore: [] &#125;, outbox: Stack &#123; count: 0, dataStore: [] &#125; size: 0 &#125;queue.eneque(&apos;a&apos;);queue.eneque(&apos;b&apos;);queue.eneque(&apos;c&apos;);console.log(queue.dequeue()); // aconsole.log(queue.dequeue()); // bqueue.eneque(&apos;d&apos;);queue.eneque(&apos;e&apos;);console.log(queue.dequeue()); // cconsole.log(queue.dequeue()); // d 2. 생성자 함수를 이용한 Queue 구현(ES5) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// Stackfunction Stack() &#123; var dataStore = []; var count = 0; this.push = function(element) &#123; dataStore[count] = element; count++; &#125;; this.pop = function() &#123; if(count &gt;= 1) &#123; let val = dataStore[count - 1]; count--; return val; &#125; return null; &#125;; this.peek = function() &#123; return dataStore[count - 1]; &#125;; this.size = function() &#123; return count; &#125;; this.isEmpty = function() &#123; return count === 0; &#125;;&#125;// Queuefunction Queue() &#123; var inbox = new Stack(); var outbox = new Stack(); this.eneque = function(element) &#123; inbox.push(element); &#125;; this.dequeue = function() &#123; if (outbox.size() === 0) &#123; while (inbox.size()) outbox.push(inbox.pop()); &#125; return outbox.pop(); &#125;; this.size = function()&#123; return inbox.size() + outbox.size(); &#125;;&#125;// for Testvar queue = new Queue();console.log(queue); // &#123; eneque: [Function], dequeue: [Function], size: [Function] &#125;queue.eneque(&apos;a&apos;);queue.eneque(&apos;b&apos;);queue.eneque(&apos;c&apos;);console.log(queue.dequeue()); // aconsole.log(queue.dequeue()); // bqueue.eneque(&apos;d&apos;);queue.eneque(&apos;e&apos;);console.log(queue.dequeue()); // cconsole.log(queue.dequeue()); // d Deque Deque란, 데이터의 삽입과 삭제를 앞, 뒤 양쪽에서 이루어지는 자료구조다. 출처: Deque","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"https://cheonmro.github.io/categories/Computer-Science/"}],"tags":[{"name":"Queue","slug":"Queue","permalink":"https://cheonmro.github.io/tags/Queue/"},{"name":"Stack","slug":"Stack","permalink":"https://cheonmro.github.io/tags/Stack/"},{"name":"Deque","slug":"Deque","permalink":"https://cheonmro.github.io/tags/Deque/"}]},{"title":"Linked List와 Array의 차이점","slug":"linkedlist-vs-array","date":"2018-11-03T07:20:39.000Z","updated":"2018-11-03T07:20:39.427Z","comments":true,"path":"2018/11/03/linkedlist-vs-array/","link":"","permalink":"https://cheonmro.github.io/2018/11/03/linkedlist-vs-array/","excerpt":"","text":"Linked List(연결 리스트) Linked List란, 데이터를 논리적 순서에 따라 입력하지만, 물리적 주소는 순차적이지 않는 자료구조를 말한다. Linked List의 특징: 장점: Linked List에 데이터를 삽입하거나, 삭제시에 각 데이터가 가지고 있는 링크만 변경하면 되므로, 다른 데이터의 영향없이 빠르게 가능하다. 단점: 배열의 인덱스 대신에 각 데이터가 이전 위치 및 다음 위치를 가리키는 링크를 가지고 있기 때문에, 데이터에 한번에 접근할 수는 없고, 연결되어 있는 링크를 따라가야 하기 때문에, 배열에 비해 속도가 느리다. Array(배열) Array란, 데이터를 논리적 순서에 따라 순차적으로 데이터를 입력하며, 물리적 주소 또한 순차적인 자료구조를 말한다. Array의 특징: 장점: 인덱스를 가지고 있어서 원하는 데이터에 한번에 접근이 가능하기 때문에 접근속도가 빠르다. 단점: Array에 데이터를 삽입하거나 삭제할 시에 배열을 통째로 복사해서 삽입/삭제가 이루어지고, 삽입/삭제가 이루어진 위치의 다음부터 모든 데이터의 위치를 변경해야 하기 때문에, 삽입/삭제 때마다 데이터의 위치를 바꾸는 데만 많은 리소스를 사용하게 된다. 1. 접근 속도(Access) Linked List: 최소 한번은 리스트를 순회해야 하기 때문에, 시간복잡도는 O(n)이다. Array: 인덱스로 접근하기 때문에, 시간복잡도는 O(1)이다. 출처: Array vs. LinkedList 2. 삽입/삭제 속도(Add/Remove) Linked List: 어느 곳에 삽입/삭제를 하던간에 리스트를 순회해야 하기 때문에, 시간복잡도는 O(n)이다. Array: 데이터를 삽입/삭제시에 삽입 또는 삭제될 위치 그 이후의 데이터를 한 칸씩 미뤄야하는 추가과정과 시간 등 리소스가 소비됨.(Linked List는 필요없음) 또한, 데이터를 삽입시에 모든 공간이 다 꽉 차버렸다면, 새로운 메모리 공간이 필요함.(Linked List는 필요없음) 목적과 상황에 따라 선택해야 하는 자료구조 Linked List를 사용해야 하는 경우: 데이터의 삽입/삭제가 자주 일어나야 한다면 사용Array를 사용해야 하는 경우: 데이터의 삽입/삭제가 많이 없고, 대신에 데이터의 접근이 자주 일어나야 한다면 사용","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"https://cheonmro.github.io/categories/Computer-Science/"}],"tags":[{"name":"Linked List","slug":"Linked-List","permalink":"https://cheonmro.github.io/tags/Linked-List/"},{"name":"Array","slug":"Array","permalink":"https://cheonmro.github.io/tags/Array/"}]},{"title":"Javascript에서의 this","slug":"what-is-this","date":"2018-11-01T01:54:20.000Z","updated":"2018-11-01T01:54:20.385Z","comments":true,"path":"2018/11/01/what-is-this/","link":"","permalink":"https://cheonmro.github.io/2018/11/01/what-is-this/","excerpt":"","text":"Javascript에서의 this는 다음과 같은 규칙을 따른다. 기본적으로, this는 전역객체(window)를 가리킨다. 예외1: 생성자 함수내의 this는 생성자 함수가 생성한 객체를 가리킨다. 예외2: 메소드 내에서 this는 메소드를 호출한(소유한) 객체를 가리킨다. 그외는 this는 언제나 window를 가리킨다. 또는, 명시적으로 this를 바꿀 수 있다.(apply() &amp; call() 메소드 사용)","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://cheonmro.github.io/categories/Javascript/"}],"tags":[{"name":"this","slug":"this","permalink":"https://cheonmro.github.io/tags/this/"}]},{"title":"Prototype이란 무엇인가?","slug":"what-is-prototype","date":"2018-10-31T15:59:03.000Z","updated":"2018-10-31T17:00:28.021Z","comments":true,"path":"2018/11/01/what-is-prototype/","link":"","permalink":"https://cheonmro.github.io/2018/11/01/what-is-prototype/","excerpt":"","text":"Prototype과 Prototype Architecture Prototype(객체)이란, 새로 생성된 인스턴스(객체)의 부모의 역할을 하는 객체를 말한다. 여기서 부모의 역할이란, 새로 생성된 인스턴스(객체)가 부모 객체의 프로퍼티 또는 메소드를 상속받아 사용할 수 있다는 뜻이다. Prototype 객체는 생성자 함수에 의해 생성된 각각의 객체에 공유 프로퍼티를 제공하기 위해 사용한다. Java, C++과 같은 클래스 기반 객체지향 프로그래밍 언어와 달리 자바스크립트는 프로토타입 기반 객체지향 프로그래밍 언어이다. 클래스 기반 객체지향 프로그래밍 언어는 객체 생성 이전에 클래스를 정의하고 이를 통해 객체(인스턴스)를 생성한다. 하지만 프로토타입 기반 객체지향 프로그래밍 언어는 클래스 없이(Class-less)도 객체 리터럴 방식 또는 생성자 함수를 이용해서 객체를 생성할 수 있다. (ECMAScript 6에서 클래스가 추가되었다) 기본적으로 Prototype과 관련된 개념은 다음과 같다. 출처: Prototype Architecture 어떤 생성자 함수(Person 생성자 함수)에 의해 인스턴스(foo 객체)가 생성되면, 그 인스턴스의 부모 역할을 하는 프로토타입 객체(Person.prototype)가 결정된다. 위 그림에서, 생성된 인스턴스는 name, gender 프로퍼티와, sayHello 메소드를 가지고 있다. ECMAScript spec에서는 자바스크립트의 모든 객체는 자신의 프로토타입을 가리키는 [[Prototype]]이라는 숨겨진 프로퍼티를 가진다 라고 되어있다. 크롬, 파이어폭스 등에서는 숨겨진 [[Prototype]] 프로퍼티가 __proto__ 프로퍼티로 구현되어 있다. 즉, __proto__과 [[Prototype]]은 같은 개념이다. foo 객체는 __proto__ 프로퍼티로 자신의 부모 객체(프로토타입 객체)인 Person.prototype을 가리키고 있다. 객체를 생성할 때 프로토타입은 결정된다. 결정된 프로토타입 객체는 다른 임의의 객체로 변경할 수 있다. 이것은 부모 객체인 프로토타입을 동적으로 변경할 수 있다는 것을 의미한다. 이러한 특징을 활용하여 객체의 상속을 구현할 수 있다. constructor 프로퍼티 프로토타입 객체는 constructor 프로퍼티를 갖는다. 이 constructor 프로퍼티는 객체의 입장에서 자신을 생성한 객체를 가리킨다. 예를 들어 Person() 생성자 함수에 의해 생성된 객체를 foo라 하자. 이 foo 객체를 생성한 객체는 Person() 생성자 함수이다. 이때 foo 객체 입장에서 자신을 생성한 객체는 Person() 생성자 함수이며, foo 객체의 프로토타입 객체는 Person.prototype이다. 따라서 프로토타입 객체 Person.prototype의 constructor 프로퍼티는 Person() 생성자 함수를 가리킨다. Prototype Chain 자바스크립트는 특정 객체의 프로퍼티나 메소드에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티 또는 메소드가 없다면 [[Prototype]] 프로퍼티가 가리키는 링크를 따라 자신의 부모 역할을 하는 프로토타입 객체의 프로퍼티나 메소드를 차례대로 검색한다. 이것을 프로토타입 체인이라 한다. 프로토타입 체인 동작 조건 객체의 프로퍼티를 참조하는 경우, 해당 객체에 프로퍼티가 없는 경우, 프로토타입 체인이 동작한다. 객체의 프로퍼티에 값을 할당하는 경우, 프로토타입 체인이 동작하지 않는다. 이는 객체에 해당 프로퍼티가 있는 경우, 값을 재할당하고 해당 프로퍼티가 없는 경우는 해당 객체에 프로퍼티를 동적으로 추가하기 때문이다. 출처: 프로토타입 체인 동작 조건","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://cheonmro.github.io/categories/Javascript/"}],"tags":[{"name":"Prototype","slug":"Prototype","permalink":"https://cheonmro.github.io/tags/Prototype/"}]},{"title":"Closure란 무엇인가?","slug":"what-is-closures","date":"2018-10-31T14:52:06.000Z","updated":"2018-10-31T14:52:06.449Z","comments":true,"path":"2018/10/31/what-is-closures/","link":"","permalink":"https://cheonmro.github.io/2018/10/31/what-is-closures/","excerpt":"","text":"클로저(Closure) 클로저란, 외부함수와 내부함수가 있을 때, 외부함수에 의해 내부함수가 반환된 이후에도, 내부함수에서 외부함수에 있는 변수를 참조할 수 있는 것을 말한다. 조건 3가지 외부함수와 내부함수가 존재 내부함수가 외부함수에 있는 변수를 참조해야 한다. 외부함수가 내부함수를 return(라이프사이클과 관련) 해야한다. 내부함수가 외부함수보다 더 긴 라이프 사이클을 가지고 있을때,외부함수에 있는 변수를 내부함수가 참조하는데, 그 변수의 값은 유지되어있다. 실행 컨텍스트의 관점에서 이해해보자. 기본적으로 실행 컨텍스트는 함수가 종료되면, 실행 컨텍스트 스택에서 제거된다. 그래서 외부함수에서 내부함수를 반환하고, 모두 실행이 되면, 외부함수의 실행 컨텍스트는 제거된다. 그럼에도 불구하고, 내부함수에서 외부함수의 실행 컨텍스트 내에 있는 활성 객체는 유효하기 때문에, 내부함수에서 외부함수의 변수를 참조할 수 있다. (이때, 이 변수를 자유변수라고 한다.) 이는 내부함수가 스코프 체인을 통해 참조하려는 변수를 먼저 내부함수에서 찾고(내부함수 안에 있는 스코프체인의 ‘0’이 가리키는 활성객체에 참조하려는 변수가 있는지 확인한다.), 없으면, 상위지역인 외부함수에서 찾는다.(내부함수 안에 있는 스코프체인의 ‘1’이 가리키는 활성객체, 즉 외부함수의 활성객체에 들어있는 변수를 말한다.) 이때 내부함수가 외부함수에 있는 변수의 복사본이 아니라, 실제 변수에 접근하는 것이다. 위 내용을 예제와 함께 요약하면 다음과 같다.12345678function outerFunc() &#123; var x = 10; var innerFunc = function () &#123; console.log(x); &#125;; return innerFunc;&#125;var inner = outerFunc();inner(); // 10 순서 외부함수(outerFunc)가 내부함수(innerFunc)를 반환하고, 외부함수는 종료된다.(이때, 외부함수의 실행 컨텍스트는 실행 컨텍스트 스택에서 제거된다.) 내부함수에서 변수 x를 참조하려 할 때, 먼저 내부함수(자기자신) 내에서 그 변수를 찾는다.(내부함수의 스코프체인의 ‘0’이 가리키는 활성객체내에 변수 x를 찾는다.) 내부함수내에 없으면, 그 내부함수를 포함하고 있는 외부함수 내에서 그 변수를 찾는다.(내부함수의 스코프체인의 ‘1’이 가리키는 활성객체내에 변수 x를 찾아 참조한다.) 이때 내부함수가 외부함수에 있는 변수의 복사본이 아니라, 실제 변수에 접근한다.!","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://cheonmro.github.io/categories/Javascript/"}],"tags":[{"name":"Closures","slug":"Closures","permalink":"https://cheonmro.github.io/tags/Closures/"}]},{"title":"실행 컨텍스트란 무엇인가?","slug":"what-is-execution-context","date":"2018-10-31T14:42:23.000Z","updated":"2018-10-31T14:42:23.820Z","comments":true,"path":"2018/10/31/what-is-execution-context/","link":"","permalink":"https://cheonmro.github.io/2018/10/31/what-is-execution-context/","excerpt":"","text":"실행 컨텍스트(Execution Context) 실행 컨텍스트란, 실행 가능한 코드가 실행되기 위해 필요한 환경을 의미하는데, 이 환경은 코드가 실행되기 전에 설정이 된다. 이때, 실행 가능한 코드는 총 3개(전역코드/함수코드/Eval코드)가 있는데, 일반적으로 전역코드/함수코드를 말한다. 여기서 환경이 설정된다는 것은 실행에 필요한 여러가지 정보를 담는다는 뜻이다. 코드가 전역변수와 외부함수 그리고 그 안에 내부함수 있다고 해보자. 코드가 실행되기 전, 전역에 실행 컨텍스트가 생성이 되는데, 이것을 전역 실행 컨텍스트라고 한다. 전역 실행 컨텍스트가 생성이 되면, 실행 컨텍스트 스택(콜 스택)에 추가된다. 그리고, 외부함수가 호출이 되면, 외부함수가 실행되기 전에 외부함수에 대한 실행 컨텍스트가 생성이 되는데, 이것을 함수 실행 컨텍스트라고 한다. 이 외부함수 실행 컨텍스트 또한 실행 컨텍스트 스택에 그 전에 추가된 전역 실행 컨텍스트 위에 쌓이게 된다. 내부함수 또한 호출되면, 내부함수 실행되기 전에 내부함수 실행 컨텍스트가 생성되고, 실행 컨텍스트 스택에 있는 외부함수 실행 컨텍스트 위에 쌓이게 된다. 전체적인 과정에서 봤을때, 코드의 종류(전역코드/함수코드)에 따라 실행 컨텍스트가 생성되고, 실행 컨텍스트 스택에 쌓이는 구조이다. 실행 컨텍스트가 생성되고 코드가 실행되기 전에, 실행 컨텍스트는 3가지 프로퍼티를 가지게 된다. Scope Chain VO(변수객체) thisvalue 실행 컨텍스트가 생성이 되면, 먼저 Scope Chain이라는 전역 객체 또는 활성 객체를 가리키는 리스트가 생성되고 초기화 된다. 리스트는 배열처럼 ‘0’: {}, ‘1’: {}, 이런 방식으로 생성되는데, ‘0’은 자기자신(위치)를 가리키고, 1은 자기 위치의 상위 지역을 가리킨다. 예를 들어, 외부함수의 Scope Chain의 ‘0’은 자기 자신인 외부함수를 가리키고, ‘1’은 외부함수의 상위지역인 전역코드를 가리킨다. 좀 더 구체적으로 말하면, ‘0’은 자기자신(외부함수)가 가지고 있는 활성객체(A0)를 가리키고, ‘1’은 상위지역인 전역코드가 가지고 있는 전역객체(GO)를 가리킨다. 그리고, 변수 객체(VO)가 생성되어, 각 코드(전역코드/함수코드)가 가지고 있는 객체를 담는다. 전역코드의 경우, 전역함수와 전역변수를 가지고 있고, 함수코드의 경우, arguments, 내부함수, 지역변수 등을 가지고 있다. this의 값은 문맥에 따라 결정이 되는데, 예외사항이 아니면 전역객체를 가리킨다. 위 내용을 요약하면 다음과 같다. 순서 브라우저안에 기본적으로 전역객체(window)가 존재 (브라우저에서) 코드가 실행되기전, 전역 실행 컨텍스트가 생성 전역 실행 컨텍스트가 생성되면서, Scope Chain의 리스트 생성 및 초기화(이때, Scope Chain의 리스트 ‘0’은 전역객체를 가리킨다) 변수객체의 생성후, 변수객체에 전역변수 및 전역함수를 추가 전역함수를 추가할 때, 전역 함수 객체는 [[Scopes]] 프로퍼티를 가짐(이 프로퍼티는 함수 객체만이 소유하는 내부 프로퍼티로, 함수 객체가 실행되는 환경을 가리킨다.) this 값이 결정되기 이전에 this는 전역 객체를 가리키다가, 함수 호출 패턴에 의해 this에 할당되는 값이 결정됨 전역코드가 실행(예를 들어, 전역변수에 값이 할당되고, 전역함수가 호출됨) 외부함수가 호출되면, 외부함수에 대한 실행 컨텍스트 생성 외부함수도 전역 실행 컨텍스트와 같은 방식으로 진행 이때, 외부함수의 변수객체에는 arguments, 내부함수, 지역변수 등이 포함됨 외부함수 실행 내부함수도 위와 동일 위에서 생성된 각 실행 컨텍스트가 순서대로 실행 컨텍스트 스택에 하나씩 쌓이고, 함수 실행이 끝나면, 해당 함수의 실행 컨텍스트가 제거된다. 전역 실행 컨텍스트는 애플리케이션이 종료될 때까지 유지된다.!!","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://cheonmro.github.io/categories/Javascript/"}],"tags":[{"name":"Execution Context","slug":"Execution-Context","permalink":"https://cheonmro.github.io/tags/Execution-Context/"}]},{"title":"let & const & var","slug":"let-and-const","date":"2018-10-31T13:45:37.000Z","updated":"2018-10-31T13:45:37.821Z","comments":true,"path":"2018/10/31/let-and-const/","link":"","permalink":"https://cheonmro.github.io/2018/10/31/let-and-const/","excerpt":"","text":"var와 let/const의 차이점 ES5까지는 var를 사용했으나, var가 가지고 있는 단점들을 보완하기 위해 ES6에서는 let 과 const를 사용할 수 있다. var는 중복선언이 가능했으나, let과 const는 불가능하다. var a = 3; 이렇게 선언을 했어도, 다시 var a = 10; 이런식으로 중복 선언이 가능하다. 이는 의도치 않게 변수값을 변경하는 문제가 발생하게 된다. 하지만, let과 const로 선언을 할 경우, 중복선언을 하려고 하면, 에러가 발생하게 된다. 이렇게, let과 const를 사용하게 되면 중복선언을 미리 막을 수 있다. 유효범위가 다르다. var를 이용한 변수 선언은 유효범위가 함수레벨이다. 즉, 함수내에서는 지역변수이고, 함수 밖에서는 전역변수이다.let과 const를 이용한 변수 선언은 유효범위가 블록레벨이다. 즉, 블록내에서는 지역변수이고, 블록 밖에서는 전역변수이다. let 과 const 차이점 const는 상수(변하지 않는 값)를 위해 사용한다.(그렇다고 꼭 상수만을 위한 것은 아니다.) let은 재할당이 가능하고, const는 불가능하다. const는 반드시 선언과 동시에 할당이 이루어져야 한다. 그렇지 않으면, 문법에러가 발생한다. const 변수의 객체인 경우도 재할당이 불가능하다. 즉, 객체에 대한 참조를 변경하지 못한다는 것을 의미한다. 그러나, 할당된 객체의 프로퍼티 및 값은 변경할 수 있다.12345const user = &#123; name: &apos;Kim&apos; &#125;;user = &#123;&#125;; // TypeError: Assignment to constant variable.// 객체의 내용은 변경할 수 있다.user.name = &apos;Ro&apos;; var 와 let 과 const 활용 let: 재할당이 필요한 변수에 사용한다.const: 재할당이 필요없는 변수에 사용한다.var: ES6에서는 사용하지 않는다.","categories":[{"name":"ES6","slug":"ES6","permalink":"https://cheonmro.github.io/categories/ES6/"}],"tags":[{"name":"let","slug":"let","permalink":"https://cheonmro.github.io/tags/let/"},{"name":"const","slug":"const","permalink":"https://cheonmro.github.io/tags/const/"},{"name":"var","slug":"var","permalink":"https://cheonmro.github.io/tags/var/"}]},{"title":"브라우저 동작원리","slug":"how-browser-works","date":"2018-10-31T12:59:40.000Z","updated":"2018-10-31T12:59:40.291Z","comments":true,"path":"2018/10/31/how-browser-works/","link":"","permalink":"https://cheonmro.github.io/2018/10/31/how-browser-works/","excerpt":"","text":"브라우저 동작원리(How Browser Works) 브라우저와 서버와의 통신은 다음과 같이 진행된다. 출처: How Browser Works 브라우저의 핵심 기능은 사용자가 브라우저에서 URL 입력창에 어떤 사이트를 입력하게 될 때, 그 사이트의 서버에 요청(Request)을 하고, 서버로부터 응답(Response)을 받아 브라우저에 그 사이트의 웹페이지를 표시하는 것이다. 이때, 브라우저는 서버로부터 HTML, CSS, Javascript, 그리고 이미지 파일 등을 받는데, 그 과정은 다음과 같다. 브라우저가 서버에 첫 요청을 하고, 서버는 먼저 index.html을 응답으로 브라우저에 보낸다. 브라우저의 렌더링 엔진에 있는 HTML 파서에 의해 파싱(해독)되어, DOM 트리를 생성한다. HTML 파서가 html 파일을 파싱할 때, css 태그를 만나면 다시 서버에 요청하고, 서버는 css 파일을 응답으로 브라우저에 보내준다. 그러면, 브라우저의 렌더링 엔진에 있는 CSS 파서에 의해 파싱되어, CSSOM 트리를 생성한다. 또한, HTML 파서는 script 태그를 만나게 되면, 자바스크립트 코드를 실행하기 위해, DOM 생성 프로세스를 중지하고, 자바스크립트 엔진으로 제어 권한을 넘긴다. 그리고, 다시 서버에 요청해, 응답으로 자바스크립트 파일을 응답받아, 자바스크립트 엔진은 자바스크립트 파일을 파싱하여 실행한다. 자바스크립트의 실행이 완료되면, 다시 HTML 파서로 제어 권한을 넘겨서 브라우저가 중지했던 시점부터 DOM 생성을 재개한다. DOM 생성이 완료되면, DOM과 CSSOM 트리는 최종적으로 렌더 트리로 결합하게 된다. 이 렌더 트리를 기반으로 브라우저는 웹페이지를 화면에 표시하게 된다. 이처럼, 브라우저는 동기적으로 HTML/CSS/Javascript를 처리한다. 이는 script 태그의 위치에 따라 블로킹이 발생하여, DOM 생성이 지연될 수 있다는 것을 의미한다. 즉, script 태그의 위치는 중요하다. 그래서, body 요소의 가장 아래에 자바스크립트 태그를 위치시키는 것이 좋다. 그 이유는 다음과 같다. HTML 요소들이 자바스크립트 로딩 지연으로 인해 렌더링에 지장 받는 일이 발생하지 않기 때문에, 웹페이지 로딩 시간이 단축되기 때문이다. DOM이 완성되지 않은 상태에서 자바스크립트가 DOM을 조작하게 된다면, 에러가 발생할 수 있기 때문이다.","categories":[{"name":"Network","slug":"Network","permalink":"https://cheonmro.github.io/categories/Network/"}],"tags":[{"name":"Browser","slug":"Browser","permalink":"https://cheonmro.github.io/tags/Browser/"}]},{"title":"정렬(sort) 알고리즘","slug":"sort-algorithms","date":"2018-10-31T06:54:39.000Z","updated":"2018-10-31T06:54:39.373Z","comments":true,"path":"2018/10/31/sort-algorithms/","link":"","permalink":"https://cheonmro.github.io/2018/10/31/sort-algorithms/","excerpt":"","text":"정렬 알고리즘 정렬 알고리즘이란, 원소들을 번호순이나 사전 순서와 같이 일정한 순서대로 열거하는 알고리즘이다. 정렬 알고리즘은 명함을 어떤 순서로 정리할까?와 같은 문제이다.1만장의 명함이 있고, 가나다 순으로 정리되어 있는데, 어느 날 새로운 명함을 받았다면, 그 명함을 가나다 순에 맞춰 끼워 넣어야 한다면 그 뒤에 명함들은 한 칸씩 뒤로 밀어야 하는 번거로움이 있다. 밀리는 명함이 1장일 수도 있고, 수천장일 수도 있다. 즉, 가나다 순으로 명함을 정리해두는 것이 머릿속에서는 편리하다고 생각되더라도 실제 관리하기에는 여간 불편한 것이 아니다. 정렬 알고리즘에서 중요한 점은 2가지다. 어떤 데이터를 사용하는가? 어떤 정렬 조건을 사용하는가? 데이터를 정렬할 때, 무조건 하나의 정렬 알고리즘을 사용하는 것은 바람직하지 않다. 데이터를 정렬할 여러 가지 조건(데이터의 개수, 사용할 수 있는 메모리의 양 등)을 분석해서 가장 합당한 정렬 알고리즘을 선택하는 지혜가 필요하다. 정렬 알고리즘 종류 퀵 정렬 알고리즘(Quick Sort) 병합 정렬 알고리즘(Merge Sort) 버블 정렬 알고리즘(Bubble Sort) 선택 정렬 알고리즘(Selection Sort) 퀵 정렬 알고리즘(Quick Sort) 퀵 정렬 알고리즘: 리스트의 한 요소를 피벗(Pivot: 기준값)으로 선정한 다음, 피벗보다 작은 요소를 하위(왼쪽) 리스트로, 피벗보다 큰 요소를 상위(오른쪽) 리스트로 이동시키는 알고리즘이다. 예를 들어, 배열 [3, 9, 4, 7, 5, 0, 1, 6, 8, 2] 있다고 해보자. 여기서 피벗을 5라고 정하고, 5보다 작은 요소를 왼쪽으로, 큰 요소를 오른쪽으로 보내는 작동 방식에 대해 알아보자. 왼쪽 맨끝을 s(시작 포인트), 오른쪽 맨끝을 e(끝 포인트)라고 하자. s부터 피벗과 비교해서, s가 피벗보다 작으면 s는 오른쪽으로 한칸 이동후, 피벗과 비교한다. 만약, s가 피벗보다 크면 잠깐 멈춰있고, e를 피벗과 비교하기 시작한다. e가 피벗보다 크면 e는 왼쪽으로 한칸 이동후, 피벗과 다시 비교한다. 만약, e가 피벗보다 작으면 잠깐 멈춘후, 아까 멈춘 s의 값과 서로 바꾼다.(swap) 위 배열에서 s는 9가 되고, e는 2가 된다. 이 두 개의 숫자를 서로 바꾼다. 그럼, [3, 2, 4, 7, 5, 0, 1, 6, 8, 9] 배열이 된다. 그리고, 다시 s를 한칸 오른쪽으로 이동후, 피벗과 비교한다. 만약, s의 값이 피벗보다 클 경우, 잠깐 멈춰있고, e도 피벗과 비교하기 시작한다. 이런식으로 1바퀴를 돌게 되면 배열은 다음과 같다. [3, 2, 4, 1, 0, 5, 7, 6, 8, 9] s와 e가 서로 정한 범위를 벗어나게 되면, 이 루프가 끝나게 된다. 그러면 총 2개의 partition(smaller/bigger)이 만들어진다. 그 다음에는, 양쪽 배열(partition)을 가지고 반복적으로 퀵 정렬 함수를 재귀적으로 호출하면, partition의 값이 1개가 될 때까지 계속적으로 반복해서 작은 값과 큰값의 위치를 바꾸게 된다. 이때, partition이 왼쪽/오른쪽에 1개면 더이상 재귀호출을 하지 않는다. 퀵 정렬 알고리즘은 큰 데이터 집합을 가장 빨리 정렬할 수 있는 알고리즘이다.1234567891011121314151617181920212223242526function qSort(arr) &#123; if (arr.length == 0) &#123; return []; &#125; let left = []; let right = []; const pivot = arr[0]; for (let i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return qSort(left).concat(pivot, qSort(right));&#125;console.log(qSort([3, 9, 4, 7, 0, 1, 5, 8, 6, 2])); // [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]// random input array for testvar a = [];for (var i = 0; i &lt; 10; ++i) &#123; a[i] = Math.floor((Math.random()*100)+1);&#125;console.log(a);console.log(qSort(a)); 위 코드의 시간복잡도를 계산하면 T(n) = nlogn 이다. 이것을 Big-O 표기법으로 나타내면 O(nlogn)이다. partion을 나누는 수가 n번인데, 이는 partion을 계속 나누다 보면, 결국 낱개가 될 때까지 나누기 때문이다. 그런데 1번 나누면, 2번째 나눌 때는 전체에서 2개로 나눈 결과를 가지고 또 나누는 것이기 때문에, 검색해야하는 데이터의 양이 줄어들었다. 마치, 이진 탐색 알고리즘과 같다. 그래서 logn번 검색하게 된다. 즉, n * logn = nlogn인 시간복잡도가 된다. 그러나, 예외도 있다. partion을 나누기 위한 pivot(기준값)이 전체 배열에서 최소값/최대값일 경우, 시간복잡도는 O(n^2)이 된다. 예를 들어, pivot(기준값)이 전체 배열에서 최소값일 경우, 제일 왼쪽으로 들어가고, 나머지 데이터에서 pivot(기준값)이 또 최소값이어서 이런식으로 된다면, 결국 모든 데이터를 모두 돌게 되어, 시간복잡도가 O(n^2)dl 된다. 하지만, 확률적으로 이런 경우는 거의 없기 때문에, 보통의 시간복잡도는 O(n^2)이 된다. 병합 정렬 알고리즘(Merge Sort) 병합 정렬 알고리즘: 함수가 호출 될때마다, 절반씩 잘라서 재귀적으로 함수를 호출하고 맨끝에 제일 작은 조각부터 두 개씩 병합해서 정렬된 배열을 병합해나가는 방식이 병합 정렬 알고리즘이다. 이미 정렬되어 있는 데이터들을 하나로 합해서 정렬하는 방법. 이러한 정렬 방법은 데이터들을 정렬하는 경우에도 사용되지만 파일에 정렬되어 있는 데이터들을 하나로 합쳐서 정렬하는 경우에도 종종 사용된다. 이미 정렬되어 있는 데이터 그룹들 혹은 묶음들을 하나로 합할 때 사용할 수 있다. 병합 정렬 알고리즘을 사용하는 경우 배열 하나에 저장된, 정렬되지 않은 데이터들을 어떤 방식으로 정렬하는 지 알아보자. 예)정렬되지 않은 데이터가 있다고 해보자. 하나의 데이터 배열을 여러 개로 나누어서, 나중에 병합 하기 위해 묶는데, 이 묶은 데이터 그룹을 런(Run)이라고 한다. 2-way 방식은 2개씩 그룹으로 묶는다. 일단 2개씩 묶으면, 각 그룹별로 정렬을 한다. 예를 들어, 6과 1이 하나의 그룹으로 묶였다면, 1이 왼쪽에 오고, 6이 오른쪽에 오는 식으로 정렬을 한다. 그 다음으로는 2개의 런을 묶어서 하나의 런으로 합하도록 정렬한다. 만약 2, 3 런과 5, 7 런이 하나의 런으로 합쳐진 다음, 2, 3, 5, 7 사이에서 정렬이 된다. 이렇게 런(그룹)을 계속 합쳐나가면서 하나의 런으로 모두 합쳐 정렬하는 방식을 병합 정렬 알고리즘이라고 한다. 병합 정렬의 핵심은 1부터 하나의 런에 들어가는 데이터의 수를 2의 배수 기준으로 늘려서 병합하는 과정을 반복하는 것이다. 이와 같이 반복해서 병합하게 되면 결국 전체 데이터를 모두 정렬하게 되는 결과를 얻을 수 있다. 병합 정렬 알고리즘의 성능은 수치적으로만 보면 퀵 정렬 알고리즘과 비슷하다. 퀵 정렬 알고리즘이나 병합 정렬 알고리즘이나 데이터를 나눈 후에 재귀 호출을 사용하기 때문이다. 12345678910111213141516171819202122232425262728293031323334// 퀵정렬과 마찬가지로 분할 정복 알고리즘중 하나이다.function MergeSort(arr) &#123; const len = arr.length; if(len == 1) &#123; return arr; &#125; const middle = Math.floor(len / 2); const left = arr.slice(0, middle); const right = arr.slice(middle, len); function merge(left, right) &#123; let result = []; while(left.length &amp;&amp; right.length) &#123; if( left[0] &lt;= right[0] ) &#123; result.push(left.shift()); &#125; else &#123; result.push(right.shift()); &#125; &#125; while(left.length) &#123; result.push(left.shift()); &#125; while(right.length) &#123; result.push(right.shift()); &#125; return result; &#125; return merge(MergeSort(left), MergeSort(right));&#125; 위 코드의 시간복잡도를 계산하면 T(n) = nlogn 이다. 이것을 Big-O 표기법으로 나타내면 O(nlogn)이다. n개 만큼씩 logn번 돌기 때문에, 병합 정렬 알고리즘의 시간복잡도는 O(nlogn)이 된다. partition이 낱개가 될 때까지 쪼개지니까 n번 호출에, 1번 호출당 검색해야하는 데이터의 양이 절반씩 줄어드니까 logn이다. 따라서 n * logn = nlogn 시간복잡도가 된다. nlogn 시간복잡도는 이진 탐색 알고리즘에서 한 번 돌 때마다 검색 영역에 절반씩 떨어지는 것과 같은 원리이다. 병합 정렬 알고리즘은 물리적으로 배열의 가운데 값으로 partition을 나누기 때문에 최악의 경우에도 시간복잡도는 O(nlogn)이다. 퀵 정렬 알고리즘으로 따지면, pivot(기준값)을 잘 골랐을 때랑 비슷하다. 퀵 정렬 알고리즘도 최악의 경우가 아니라면, 병합 정렬 알고리즘과 같은 시간복잡도는 O(nlogn)이다. 하지만, 병합 정렬 알고리즘은 실행시에 별도의 저장공간을 필요로 하기 때문에, 공간을 사용할 수 없는 경우에는 퀵 정렬 알고리즘을 사용해야 한다. 버블 정렬 알고리즘(Bubble Sort) 버블 정렬 알고리즘: 순차적으로 바로 옆에 있는 데이터와 비교해서 옆의 데이터가 크면 자신과 위치를 바꾼다. 즉, 첫 번째 데이터가 가장 크다면 계속 옆에 있는 데이터와 자리를 바꾸면서 해당 데이터는 결국 맨 끝으로 이동하게 된다. 그리고 두 번째 위치에 있는 데이터를 또다시 옆에 있는 데이터와 비교한다. 이와 같은 과정을 마지막 데이터의 바로 전 데이터까지 반복해서 실행한다. 이 형태가 마치 버블이 부글부글 올라가는 것과 같다고 하여 버블 정렬 알고리즘이라고 한다. 예를 들어, [3, 5, 4, 2, 1] 배열이 있으면, 먼저 3과 5를 비교해서 3이 5보다 크면 둘을 바꾼다. 그런데 여기서는 5가 크므로 그대로 둔다. 그 다음은 5와 4를 비교한다. 이때, 5가 4보다 크므로 그 둘을 바꾼다. 그럼 [3, 4, 5, 2, 1] 배열이 이렇게 바뀐다. 이런식으로 비교하면 결국 5가 제일 마지막으로 이동하게 된다. 즉, [3, 4, 2, 1, 5] 배열이 된다. 그럼 가장 큰 수인 5가 배열에 제일 오른쪽으로 이동하게 되고, 다시 맨 처음부터 이웃 숫자끼리 비교한다. 이런식으로 가장 큰 수를 오른쪽으로 이동시켜 정렬하는 방식을 버블 정렬 알고리즘이라고 한다. 성능이 좋은 편이 아니라, 자주 사용되지는 않는다. 12345678910111213141516171819// 스왑 헬퍼 =&gt; 배열의 위치를 바꾼다.function swap(arr, index1, index2) &#123; let temp = arr[index1]; arr[index1] = arr[index2]; arr[index2] = temp;&#125;// 버블 정렬은 서로 이웃한 데이터들을 비교하며 가장 큰 데이터를 가장 뒤로 보내며 정렬하는 방식function BubbleSort(arr) &#123; let len = arr.length; for(let outer = len; outer &gt; 1; outer--) &#123; for(let inner = 0; inner &lt; outer; inner++) &#123; if( arr[inner] &gt; arr[inner + 1]) &#123; swap(arr, inner, inner+1); &#125; &#125; &#125; return arr;&#125;; 위 코드의 시간복잡도를 계산하면 T(n) = n^2 이다. 이것을 Big-O 표기법으로 나타내면 O(n^2)이다. 앞에서부터 한 개씩 뒤로 가면서 전체 배열 데이터를 돌기 때문에 n^2 만큼 시간이 걸린다. 선택 정렬 알고리즘(Selection Sort) 선택 정렬 알고리즘: 데이터의 처음부터 끝까지 쭉 훑어가면서 가장 작은 값을 찾아 그 값을 첫 번째 데이터와 자리를 바꾸고, 두 번째로 작은 데이터를 찾아 두 번째의 데이터와 자리를 바꾸는 방법으로 구현하는 정렬 알고리즘이다. 예를 들어, [3, 5, 4, 2, 1] 배열이 있으면, 변수 min = 3으로 할당하고, 그 다음 데이터인 5부터 하나씩 비교해 나간다. 이때, 가장 작은 값이 1 이므로 맨 앞에 있는 3과 1을 바꾼다. 그리고, 다시 두번째 요소인 5부터 오른쪽으로 하나씩 비교하면서 가장 작은 값을 찾아 5와 바꾼다. 이런식으로 정렬하는 방식이 선택 정렬 알고리즘이다. 123456789101112131415161718192021// 스왑 헬퍼 =&gt; 배열의 위치를 바꾼다.function swap(arr, index1, index2) &#123; let temp = arr[index1]; arr[index1] = arr[index2]; arr[index2] = temp;&#125;// 선택 정렬은 정렬되지 않은 데이터들에 대해 가장 작은 데이터를 찾아 가장 앞의 데이터와 교환해나가는 방식function SelectionSort(arr) &#123; let min; for(let outer = 0; outer &lt; arr.length -1; ++outer) &#123; min = outer; for(let inner = outer + 1; inner &lt; arr.length; ++inner) &#123; if( arr[inner] &lt; arr[min] ) &#123; min = inner; &#125; &#125; swap(arr, outer, min); &#125; return arr;&#125; 위 코드의 시간복잡도를 계산하면 T(n) = n^2 이다. 이것을 Big-O 표기법으로 나타내면 O(n^2)이다. 앞에서도 한칸씩 가면서 갈때마다 각 배열 요소를 한번씩 다시 돌기 때문에, n^2 만큼 시간이 걸린다.","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"https://cheonmro.github.io/categories/Computer-Science/"}],"tags":[{"name":"sort algorithms","slug":"sort-algorithms","permalink":"https://cheonmro.github.io/tags/sort-algorithms/"}]},{"title":"탐색(search) 알고리즘","slug":"search-algorithms","date":"2018-10-31T02:54:03.000Z","updated":"2018-11-05T07:11:42.623Z","comments":true,"path":"2018/10/31/search-algorithms/","link":"","permalink":"https://cheonmro.github.io/2018/10/31/search-algorithms/","excerpt":"","text":"탐색 알고리즘 탐색 알고리즘이란, 데이터를 탐색하면서 어떤 값을 찾는 알고리즘을 말한다. 탐색 알고리즘 종류 순차 탐색 알고리즘(linear search) 이진 탐색 알고리즘(binary search) 순차 탐색 알고리즘(linear search) 순차 탐색 알고리즘: 맨 앞에서부터 순서대로 탐색을 진행하는 알고리즘1234for(i = 0; i &lt; array.length; i++) &#123; if(array[i] === target) return i;&#125; 위 for문의 경우, 데이터의 수가 n개 일때, 최악의 경우에 해당하는 연산횟수는 n이다. T(n) = n, 시간복잡도는 O(n)이다. 이진 탐색 알고리즘(binary search) 이진 탐색 알고리즘: 데이터가 정렬된 상태에서, 모든 데이터의 중간부터 시작해서 크기 비교를 통해 반씩 쪼개면서 탐색하는 알고리즘이다. 즉, 배열에 저장된 데이터는 정렬되어야 할 수 있는 탐색 알고리즘이다. 예를 들어, array = [1, 2, 3, 4, 5, 6, 7, 8, 9]라는 배열이 있다고 해보자. 이 중에서 데이터 ‘6’(key 값)을 찾는다고 하면, 먼저 배열의 중간인 5와 비교한다. 이때, key 값이 더 크기 때문에 key 값은 중간값인 5를 기준으로 배열에서 오른쪽에 있다는 뜻이다. 그럼 다시 오른쪽 데이터(6, 7, 8, 9) 중에서 중간값 7를 찾아서 key 값과 비교한다. 이때, key 값이 더 작기 때문에 key 값은 중간값인 7보다 앞쪽에 있다는 뜻이다. 결국 key 값 6을 찾을 수 있게 된다. 이렇게 한번 처리가 진행될 때마다, 검색해야 하는 데이터의 양이 절반씩 떨어지는 알고리즘을 이진 탐색 알고리즘이라고 한다. 이를, 시간 복잡도로 나타내면 O(logN)이다.12345678910111213141516171819202122const findAge = (num, array) =&gt; &#123; const midPoint = Math.floor(array.length/2); // 2 if(array[midPoint] === num) &#123; return true; // 1번 실행 &#125; if(array[midPoint] &lt; num) &#123; for (let i = midPoint + 1; i &lt; array.length;) &#123; if(array[i] === num) &#123; return true; &#125; &#125; &#125; else &#123; for (let i = 0; i &lt; midPoint;) &#123; if(array[i] === num) &#123; return true; &#125; &#125; &#125;&#125;const sortedAges = [21, 23, 25, 27, 29];console.log(findAge(27, sortedAges)) // true 위 코드의 시간복잡도를 계산하면 T(n) = 1 + n/2 이다. 이것을 Big-O 표기법으로 나타내면 O(logn)이다. 재귀함수를 이용하면 다음과 같이 작성할 수도 있다.123456789101112131415const binarySearch = (numArray, key) =&gt; &#123; const middleIdx = Math.floor(numArray.length / 2); const middleElem = numArray[middleIdx]; if (middleElem === key) return true; else if (middleElem &lt; key &amp;&amp; numArray.length &gt; 1) &#123; return binarySearch(numArray.splice(middleIdx, numArray.length), key); &#125; else if (middleElem &gt; key &amp;&amp; numArray.length &gt; 1) &#123; return binarySearch(numArray.splice(0, middleIdx), key); &#125; else return false;&#125;console.log(binarySearch([21, 23, 25, 27, 29], 27)); // true","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"https://cheonmro.github.io/categories/Computer-Science/"}],"tags":[{"name":"search algorithms","slug":"search-algorithms","permalink":"https://cheonmro.github.io/tags/search-algorithms/"}]},{"title":"3. Fibonacci","slug":"fibonacci","date":"2018-10-31T01:53:41.000Z","updated":"2018-10-31T01:53:41.173Z","comments":true,"path":"2018/10/31/fibonacci/","link":"","permalink":"https://cheonmro.github.io/2018/10/31/fibonacci/","excerpt":"","text":"What is Fibonacci?Fibonacci 수열이란, 다음 수는 앞의 두 수의 합으로 이루어진 수열을 말한다.규칙에 따라 수를 나열해 보면, 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144…와 같은 수열이 된다. [Problem]피보나치 수는 F(0) = 0, F(1) = 1일 때, 2 이상의 n에 대하여 F(n) = F(n-1) + F(n-2) 가 적용되는 점화식입니다.2 이상의 n이 입력되었을 때, fibonacci 함수를 제작하여 n번째 피보나치 수를 반환해 주세요.예를 들어 n = 3이라면 2를 반환해주면 됩니다. 즉, 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144…에서 3번째 피보나치의 수는 2이다. [Algorithms] n이 0일 경우, 0을 리턴하고, 1일 경우, 1을 리턴한다.(피보나치 수열에서 0번째는 0, 1번째는 1이기 때문이다.) n이 2이상일 경우, 앞의 두 수의 합으로 계산되는 재귀 호출을 사용하여 구현한다. 함수에서 n이라는 정수를 받을 것이고, n은 몇 번째 피보나치 수를 구할 것인지를 의미한다. 예를 들어, n이 3이면, 피보나치 수열 중 3번째 피보나치 수를 구하는 함수를 구현하는 것이고, 그 값은 2이다. [Solution]123456789101112function fibonacci(num)&#123; var a = 1, b = 0, temp; while (num &gt;= 0)&#123; temp = a; a = a + b; b = temp; num--; &#125; return b;&#125; [Best Practice]123456789function fibonacci(num) &#123; if(num === 0) &#123; return 0; &#125; else if(num === 1) &#123; return 1; &#125; return fibonacci(num - 1) + fibonacci(num - 2);&#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://cheonmro.github.io/categories/Algorithms/"}],"tags":[{"name":"Fibonacci","slug":"Fibonacci","permalink":"https://cheonmro.github.io/tags/Fibonacci/"}]},{"title":"Pass-by-Value vs Pass-by-Reference","slug":"pass-by-value-and-pass-by-reference","date":"2018-09-14T03:28:23.000Z","updated":"2018-09-14T03:28:23.071Z","comments":true,"path":"2018/09/14/pass-by-value-and-pass-by-reference/","link":"","permalink":"https://cheonmro.github.io/2018/09/14/pass-by-value-and-pass-by-reference/","excerpt":"","text":"Pass-by-Value 기본자료형의 값은 값(Value)으로 전달한다.(원래 값은 그대로 존재하고, 그 값이 복사되어 전달된다.) 기본자료형의 값은 한번 정해지면 변경할 수 없다.(Immutable, 재할당은 가능하지만 기존의 값은 메모리에 저장되어 있다.) 기본자료형의 값은 런타임(변수 할당 시점)에 메모리의 스택 영역(Stack Segment)에 고정된 메모리 영역을 점유하고 저장된다. 123456789var a = 1;var b = a; // a의 값(1)이 복사되어 전달console.log(a, b); // 1 1console.log(a === b); // truea = 10; // 재할당은 가능하지만, 기존의 값은 메모리에 저장되어 있다.console.log(a, b); // 10 1console.log(a === b); // false Pass-by-Reference 객체형의 값은 실제 값이 아닌 값을 참조하여 전달한다.(값의 주소(address)를 참조한다.) 객체형은 변경 가능(mutable)한 값으로, 프로퍼티를 변경, 추가, 삭제가 가능하다. 객체형의 값은 동적으로 변화할 수 있어서 어느 정도의 메모리 공간이 필요한지를 알 수가 없기 때문에, 런타임(변수 할당 시점)에 메모리 공간을 확보하고, 메모리의 힙 영역(Heap Segment)에 저장된다. 123456789var obj1 = &#123; val: 100 &#125;var obj2 = obj1; // 값을 참조하여 전달console.log(obj1.val, obj2.val); // 100 100console.log(obj1 === obj2); // trueobj2.val = 200; // 객체의 값은 변경 가능console.log(obj1.val, obj2.val); // 200 200console.log(obj1 === obj2); // true 두 변수사이에 같은 내용을 할당하여도, 각 별개의 객체를 생성하여, 서로 다른 참조값을 가진다.12345678910var obj1 = &#123; val: 100 &#125;;var obj2 = &#123; val: 100 &#125;;console.log(obj1.val, obj2.val); // 100 100console.log(obj1 === obj2); // false -&gt; 서로 다른 참조값을 가지기 때문에, 두 변수는 같지 않다.var obj3 = obj2;console.log(obj3.val, obj2.val); // 100 100console.log(obj3 === obj2); // true -&gt; 서로 같은 참조값을 가지기 때문에, 두 변수는 같다. 서로 다른 빈 객체 참조 및 모두 같은 빈 객체 참조(예제)123456789101112// a, b, c는 각각 다른 빈 객체를 참조var a = &#123;&#125;;var b = &#123;&#125;;var c = &#123;&#125;;console.log(a === b, a === c, b === c); // false false false// a, b, c는 모두 같은 빈 객체를 참조a = b = c = &#123;&#125;;console.log(a === b, a === c, b === c); // true true true","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://cheonmro.github.io/categories/Javascript/"}],"tags":[{"name":"Object","slug":"Object","permalink":"https://cheonmro.github.io/tags/Object/"}]},{"title":"알고리즘 성능분석을 위한 복잡도 활용법","slug":"complexity-for-algorithms","date":"2018-09-14T02:55:28.000Z","updated":"2018-10-31T02:14:11.222Z","comments":true,"path":"2018/09/14/complexity-for-algorithms/","link":"","permalink":"https://cheonmro.github.io/2018/09/14/complexity-for-algorithms/","excerpt":"","text":"알고리즘 알고리즘이란, 어떤 목적이나 결과물(프로그램)을 만들어내기 위해 거쳐야 하는 일련의 과정들을 말한다. 어떤 프로그램을 만드는 데 있어서 방법은 여러가지가 있을 수 있다. 예를 들어, 어떤 케익 1개를 100가지 방법으로 자를 수 있는 것처럼, 하나의 문제를 여러가지의 알고리즘으로 풀 수 있다. 그렇기 때문에, 여러 알고리즘 중 최선의 알고리즘으로 하는 것이 좋다. 어떤 프로그램 개발을 위해 코딩을 할 때, 여러가지의 알고리즘으로 풀 수 있지만, 최선의 알고리즘으로 푸는 것이 (웹페이지 등의) 성능을 위해서 좋다. 이때, 이 성능 분석을 위해 필요한 것이 복잡도이다. 복잡도 복잡도에는 크게 2가지가 있다. 시간 복잡도: 알고리즘이 문제를 해결하기 위한 연산의 횟수(얼마나 많은 연산이 수행되는지) 공간 복잡도: 메모리 사용량(얼마나 많은 양의 메모리를 차지하는지) 이런 복잡도를 가지고 작성한 코드 알고리즘의 성능을 분석해서, 어떻게 하면 더 적은 연산으로(시간 복잡도), 더 적은 메모리를 차지하여(공간 복잡도) (웹페이지 등의) 성능을 좋게 할 수 있다. 알고리즘의 성능을 평가하기 위해서는 작성된 코드의 시간복잡도 및 공간복잡도를 계산하고, 이를 점근적 표기법으로 나타내어 평가한다. 이때 점근적 표기법이란, 각 알고리즘이 주어진 데이터의 크기를 기준으로 코드에서의 연산의 횟수 또는 메모리 사용량이 얼마나 되는지를 비교할 수 있는 방법이다. 이 방법에는 Big-O, 오메가, 세타 등이 있다. 이 방법중에서 Big-O 표기법에 대해 알아보자. Big-O 표기법 Big-O 표기법이란, 계산된 복잡도를 O(n) 이런식으로 표기하는 방식인데, 이때, n은 최고차항의 차수가 된다. 예를 들어, T(n) = n^2+ 2n + 1 으로 시간복잡도가 계산되었다면, O(n^2)으로 표기하는 것이 Big-O 표기법이다. 대표적인 복잡도를 Big-O 표기법으로 작성한 것은 다음과 같다. O(1): 상수 시간 입력값 n이 주어졌을 때, 알고리즘이 문제를 해결하는 데 오직 한 단계만 거친다. O(logn): 로그 시간 입력값 n이 주어졌을 때, 문제를 해결하는데 필요한 단계들이 연산마다 특정 요인에 의해 줄어든다. O(n): 직선적 시간 문제를 해결하기 위한 단계의 수와 입력값 n이 1:1 관계를 가진다. O(n^2): 2차 시간 문제를 해결하기 위한 단계의 수는 입력값 n의 제곱이다. O(c^n): 지수 시간 문제를 해결하기 위한 단계의 수는 주어진 상수값 c의 n 제곱이다. 복잡도의 크기는 다음과 같다.1O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) 보통 O(n^2) 이상의 복잡도를 가지는 알고리즘은 좋지 않다. 복잡도 계산하기 O(1): 상수 시간(constant time) 알고리즘이 문제를 해결하는 데 오직 한 단계만 거친다. O(1)은 여러가지 경우가 있겠지만, 예를 들면 다음과 같은 코드들이 있다. 1. 전달되는 인자를 반환하는 경우12345function addTwoNumbers(num1, num2) &#123; return num1 + num2; // 1번 실행&#125;console.log(addTwoNumbers(1, 3)); // 4 시간복잡도를 T(n)이라고 하는데, 위 코드의 시간복잡도를 계산하면 T(n) = 1 이다. 이것을 Big-O 표기법으로 나타내면 O(1)이다. 1인 이유는 Big-O 표기법에서 O(n)의 n은 최고차항의 차수를 나타내는데, 위의 경우 n^0이므로, 1이된다. 2. 정렬되어 있는 배열에서 최소값과 최대값을 구하는 경우12345678const numbers = [1, 2, 3, 4, 5, 10]; // 배열의 요소들이 순서대로 정렬되어 있다.function FindLargestNumber(items) &#123; let smallest = items[0]; // 1번 실행 let largest = items[items.length - 1]; // 1번 실행 return (largest - smallest); // 1번 실행&#125;console.log(FindLargestNumber(numbers)); // 9 위 코드의 시간복잡도를 계산하면 T(n) = 3 이다. 이것을 Big-O 표기법으로 나타내면 O(1)이다. 3. 값을 검색할 때, 객체에서 키를 알거나, 배열에서 인덱스를 알고 있으면 언제나 한 단계만 걸린다.1234567891011function isCryptoCurrency(name) &#123; return cryptoCurrency[name]; // 1번 실행&#125;var cryptoCurrency = &#123; &apos;bitcoin&apos;: true, &apos;ripple&apos;: true, &apos;bitcoinCash&apos;: true&#125;console.log(isCryptoCurrency(&apos;bitcoin&apos;)); // true 위 코드의 시간복잡도를 계산하면 T(n) = 1 이다. 이것을 Big-O 표기법으로 나타내면 O(1)이다. O(logN): 로그 시간(log time) 문제를 해결하는데 필요한 단계들이 연산마다 특정 요인에 의해 줄어든다. 배열에서 값을 찾을 때, 어느 쪽에서 시작할지를 알고 있으면, 검색하는 시간이 줄어든다. 대표적인 것이 이진 검색 알고리즘이다.(binary search)12345678910111213141516171819202122function findAge(num, array) &#123; var midPoint = Math.floor(array.length/2); if(array[midPoint] === num) &#123; return true; // 1번 실행 &#125; if(array[midPoint] &lt; num) &#123; for (let i = midPoint + 1; i &lt; array.length) &#123; if(array[i] === num) &#123; return true; &#125; &#125; n/2번 실행 &#125; else &#123; for (let i = 0; i &lt; midPoint) &#123; if(array[i] === num) &#123; return true; &#125; &#125; n/2번 실행 &#125;&#125;console.log(findAge(27, sortedAges))sortedAges = [21, 23, 25, 27, 29]; 위 코드의 시간복잡도를 계산하면 T(n) = 1 + n/2 이다. 이것을 Big-O 표기법으로 나타내면 O(logn)이다. O(n): 직선적 시간(linear time) 문제를 해결하기 위한 단계의 수와 입력값 n이 1:1 관계를 가진다. for문을 1번 사용하는 경우 예를 들어, 배열이 정렬되어 있지 않을 경우, 최소 및 최대값을 찾기 위해 배열의 모든 숫자를 탐색하여, 비교를 수행한다. 이 경우, 수행시간은 배열의 크기에 따라 늘어난다.123456789101112131415const numbers = [1, 9, 3, 10, 16];function FindLargestGap(items) &#123; let smallest = items[0]; // 1번 실행 let largest = items[0]; // 1번 실행 for (let i = 1; i &lt; items.length; i++) &#123; if (items[i] &lt; smallest) &#123; smallest = items[i]; &#125; else if (items[i] &gt; largest) &#123; largest = items[i]; &#125; &#125; // n번 실행 return (largest - smallest); // 1번 실행&#125;console.log(FindLargestGap(numbers)); 위 코드의 시간복잡도를 계산하면 T(n) = 3 + n 이다. 이것을 Big-O 표기법으로 나타내면 O(n)이다. O(n^2): 2차 시간(quadratic time) 문제를 해결하기 위한 단계의 수는 입력값 n의 제곱이다. 중첩 for 문을 사용할 경우, 첫번째 for 문의 각 요소(n) x 두번째(안에있는) for 문의 각 요소(n) = n x n12345678910111213141516171819const number = [2, 10, 1, 4, 3, 10, 5];function FindLargestGap(items) &#123; let gap; // 1번 실행 let maxGap = 0; // 1번 실행 for (let i = 0; i &lt; items.length; i++) &#123; for(let j = 0; j &lt; items.length; j++) &#123; gap = items[i] - items[j]; if (gap &lt; 0) &#123; gap = gap * -1; &#125; if (gap &gt; maxGap) &#123; maxGap = gap; &#125; &#125; &#125; // n^2번 실행 return maxGap; // 1번 실행&#125;console.log(FindLargestGap(numbers)); // 9 위 코드의 시간복잡도를 계산하면 T(n) = 3 + n^2 이다. 이것을 Big-O 표기법으로 나타내면 O(n^2)이다. O(c^n): 지수 시간(exponential time) 문제를 해결하기 위한 단계의 수는 주어진 상수값 c의 n 제곱이다. 지수 시간은 문제를 풀기 위해, 모든 조합과 방법을 시도할 때 사용된다. 예를 들어, 2^n이 걸리는 피보나치 수열이 있다.123456789function fibonacci(num) &#123; if(num === 0) &#123; return 0; &#125; else if(num === 1) &#123; return 1; &#125; return fibonacci(num - 1) + fibonacci(num - 2);&#125; 위 코드는 함수가 호출될 때마다, 앞의 두 수에 대한 함수를 호출하기 때문에, 두번씩 호출하게 된다.(구조는 트리로 되어 있다.) 위 코드의 시간복잡도를 계산하면 T(n) = 2^n 이다. 이것을 Big-O 표기법으로 나타내면 O(2^n)이다. Worst Case, Best Case, and Average Case 시간 복잡도 계산을 위한 연산 횟수를 카운팅할때, 3가지의 시나리오가 있다. Worst Case: 입력값 n의 규모가 동일할 때, 가장 많은 횟수의 연산으로 처리되는 경우 Best Case: 입력값 n의 규모가 동일할 때, 가장 적은 횟수의 연산으로 처리되는 경우 Average Case: 입력값 n의 규모가 동일할 때, 평균적인 횟수의 연산으로 처리되는 경우 예를 들면 다음과 같은 코드가 있다.12345678910111213function getNumber7(items) &#123; for (let i = 0; i &lt; items.length; i++) &#123; if (i === 7) &#123; return i &#125; &#125;&#125;getNumber7(numbers)// numbers = [7, 5, 3, 1]인 경우, 1번만 실행(Best Case)// numbers = [5, 7, 3, 1]인 경우, 2번만 실행// numbers = [1, 3, 5, 7]인 경우, 4번 모두 실행(Worst Case)","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"https://cheonmro.github.io/categories/Computer-Science/"}],"tags":[{"name":"Complexity","slug":"Complexity","permalink":"https://cheonmro.github.io/tags/Complexity/"},{"name":"Big-O","slug":"Big-O","permalink":"https://cheonmro.github.io/tags/Big-O/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://cheonmro.github.io/tags/Algorithms/"}]},{"title":"Hoisting(호이스팅)이란 무엇인가?","slug":"what-is-hoisting","date":"2018-09-13T06:03:47.000Z","updated":"2018-09-13T06:03:47.142Z","comments":true,"path":"2018/09/13/what-is-hoisting/","link":"","permalink":"https://cheonmro.github.io/2018/09/13/what-is-hoisting/","excerpt":"","text":"Hoisting(호이스팅) Hoisting(호이스팅)이란, Javascript의 모든 선언문(var, let, const, function, function*, class)이 해당 Scope의 최상단으로 옮겨진 것처럼 행동하는 것을 말한다. C 언어 등 C-family 언어와는 다르게, Javascript의 모든 선언문은 ‘호이스팅’이 되는 Javascript만의 특징이 있다.Hoisting에는 크게 2가지가 있다. 변수 호이스팅 함수 호이스팅 변수 호이스팅(Variable Hoisting) 변수 호이스팅이란, Javascript의 변수 선언문(var, let, const)이 해당 Scope의 최상단으로 옮겨진 것처럼 행동하는 것을 말한다. 즉, Javascript의 모든 선언문이 선언되기 전부터, 변수를 참조할 수 있게 된다.1234567console.log(num); // 1. -&gt; undefinedvar num = 100;console.log(num); // 2. -&gt; 100&#123; var num = 5;&#125;console.log(num); // 3. -&gt; 5 위 코드를 처음 봤을 때, 첫줄의 출력 값은 Error가 날 것이라고 예상 할 수 있다. 그러나, 위 Javascript의 코드는 변수 호이스팅이 있기 때문에, undefined를 출력한다. Javascript 엔진이 위 코드를 읽어들일 때, 제일 먼저 선언문부터 읽는다. 그리고, 그 중 제일 첫번째로 선언된 변수를 찾아, 그 변수를 선언하고, 초기화를 한다. 이때, 변수의 호이스팅 때문에, 선언문은 해당 Scope의 최상단, 즉 제일 윗줄로 옮겨진 것처럼 행동하여, ‘num’을 출력(console.log(num)) 하기 전에, 변수가 존재하는 것처럼 행동하고, 이 변수는 선언이 되고, 초기화까지 되었기 때문에(변수를 초기화하면, ‘undefined’를 메모리에 할당한다.), console.log(num)의 결과로는 ‘undefined’가 출력된다. 기본적으로, var 키워드로 선언된 변수는 선언 단계와 초기화 단계가 한번에 이루어진다. 변수가 선언이 될 때, 스코프에 Variable Object가 생성이 되고, 여기에 변수가 등록이 되어있어, 변수 선언문 이전에 변수에 접근해도 에러가 발생하지 않는다. 다만, 초기화 단계에서 변수는 메모리에 공간을 확보한 후, undefined를 저장하기 때문에, undefined를 반환한다. 이후, 변수 할당문(var num = 100;)에 도달하여 값의 할당이 이루어진다. 호이스팅 관점에서 다시 코드를 보자.1234567console.log(num); // 1. -&gt; undefinedvar num = 100;console.log(num); // 2. -&gt; 100&#123; var num = 5;&#125;console.log(num); // 3. -&gt; 5 ‘1.’이 실행되기 이전에 var num = 100;이 호이스팅되어 ‘1.’ 구문 위에(최상단) var num;가 옮겨진 것처럼 된다. 실제로 변수 선언이 코드 레벨로 옮겨 진것은 아니고, 변수 객체(Variable Object)에 등록되고, undefined로 초기화된 것이다. 그러나, 변수 선언 단계와 초기화 단계가 할당 단계와 분리되어 진행되기 때문에, 이 단계에서는 num에 undefined가 할당되어 있다. 변수 num에 값이 할당되는 것은 두번째 행(var num = 100;)에서 실시된다. 마지막 줄에서는 숫자 5가 출력이 되는데, 이는 코드 블록안에서 새롭게 변수가 중복 선언이 되어 num의 값이 5로 바뀌었기 때문이다. Javascript는 function-level scope를 갖기 때문에, 변수의 유효범위가 코드 블록에는 영향이 없다. 함수 호이스팅(Function Hoisting) 함수 호이스팅이란, Javascript의 함수 선언문(function)이 해당 Scope의 최상단으로 옮겨진 것처럼 행동하는 것을 말한다. 즉, Javascript의 모든 선언문이 선언되기 전부터, 함수를 호출할 수 있게 된다. 함수선언의 위치와는 상관없이 코드 내 어느 곳에서든지 호출이 가능하게 만드는 것을 말한다. 단, 함수선언식에만 적용이 된다. 함수선언식으로 정의된 함수는 자바스크립트 엔진이 스크립트가 로딩되는 시점에 바로 초기화하고 이를 VO(variable object)에 저장한다. 즉, 함수 선언, 초기화, 할당이 한번에 이루어진다. 그렇기 때문에 함수 선언의 위치와는 상관없이 소스 내 어느 곳에서든지 호출이 가능하다.12345square(5); // 25function square(number) &#123; return number * number;&#125; 다음은 함수표현식으로 함수를 정의한 경우이다.12345var res = square(5); // TypeError: square is not a functionvar square = function(number) &#123; return number * number;&#125; 위와 같이 에러가 발생한 이유는, 함수표현식의 경우는 함수 호이스팅이 아니라, 변수 호이스팅이 발생하기 때문이다. 함수표현식은 함수선언식과는 달리 스크립트 로딩 시점에 변수 객체(VO)에 함수를 할당하지 않고, runtime에 해석되고 실행된다. 즉, 선언과 초기화까지만 하여, undefined를 호출하는 것과 같기 때문에, 에러가 난다. 그래서, 더글러스 크락포드는 ‘함수표현식’만 사용할 것을 권한다. 왜냐하면, 에러가 나서 미리 호출을 방지하기 때문이다. 왠만하면, 선언문 이전에 호출하지 않는 것이 좋다.변수와 함수의 호이스팅의 차이점: 함수 호이스팅: 함수선언문 이전에 함수가 호출이 된다.(함수 선언식으로 함수를 선언했을 경우) 변수 호이스팅: 함수표현식으로 함수를 선언했을 경우, 함수표현식 이전에 함수를 호출하면, 에러가 난다. 왜냐하면, 함수표현식은 변수 호이스팅을 따르기 때문에, 할당은 안되고, 초기화까지만 되기 때문이다. 즉, 초기화까지만 되면 undefined를 호출하는 것과 같기 때문이다. undefiend() 이런형식으로 나온다는 의미이기 때문에, 에러가 난다.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://cheonmro.github.io/categories/Javascript/"}],"tags":[{"name":"Hoisting","slug":"Hoisting","permalink":"https://cheonmro.github.io/tags/Hoisting/"}]},{"title":"DOM(Document Object Model)이란 무엇인가?","slug":"what-is-dom","date":"2018-09-13T03:01:26.000Z","updated":"2018-09-13T03:01:26.985Z","comments":true,"path":"2018/09/13/what-is-dom/","link":"","permalink":"https://cheonmro.github.io/2018/09/13/what-is-dom/","excerpt":"","text":"DOM(Document Object Model) DOM이란, 브라우저가 서버에게 요청하여, 응답으로 받은 웹 문서(HTML, XML, SVG 등)를 브라우저의 렌더링 엔진이 로드하고, 파싱하여 브라우저가 이해할 수 있는 형태로 구성된 것을 말한다. 이 DOM은 자바스크립트를 이용해 동적으로 변경이 가능하고, 이 변경된 DOM은 렌더링에 반영된다. 이때, 자바스크립트로 이 DOM에 접근하고 수정할 수 있는 DOM API가 있으며, 이 DOM API가 가지고 있는 프로퍼티와 메소드로 정적인 웹페이지에 접근하여 동적으로 변경할 수 있다. DOM은 W3C의 공식 표준이고, HTML, JavaScript에서 정의한 표준이 아니다. DOM의 기능 HTML 문서에 대한 모델 구성 브라우저가 이해할 수 있는 형태로 HTML 문서를 모델로 구성하여 메모리에 생성하는데, 이때 모델은 객체의 트리로 구성된다. HTML 문서 내의 각 요소에 접근 및 수정 객체의 트리로 구성되어있는 모델 내의 각 객체에 접근 및 수정할 수 있는 프로퍼티와 메소드를 제공한다. 이때, DOM이 수정되면, 브라우저를 통해 사용자가 보게 될 내용 또한 변경된다. DOM 구조 DOM 구조는 브라우저가 이해할 수 있는 형태로 HTML 문서를 모델로 구성하여 메모리에 생성하는데, 이때 모델은 객체의 트리로 구성되었다고 하여, DOM tree라고 부른다. DOM tree는 HTML 문서의 모든 요소와 요소의 attribute, text 등을 각각의 객체로 만들고, 이들 객체간에 관계를 부자 관계로 표현하는 tree(나무 가지)처럼 구성되어있다. 출처: DOM 구조 위 구조를 코드로 작성하면 다음과 같다.12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;h1&gt;Cryptocurrency&lt;/h1&gt; &lt;ul&gt; &lt;li id=&quot;one&quot;&gt;Bitcoin&lt;/li&gt; &lt;li id=&quot;two&quot;&gt;Bitcoin Cash&lt;/li&gt; &lt;li id=&quot;three&quot;&gt;Ripple&lt;/li&gt; &lt;li id=&quot;four&quot;&gt;Ethereum&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; DOM tree 노드의 종류DOM tree는 4 종류의 노드로 구성된다. 문서 노드(Document Node) 요소 노드(Element Node) 어트리뷰트 노드(Attribute Node) 텍스트 노드(Text Node) 문서 노드(Document Node) Document Node란, DOM tree에 접근하기 위한 시작점(entry point)이다.DOM tree의 최상위에 존재하고, DOM tree에 있는 요소, 어트리뷰트, 또는 텍스트 노드 등에 접근하기 위해서는 Document Node를 통해 접근해야 한다. Document Node의 프로퍼티 및 메소드는 MDN에서 확인할 수 있다. 요소 노드(Element Node) Element Node란, html, body, div 등 HTML 요소를 말한다. Element Node는 서로 부자 관계를 가지며, 이 부자 관계를 통해 정보를 구조화한다. Attribute Node 또는 Text Node에 접근하기 위해서는 먼저 Element Node에 접근해야 한다. 모든 Element Node는 요소별 특성을 표현하기 위해 HTMLElement 객체를 상속한 객체로 구성된다. Element Node의 프로퍼티 및 메소드는 MDN에서 확인할 수 있다. 어트리뷰트 노드(Attribute Node) Attribute Node란, HTML 요소의 어트리뷰트로, HTML 요소의 자식이 아닌 일부이다. Attribute Node의 프로퍼티 및 메소드는 MDN에서 확인할 수 있다. 텍스트 노드(Text Node) Text Node란, 텍스트로 표현된 Element Node의 자식 요소이다. DOM tree의 최하단에 있는 Node로, Text Node는 자식 노드를 가질 수 없다. Text Node의 프로퍼티 및 메소드는 MDN에서 확인할 수 있다. DOM tree의 객체 구성 출처: DOM tree의 객체 구성 DOM tree의 객체는 위 그림과 같이 구성되어 있다. 또한, 모든 Element Node는 HTMLElement 객체를 상속한 객체로 구성되어 있다.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://cheonmro.github.io/categories/Javascript/"}],"tags":[{"name":"DOM","slug":"DOM","permalink":"https://cheonmro.github.io/tags/DOM/"}]},{"title":"==와 ===의 차이점","slug":"strict-equal-operator-difference","date":"2018-09-12T03:33:31.000Z","updated":"2018-09-12T03:33:31.421Z","comments":true,"path":"2018/09/12/strict-equal-operator-difference/","link":"","permalink":"https://cheonmro.github.io/2018/09/12/strict-equal-operator-difference/","excerpt":"","text":"[ ==와 ===의 차이점 ] ==는 Equal Operator이고, ===는 Strict Equal Operator이다. ==는 a == b 라고 할때, a와 b의 값이 같은지를 비교해서, 같으면 true, 다르면 false라고 한다.(값만 같으면 true이다.) ===는 Strict, 즉 엄격한 Equal Operator로써, “엄격하게” 같음을 비교할 때 사용하는 연산자이다. ===는 a === b 라고 할때, 값과 값의 종류(Data Type)가 모두 같은지를 비교해서, 같으면 true, 다르면 false라고 한다. [기본자료형(Primitive)] 값은 똑같이 1이지만 값의 종류가 숫자냐, 문자열이냐에 따라 === 연산자를 사용할 때 결과가 false라고 나온다.1234var a = 1;var b = &quot;1&quot;;console.log(a == b); // trueconsole.log(a === b); // false null과 undefined는 공통적으로 값이 없음을 뜻하지만, 값의 종류(Data Type)가 다르기 때문에, === 연산자를 사용할 때 결과가 false라고 나온다.12console.log(null == undefined); // trueconsole.log(null === undefined); // false 기본적으로 1은 true, 0은 false로 나타낼 수 있지만, 데이터 타입은 다르다.12console.log(true == 1); // trueconsole.log(true === 1); // false 숫자 0과 문자열 “0”, “”1234console.log(0 == &quot;0&quot;); // trueconsole.log(0 === &quot;0&quot;); // falseconsole.log(0 == &quot;&quot;); // trueconsole.log(0 === &quot;&quot;); // false NaN은 Not a Number라는 뜻으로, 숫자가 아닌 것을 의미하지만 그 값 자체끼리는 같지 않다.12console.log(NaN == NaN); // falseconsole.log(NaN === NaN); // false 배열, 또는 객체 등의 경우는 어떨까? [객체형(Object type)] 배열을 할당할때, 각 변수는 각 메모리의 주소를 참조한다. 두 변수 a, b의 값과 데이터 타입이 같지만, 이와 상관없이 참조하는 메모리의 주소가 다르기 때문에 두 a, b는 같지 않다.1234var a = [1,2,3];var b = [1,2,3];console.log(a == b); // falseconsole.log(a === b); // false 새로운 변수 c에 변수 b를 할당해주면, 변수 c도 b가 참조하는 같은 메모리의 주소를 참조하게 되어, 두 변수 c, b는 같다. 이때, c, b의 값과 데이터 타입이 같기 때문에, ==와 ===의 결과값이 동일하다.12345var a = [1,2,3];var b = [1,2,3];var c = b;console.log(b === c); // trueconsole.log(b == c); // ture 객체도 마찬가지다.1234567var x = &#123;&#125;;var y = &#123;&#125;;var z = y;console.log(x == y) // falseconsole.log(x === y) // falseconsole.log(y === z) // trueconsole.log(y == z) // true","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://cheonmro.github.io/categories/Javascript/"}],"tags":[{"name":"Equal Operator","slug":"Equal-Operator","permalink":"https://cheonmro.github.io/tags/Equal-Operator/"}]},{"title":"올바른 코딩을 위한 문제해결 프로세스","slug":"problem-solving-process","date":"2018-09-12T02:42:49.000Z","updated":"2018-09-12T02:42:49.651Z","comments":true,"path":"2018/09/12/problem-solving-process/","link":"","permalink":"https://cheonmro.github.io/2018/09/12/problem-solving-process/","excerpt":"","text":"Process of Problem Solving Computational Thinking Flow Chart Pseudo Code Algorithm(Write Code) 1. Computational Thinking What? 정답이 정해지지 않은 문제에 대한 해답을 다양한 시나리오별로 경우의 수를 따져서, 하나하나씩 논리적으로 답을 찾아가는 과정 How? 문제인지: 문제가 무엇인가? 문제분해 -&gt; 문제 조직화: 문제를 다양한 시나리오별로 구조화하는 것: 문제를 해결하기 위해서 어떻게 해야겠다. 시나리오 1(첫번째 경우의 수) 시나리오 1-1 시나리오 1-2 시나리오 2(두번째 경우의 수) 시나리오 2-1 시나리오 2-2 패턴인지: 이 문제를 해결하기 위해서는 어떻게(시나리오) 해결하면 되겠구나. 일반화/추상화: 어떤 문제를 해결하기 위해서는 {변수}를 어떻게(어디/무엇 등) 해결한다. Example123456789101112131415문제: array의 모든 element의 합을 구해라.1. 문제인지: array의 모든 element의 합을 구해야한다.2. 문제분해: array의 각 element에 접근해서 총합을 구한다. 1. 총합 sum = 0을 선언한다. 2. array의 element가 없다면? 1. sum을 리턴한다. 3. array의 element가 존재한다면? 1. 반복문을 이용해서 sum에 첫 element(i = 0)부터 마지막 element(array.length-1)까지 모두 더한다. 2. sum을 리턴한다.3. 패턴인지: array의 모든 element의 합을 구하려면, 반복문을 이용하면 구할 수 있다.4. 일반화/추상화: array의 모든 element의 합은 반복문을 통해 &#123;&#123;i번째 element&#125;&#125;에 접근하여 그 값을 &#123;&#123;sum&#125;&#125;에 쌓음으로써 구현한다. 2. Flow Chart What? Computational Thinking을 통해 작성한 시나리오를 하나의 흐름으로 이해하기 위해 작성하는 순서도 How? 문제가 생기는 점(Start)에서 문제가 해결되는 점(End)까지 각 경우의 수에 따라 Yes/No를 기본으로 순서도를 작성. Example 3. Pseudo Code What? 프로그램이 수행할 내용을 인간이 이해할 수 있는 언어로 작성하는 것. 의사코드를 작성하면 좋은점? 프로그램을 설계할 때, 밑그림(스케치)의 역할을 하여, 실제 코딩하기 전 사고를 좀 더 명확하게 정립을 할 수 있다. 의사코드로 소스코드 실행없이 상세 설계를 검토할 수 있어, Code Review가 더 쉬워진다. 코드 수정을 좀 더 용이하게 만든다. 일부 의사코드 몇 줄을 수정하는 것은 한 페이지 전체의 코드를 수정하는 것 보다 쉽다. 코드입력, 테스트, 디버그 등의 수정 단계에서 작업하는 것 보다 의사코드 설계 단계에서 미리 오류를 수정하는 것이 훨씬 경제적이다. 의사코드는 소스코드의 코멘트(주석)가 되기 때문에, 나중에 따로 코멘트를 작성하지 않아도 된다. 의사코드를 효과적으로 작성하는 방법 프로그래밍 문법에 맞게 작성한다. 조건문(if-else), 반복문(while, for) 등을 사용한다. 변수(n)를 사용한다. 간결하게 쓰되, 구체적으로 작성한다. 의사코드에서 많이 사용되는 영어 단어를 사용한다. 의사코드에서 많이 쓰이는 영어 단어 입력: GET, READ, OBTAIN 출력: PRINT, DISPLAY, SHOW 초기화: SET, INIT 계산: COMPUTE, CALCULATE, DETERMINE 반복: WHILE, FOR 조건문: IF-THEN-ELSE, CASE 마지막에 조건문이 있는 반복문: REPEAT-UNTIL 요소를 추가: INCREMENT, BUMP 부울: TRUE/FALSE 선형적으로 증가할 때: SEQUENCE 그외: REPEAT - UNTIL RETURN BEGIN / EXCEPTION / END Example 1234567891. Get an array of integers from user ==&gt; arr, i =02. Set sum of all elements of an array ==&gt; sum = 03. If size of array == 0, then return 04. WHILE i is less than size of array, 1. Add element(arr[i]) to sum 2. if i == size of array, then return sum 4. Algorithm What? 목표를 달성하거나 결과물을 생산하기 위해 필요한 과정들 How? 미리 작성한 의사코드를 바탕으로 Write Code! Example123456789101112131415function simpleArraySum(ar) &#123; var sum = 0; if(ar.length === 0) &#123; return 0; &#125; for(var i =0; i &lt; ar.length; i++) &#123; sum += ar[i]; &#125; return sum;&#125;","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"https://cheonmro.github.io/categories/Computer-Science/"}],"tags":[{"name":"Problem Solving","slug":"Problem-Solving","permalink":"https://cheonmro.github.io/tags/Problem-Solving/"}]},{"title":"2. Queue Using Two Stacks","slug":"queue-stack","date":"2018-09-12T01:39:44.000Z","updated":"2018-09-12T01:42:26.168Z","comments":true,"path":"2018/09/12/queue-stack/","link":"","permalink":"https://cheonmro.github.io/2018/09/12/queue-stack/","excerpt":"","text":"[Problem]Create a queue using two stacks. [Algorithms] Create a stack. Create a queue with two instances of Stack( ). For dequeue of Queue, Move elements from stack1(inbox) to stack2(outbox), and return the highest element in outbox. [Solution]12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// STACKfunction Stack() &#123; var items = []; this.push = function() &#123; items.push.apply(items, arguments); &#125;; this.pop = function() &#123; return items.pop.apply(items, arguments); &#125;; this.size = function() &#123; return items.length; &#125;; this.peek = function() &#123; return items; &#125;; this.isEmpty = function() &#123; return items.length === 0;&#125;;&#125;// STACK TESTSvar stack = new Stack();stack.push(1, 2, 3, 4, 5);console.log(stack.peek()); // [ 1, 2, 3, 4, 5 ]stack.pop();console.log(stack.peek()); // [ 1, 2, 3, 4 ]// QUEUEfunction Queue() &#123; var inbox = new Stack(); var outbox = new Stack(); this.eneque = function() &#123; inbox.push.apply(inbox, arguments); &#125;; this.dequeue = function() &#123; if (outbox.size() === 0) &#123; while (inbox.size()) outbox.push(inbox.pop()); &#125; return outbox.pop(); &#125;; this.size = function()&#123; return inbox.size() + outbox.size(); &#125;; this.peek = function() &#123; return outbox.peek(); &#125;; this.isEmpty = function() &#123; return inbox.length + outbox.length === 0; &#125;; this.front = function() &#123; if (outbox.size() === 0) &#123; while (inbox.size()) outbox.push(inbox.pop()); &#125; return outbox.peek()[0]; &#125;;&#125;// QUEUE TESTSvar queue = new Queue();console.log(queue.size()); // 0queue.eneque(10, 20, 30, 40, 50, 60);console.log(queue.size()); // 6console.log(queue.peek()); // [] Not move to outbox yetconsole.log(queue.dequeue()); // 10console.log(queue.dequeue()); // 20console.log(queue.peek()); // [ 60, 50, 40, 30 ]console.log(queue.front()); // 60console.log(queue.size()); // 4console.log(queue.dequeue()); // 30console.log(queue.dequeue()); // 40console.log(queue.peek()); // [ 60, 50 ] [What I learned]Use the value of array.pop() as parameter of other array.push()1234567this.dequeue = function() &#123; if (outbox.size() === 0) &#123; while (inbox.size()) outbox.push(inbox.pop()); &#125; return outbox.pop();&#125;;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://cheonmro.github.io/categories/Algorithms/"}],"tags":[{"name":"Queue","slug":"Queue","permalink":"https://cheonmro.github.io/tags/Queue/"},{"name":"Stack","slug":"Stack","permalink":"https://cheonmro.github.io/tags/Stack/"}]},{"title":"1. Fizzbuzz","slug":"fizzbuzz","date":"2018-09-11T10:29:27.000Z","updated":"2018-09-11T10:29:27.637Z","comments":true,"path":"2018/09/11/fizzbuzz/","link":"","permalink":"https://cheonmro.github.io/2018/09/11/fizzbuzz/","excerpt":"","text":"[Problem]Write a function that takes an integer and returns an array [A, B, C], where A is the number of multiples of 3 (but not 5) below the given integer, B is the number of multiples of 5 (but not 3) below the given integer and C is the number of multiples of 3 and 5 below the given integer. For example, solution(20) should return [5, 2, 1]123function solution(number)&#123;&#125; [Algorithms] Declare variables for the number of multiples below the given integer(3, 5, 15) Add counts for the number of multiples below the given integer using ‘for’ statement get an array of the variables [Solution]12345678910111213141516function solution(number)&#123; var num3 = 0; var num5 = 0; var num15 = 0; for(var i = 1; i &lt; number; i++) &#123; if((i % 3 === 0) &amp;&amp; (i % 5 !== 0)) &#123; num3 += 1; &#125; else if((i % 5 === 0) &amp;&amp; (i % 3 !== 0)) &#123; num5 += 1; &#125; else if(i % 15 === 0) &#123; num15 += 1; &#125; &#125; var result = [num3, num5, num15]; return result;&#125; [Best Practice]1234567function solution(n) &#123; --n; const c15 = Math.floor(n / 15); const c3 = Math.floor(n / 3) - c15; const c5 = Math.floor(n / 5) - c15; return [c3, c5, c15];&#125; [What I learned] Math.floor [Source]CodeWars - Fizz/Buzz","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://cheonmro.github.io/categories/Algorithms/"}],"tags":[{"name":"Fizzbuzz","slug":"Fizzbuzz","permalink":"https://cheonmro.github.io/tags/Fizzbuzz/"}]},{"title":"Event Object(이벤트 객체)","slug":"event-object","date":"2018-09-03T23:57:18.000Z","updated":"2018-09-03T23:57:18.837Z","comments":true,"path":"2018/09/04/event-object/","link":"","permalink":"https://cheonmro.github.io/2018/09/04/event-object/","excerpt":"","text":"Event Object(이벤트 객체)란 무엇인가? 이벤트 객체란, 이벤트를 발생시킨 요소와 발생한 이벤트에 대한 정보를 제공하는 것을 말한다. 이벤트가 발생하면, 이벤트 객체는 동적으로 생성되어, 이벤트 핸들러에 인자로 암묵적으로 전달된다. 1234567891011121314// HTML&lt;div class=&quot;parent&quot;&gt; &lt;button id=&quot;btn1&quot;&gt;button 1&lt;/button&gt; &lt;button id=&quot;btn2&quot;&gt;button 2&lt;/button&gt;&lt;/div&gt;// Javascript function getColor(e) &#123; e.target.style.color = &apos;red&apos;;&#125;var parent = document.querySelector(&apos;.parent&apos;);parent.addEventListener(&apos;click&apos;, getColor); 위 코드에서 ‘e’가 이벤트 객체인데, 위 코드처럼 이벤트 핸들러를 선언할 때, 이벤트 객체를 전달받을 첫번째 매개변수를 명시적으로 선언해야 한다. 그 이름은 위와 같이 ‘e’가 되든, ‘event’가 되든 상관이 없다. 이벤트도 객체이기 때문에, 프로퍼티와 메소드를 가진다. Event Property Event.target &amp;&amp; Event.currentTarget Event.target: 실제로 이벤트를 발생시킨 요소 Event.currentTarget: 이벤트에 바인딩된 DOM 요소(addEventListener 메소드 앞에 기술된 객체) 버튼 2개를 자식요소로 가지고 있는 parent 요소가 있다고 해보자.1234567891011121314151617// HTML&lt;div class=&quot;parent&quot;&gt; &lt;button id=&quot;btn1&quot;&gt;button 1&lt;/button&gt; &lt;button id=&quot;btn2&quot;&gt;button 2&lt;/button&gt;&lt;/div&gt;// Javascriptfunction getEventTarget(e) &#123; console.log(e.target); // &lt;button id=&quot;btn1&quot;&gt;button 1&lt;/button&gt; console.log(e.currentTarget); // &lt;div class=&quot;parent&quot;&gt;...&lt;div&gt; console.log(this); // &lt;div class=&quot;parent&quot;&gt;...&lt;div&gt; console.log(e.currentTarget === this); // true&#125;var parent = document.querySelector(&apos;.parent&apos;);parent.addEventListener(&apos;click&apos;, getEventTarget); 만약 첫번째 버튼(button 1)을 클릭하게 되면 결과는 위와 같이 나온다. e.target은 실제로 이벤트를 발생시킨 요소로, 첫번째 버튼(button 1)이 된다. 그러나, e.currentTarget은 이벤트에 바인딩된 DOM 요소(addEventListener 메소드 앞에 기술된 객체)로, 이벤트가 발생된 곳은 첫번째 버튼이지만, 이벤트에 바인딩된 DOM 요소는 parent(부모요소)이기 때문에, e.currentTarget은 parent 요소가 된다. 또한, addEventListener 함수에서 지정한 이벤트 핸들러 내부의 this는 Event Listener에 바인딩된 요소(parent)를 가리킨다. 이것은 이벤트 객체의 currentTarget 프로퍼티와 같다. Event.type &amp;&amp; Event.keyCode Event.type: 발생한 이벤트의 종류 Event.keyCode: 발생한 이벤트의 키보드 번호 123456789101112131415// HTML&lt;div class=&quot;parent&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;val&quot;&gt; &lt;button id=&quot;btn&quot;&gt;button&lt;/button&gt;&lt;/div&gt;// Javascriptfunction getEventType(e) &#123; console.log(e.type); // keyup console.log(e.keyCode); // 13&#125;var inputBox = document.querySelector(&apos;.val&apos;);inputBox.addEventListener(&apos;keyup&apos;, getEventType); 어떤 알파벳 하나를 입력하고, 키보드에서 ‘enter’를 입력하게 되면 e.type은 ‘keyup’이 되고, e.keyCode는 13이 된다. 즉, 발생한 이벤트의 타입은 ‘keyup’이고, 발생한 이벤트의 키보드 번호(enter의 키보드 번호)는 13이다. Event.preventDefault() &amp;&amp; Event.stopPropagation() Event.preventDefault(): 이벤트의 기본 동작을 중단 Event.stopPropagation(): 이벤트의 전파(버블링/캡처링)를 중단 Event.preventDefault() 12345678910111213// HTML &lt;a href=&quot;https://cheonmro.github.io/&quot;&gt;블로그로 이동&lt;/a&gt;// Javascriptvar elem = document.querySelector(&apos;a&apos;); elem.addEventListener(&apos;click&apos;, function (e) &#123; console.log(e.cancelable); // true // 이벤트의 기본 동작을 중단 e.preventDefault();&#125;); 원래는 ‘a’태그를 클릭하면 블로그로 이동을 해야하지만, 위와 같이 e.preventDefault()를 사용하게 되면, 이벤트의 기본 동작을 중단할 수 있다. 단, Event.cancelable가 true일 경우만 가능하다. Event.cancelable는 이벤트 객체의 프로퍼티로, 요소의 기본 동작을 중단할 수 있는지에 대한 여부(true/false)를 나타낸다. Event.stopPropagation() 어느 한 요소를 이용하여 이벤트를 처리한 후, 이벤트가 부모 요소로 이벤트가 전파되는 것을 중단하기 위해 사용되는 메소드이다. 1234567891011121314151617181920212223// HTML&lt;div id=&quot;divBox&quot;&gt; &lt;p id=&quot;paraBox&quot;&gt;블로그 &lt;a id=&quot;linkBox&quot; href=&quot;https://cheonmro.github.io/&quot;&gt;클릭&lt;/a&gt; &lt;/p&gt;&lt;/div&gt;// Javascriptdocument.getElementById(&quot;divBox&quot;).addEventListener(&quot;click&quot;, clickDiv);document.getElementById(&quot;paraBox&quot;).addEventListener(&quot;click&quot;, clickPara);document.getElementById(&quot;linkBox&quot;).addEventListener(&quot;click&quot;, clickLink);function clickDiv(event) &#123; console.log(&apos;Event for div&apos;);&#125;function clickPara(event) &#123; console.log(&apos;Event for p&apos;);&#125;function clickLink(event) &#123; event.stopPropagation(); // 이벤트의 전파를 중단함. console.log(&apos;Stop Propagation!&apos;)&#125; 위 코드에서 paraBox 요소를 클릭하게 되면, 부모요소로 이벤트가 전파된다. 그러나, linkBox 요소를 클릭하게 되면, 이벤트는 부모요소로 전파되지 않는다.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://cheonmro.github.io/categories/Javascript/"}],"tags":[{"name":"Event Object","slug":"Event-Object","permalink":"https://cheonmro.github.io/tags/Event-Object/"}]},{"title":"Event Flow(이벤트의 흐름)","slug":"event-flow","date":"2018-09-03T05:38:03.000Z","updated":"2018-09-03T05:38:03.785Z","comments":true,"path":"2018/09/03/event-flow/","link":"","permalink":"https://cheonmro.github.io/2018/09/03/event-flow/","excerpt":"","text":"Event Flow(이벤트의 흐름)이란 무엇인가? Event Flow란, 어떤 요소에서 이벤트가 발생했을 때, 그 이벤트를 전파하여 감지하는 흐름을 말한다. 이벤트의 흐름은 아래와 같이, 버블링과 캡처링 방식으로 이벤트를 감지한다. 출처: Event Flow Event Delegation(이벤트 위임) Event Delegation이란, 다수의 자식 요소에 각각 이벤트 핸들러를 바인딩하는 대신에, 하나의 부모 요소에 이벤트 핸들러를 바인딩하는 방법이다. 이벤트 위임을 하게 되면, 개별 자식 요소에 이벤트 핸들러를 바인딩할 필요가 없을 뿐 아니라, DOM 트리에 새로운 자식 요소가 추가되더라도, 이벤트 처리는 이벤트가 위임된 부모 요소에서 하기 때문에 코드도 간단해지고, 실행속도도 좋아지게 된다. 아래의 코드를 보자. 12345678910111213141516// HTML&lt;ul id=&quot;parent&quot;&gt; &lt;li id=&quot;content1&quot;&gt;HTML&lt;/li&gt; &lt;li id=&quot;content2&quot;&gt;CSS&lt;/li&gt; &lt;li id=&quot;content3&quot;&gt;JAVASCRIPT&lt;/li&gt;&lt;/ul&gt;// JavascriptgetColor() &#123; console.log(&apos;get color&apos;);&#125;var con1 = document.querySelector(&apos;#content1&apos;).addEventListener(&apos;click&apos;, getColor);var con2 = document.querySelector(&apos;#content2&apos;).addEventListener(&apos;click&apos;, getColor);var con3 = document.querySelector(&apos;#content3&apos;).addEventListener(&apos;click&apos;, getColor); 만약 이벤트 위임을 안한다면, 위 코드처럼 모든 자식 요소에 이벤트 핸들러를 바인딩해줘야 한다. 위 코드처럼 3개는 크게 문제가 안될 수도 있지만, 만약 10개, 100개면 어떨까? 그렇게 되면 자식요소가 너무 많아지기 때문에, 각 자식요소에 이벤트 핸들러를 바인딩하는 것도 힘들고, 코드 가독성도 안좋게 되고, 결국 실행속도도 저하가 된다. 위 코드를 이벤트 위임을 하면 아래와 같다.12345678910111213// HTML&lt;ul id=&quot;parent&quot;&gt; &lt;li id=&quot;content1&quot;&gt;HTML&lt;/li&gt; &lt;li id=&quot;content2&quot;&gt;CSS&lt;/li&gt; &lt;li id=&quot;content3&quot;&gt;JAVASCRIPT&lt;/li&gt;&lt;/ul&gt;// JavascriptgetColor() &#123; console.log(&apos;get color&apos;);&#125;var allContents = document.querySelector(&apos;#parent&apos;).addEventListener(&apos;click&apos;, getColor); 위와 같이 부모요소 1개에만 이벤트 핸들러를 바인딩하게 되면, 어떤 자식(하위)요소에서 이벤트가 발생하게 되면 그 이벤트를 부모요소가 감지하여 addEventListener의 콜백함수가 실행되게 된다. 이렇게 하위요소에서 이벤트가 발생하여 상위요소로 전달되어 상위요소가 그 이벤트를 감지하는 것을 버블링이라고 한다. 그 반대 방향으로 감지하는 것을 캡처링이라고 한다. 이부분을 잘 이해해야 이벤트 위임을 잘 할 수 있다. Event Bubbling(이벤트 버블링) &amp; Event Capturing(이벤트 캡처링) 브라우저가 이벤트를 감지하는 방식은 2가지가 있다. Event Bubbling(이벤트 버블링) Event Capturing(이벤트 캡처링) Event Bubbling(이벤트 버블링) 이벤트 버블링이란, 자식(하위)요소에서 발생한 이벤트가 부모(상위)요소로 전파(이벤트 전파: Event Propagation)되는 것을 말한다. 아래의 코드를 보자.12345678910111213141516171819202122232425// HTML&lt;div id=&quot;ancestor&quot;&gt; &lt;ul id=&quot;parent&quot;&gt; parent &lt;li id=&quot;child&quot;&gt;child&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;// Javascriptvar divAncestor = document.querySelector(&apos;#ancestor&apos;);var ulParent = document.querySelector(&apos;#parent&apos;);var liChild = document.querySelector(&apos;#child&apos;);divAncestor.addEventListener(&apos;click&apos;, function() &#123; console.log(&apos;Event for div&apos;);&#125;)ulParent.addEventListener(&apos;click&apos;, function() &#123; console.log(&apos;Event for ul&apos;);&#125;)liChild.addEventListener(&apos;click&apos;, function() &#123; console.log(&apos;Event for li&apos;);&#125;) 위 코드에서 ‘child’(li 요소)를 클릭하면, 아래와 같은 결과가 나온다.123Event for liEvent for ulEvent for div 자식요소인 li를 클릭하면, li에서 이벤트가 발생하고, 그 부모요소인 ul에서 이벤트가 발생하고, ul의 부모요소인 div에서 이벤트가 발생한다. 즉, 이벤트가 발생한 곳부터 위로 하나씩 이벤트가 발생하게 된다. 이때, 어떤 요소에 이벤트가 없을 경우(addEventListener가 없을 경우), 그 요소에서는 이벤트가 발생하지 않는다. 예를 들어, 아래의 코드를 보자.1234567891011121314151617181920// HTML&lt;div id=&quot;ancestor&quot;&gt; &lt;ul id=&quot;parent&quot;&gt; parent &lt;li id=&quot;child&quot;&gt;child&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;// Javascriptvar divAncestor = document.querySelector(&apos;#ancestor&apos;);var liChild = document.querySelector(&apos;#child&apos;);divAncestor.addEventListener(&apos;click&apos;, function() &#123; console.log(&apos;Event for div&apos;);&#125;)liChild.addEventListener(&apos;click&apos;, function() &#123; console.log(&apos;Event for li&apos;);&#125;) 위 코드에서 ‘child’(li 요소)를 클릭하면, 아래와 같은 결과가 나온다.12Event for liEvent for div 즉, ul요소는 이벤트가 없기 때문에(addEventListener가 없다.), 이벤트가 발생하지 않고, 그 부모요소인 div요소로 넘어가 div요소의 이벤트가 발생하게 된다. 또한, li요소가 아닌, ul을 클릭하게 되면, ul요소에서 이벤트가 발생하고, 그 부모요소인 div요소에서 이벤트가 전달된다. 즉, 이벤트가 발생한 요소부터 시작하여 상위요소로 이벤트가 발생하는 방식을 이벤트 버블링이라고 한다. 그럼 여기서 이벤트 위임을 하는 코드를 확인해보자.1234567891011121314// HTML&lt;div class=&quot;parent&quot;&gt; &lt;button id=&quot;btn1&quot;&gt;button 1&lt;/button&gt; &lt;button id=&quot;btn2&quot;&gt;button 2&lt;/button&gt;&lt;/div&gt;// Javascript function getColor(e) &#123; e.target.style.color = &apos;red&apos;;&#125;var parent = document.querySelector(&apos;.parent&apos;);parent.addEventListener(&apos;click&apos;, getColor); 위 코드에서는, 모든 자식요소에 이벤트 핸들러를 바인딩하는 대신에, 부모요소 1개에만 이벤트핸들러를 바인딩했는데, 이것을 이벤트 위임이라고 한다. 따라서, 자식요소가 button1, button2 둘 중 어느 곳을 클릭을 하더라도, 이벤트가 부모요소로 전달되어, 부모요소인 parent 요소에서 이벤트를 감지하고 이벤트를 발생시킨다. Event Capturing(이벤트 캡처링) 이벤트 캡처링이란, 자식 요소에서 발생한 이벤트가 부모 요소부터 시작하여 이벤트를 발생시킨 자식 요소까지 도달하는 것을 말한다. 아래의 코드를 보자.12345678910111213141516171819202122232425// HTML&lt;div id=&quot;ancestor&quot;&gt; &lt;ul id=&quot;parent&quot;&gt; parent &lt;li id=&quot;child&quot;&gt;child&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;// Javascriptvar divAncestor = document.querySelector(&apos;#ancestor&apos;);var ulParent = document.querySelector(&apos;#parent&apos;);var liChild = document.querySelector(&apos;#child&apos;);divAncestor.addEventListener(&apos;click&apos;, function() &#123; console.log(&apos;Event for div&apos;);&#125;, true)ulParent.addEventListener(&apos;click&apos;, function() &#123; console.log(&apos;Event for ul&apos;);&#125;, true)liChild.addEventListener(&apos;click&apos;, function() &#123; console.log(&apos;Event for li&apos;);&#125;, true) 참고로, 캡처링을 적용하려면, addEventListener 메소드의 세번째 매개변수에 true를 설정해야 한다. 설정하지 않으면 default로 버블링이다. 위 코드에서 ‘child’(li 요소)를 클릭하면, 아래와 같은 결과가 나온다.123Event for divEvent for ulEvent for li 자식요소인 li를 클릭하면, 최상위 부모요소인 div에서 먼저 이벤트가 발생하고, 아래 방향으로 하나씩 이벤트가 발생한다. 즉, 버블링과 반대로, 이벤트가 발생한 곳은 자식요소이나, 이벤트를 감지하는 곳은 최상위 부모요소부터 시작하여 실제로 이벤트가 발생한 요소까지 도달하는데, 이런식으로 이벤트를 감지하는 것을 이벤트 캡처링이라고 한다. 예를 들어, 아래의 코드를 보자.1234567891011121314151617181920// HTML&lt;div id=&quot;ancestor&quot;&gt; &lt;ul id=&quot;parent&quot;&gt; parent &lt;li id=&quot;child&quot;&gt;child&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;// Javascriptvar divAncestor = document.querySelector(&apos;#ancestor&apos;);var liChild = document.querySelector(&apos;#child&apos;);divAncestor.addEventListener(&apos;click&apos;, function() &#123; console.log(&apos;Event for div&apos;);&#125;)liChild.addEventListener(&apos;click&apos;, function() &#123; console.log(&apos;Event for li&apos;);&#125;) 위 코드에서 ‘child’(li 요소)를 클릭하면, 아래와 같은 결과가 나온다.12Event for divEvent for li 즉, ul요소는 이벤트가 없기 때문에(addEventListener가 없다.), 이벤트가 발생하지 않고, 그 부모요소인 div요소부터 이벤트가 발생하고, 그 다음 li요소에서 이벤트가 발생하게 된다. 또한, li요소가 아닌, ul을 클릭하게 되면, 최상위 요소인 div요소에서 이벤트가 발생하여, 이벤트가 발생한 ul요소까지 이벤트가 도달하게 된다. 즉, 이벤트가 어디서 발생하는 것과는 상관없이, 최상위 부모요소에서부터 이벤트가 발생하기 시작하여, 실제로 이벤트가 발생한 곳까지 가는 방식을 이벤트 캡처링이라고 한다.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://cheonmro.github.io/categories/Javascript/"}],"tags":[{"name":"Event Flow","slug":"Event-Flow","permalink":"https://cheonmro.github.io/tags/Event-Flow/"}]},{"title":"Event Binding(이벤트 바인딩)과 Event Handler(이벤트 핸들러)","slug":"event-binding-and-event-handler","date":"2018-09-02T23:58:00.000Z","updated":"2018-09-02T23:58:00.626Z","comments":true,"path":"2018/09/03/event-binding-and-event-handler/","link":"","permalink":"https://cheonmro.github.io/2018/09/03/event-binding-and-event-handler/","excerpt":"","text":"Event Binding 바인딩이란, 서로 묶어서 연결해 준다는 뜻이다. 이벤트 바인딩이란, 발생하는 이벤트와 그 후에 어떤 일이 벌어질지 알려주는 함수(콜백함수)와 묶어서 연결해 준다는 뜻이다. 예를 들어, 어떤 버튼을 사용자가 클릭하게 되면, 클릭(‘click’)이벤트가 발생하게 되고, 그 이벤트가 발생했을 때 어떤 일이 벌어진다는 것을 알려주는 콜백함수를 실행하게 된다. 이때, 이 콜백함수를 이벤트 핸들러라고 한다. 이벤트 바인딩에는 대표적으로 3가지 방식이 있다. HTML 이벤트 핸들러 전통적인 DOM 이벤트 핸들러 Event Listener를 이용한 이벤트 핸들러 1~2번의 단점을 보완한 방식이 Event Listener를 이용한 이벤트 핸들러 방식이다. 1. HTML 이벤트 핸들러HTML 요소의 이벤트 Attribute에 이벤트 핸들러를 대응시키는 방법이다.12345&lt;button onclick=&quot;clickBtn()&quot;&gt;Click me&lt;/button&gt;function clickBtn() &#123; alert(&apos;Button clicked!&apos;);&#125; 옛날 코드를 보게 되면 위와 같은 방식을 사용한 코드가 있다. 그래서 혹시 모를 상황에 대비해 알아둘 필요는 있지만, 현재 이 방식은 사용되지 않고, 사용해서도 안된다. 또한, 이렇게 되면 HTML과 Javascript가 혼용이 되는데, 이 둘은 관심사가 다르기 때문에 같이 사용하는 것을 피해야 한다. HTML 이벤트 핸들러 내부의 thisHTML 이벤트 핸들러 방식의 경우, 이벤트 핸들러 내부의 this는 window를 가리킨다. 1234567&lt;button onclick=&quot;clickBtn()&quot;&gt;Click me&lt;/button&gt;function clickBtn() &#123; alert(&apos;Button clicked!&apos;); console.log(this); // window console.log(event.currentTarget); // &lt;button onclick=&quot;clickBtn()&quot;&gt;Click me&lt;/button&gt;&#125; 2. 전통적인 DOM 이벤트 핸들러HTML Event Handler의 보완점: HTML과 Javascript가 혼용되는 문제는 해결 단점: 이벤트 핸들러에 하나의 함수만을 바인딩할 수 있다. 함수에 인수를 전달할 수 없다. 바인딩된 이벤트 핸들러가 2개 이상일 경우, 제일 마지막에 추가된 코드의 바인딩된 이벤트 핸들러만 실행된다. 12345678910111213&lt;button id=&quot;myBtn&quot;&gt;Click me&lt;/button&gt;var myBtn = document.getElementById(&apos;myBtn&apos;);// 첫번째 바인딩된 이벤트 핸들러 =&gt; 실행되지 않는다.myBtn.onclick = function () &#123; alert(&apos;Button clicked 1&apos;);&#125;;// 두번째 바인딩된 이벤트 핸들러myBtn.onclick = function () &#123; alert(&apos;Button clicked 2&apos;);&#125;; 전통적인 DOM 이벤트 핸들러 내부의 this전통적인 DOM 이벤트 핸들러 방식에서 이벤트 핸들러 내부의 this는 이벤트에 바인딩된 요소를 가리킨다. 이것은 이벤트 객체의 currentTarget 프로퍼티와 같다. 12345678&lt;button id=&quot;myButton&quot;&gt;Click me!!!&lt;/button&gt;var myBtn = document.getElementById(&apos;myButton&apos;);myBtn.onclick = function() &#123; console.log(this); // &lt;button id=&quot;myButton&quot;&gt;Click me!!!&lt;/button&gt; console.log(event.currentTarget); // &lt;button id=&quot;myButton&quot;&gt;Click me!!!&lt;/button&gt; console.log(this === event.currentTarget); // true&#125;; myButton이란 id를 가진 button 요소(myBtn)가 이벤트에 바인딩된 요소를 말한다. 이것은 이벤트 객체의 currentTarget 프로퍼티와 같다. 3. Event Listener를 이용한 이벤트 핸들러addEventListener 함수를 이용하여 대상 요소(Event Target)에 이벤트를 바인딩하고, 해당 이벤트가 발생했을 때 실행될 콜백 함수를 지정한다. 1234target.addEventListener(type, listener[, useCapture]);var el = document.getElementById(&quot;outside&quot;);el.addEventListener(&quot;click&quot;, function()&#123;modifyText(&quot;four&quot;)&#125;, false); addEventListener 함수의 인수: type: 이벤트 타입 listener: 이벤트 핸들러, 즉 이벤트가 발생했을 때, 실행될 콜백함수 useCapture: true면 Capturing, false면 Bubbling(Default: false) Event Listener를 이용한 이벤트 핸들러의 장점 하나의 이벤트에 대해 하나 이상의 핸들러를 추가할 수 있다. 캡처링(Capturing)과 버블링(Bubbling)을 지원한다. HTML 요소뿐만아니라 모든 DOM 요소에 대해 동작한다. 1234567&lt;label for=&apos;email&apos;&gt;Your Email&lt;/label&gt;&lt;input type=&apos;text&apos; id=&apos;email&apos;&gt;var elem = document.getElementById(&apos;email&apos;);elem.addEventListener(&apos;blur&apos;, function() &#123; alert(&apos;Your Email!&apos;);&#125;); 참고로, addEventListener 함수는 IE 9 이상에서 동작한다. IE 8 이하에서는 attachEvent 함수를 사용한다. 만약 addEventListener 함수 앞에 대상요소(elem)를 지정하지 않으면, blur 이벤트는 전역객체 window에 바인딩된다. Event Listener를 이용한 이벤트 핸들러 내부의 thisaddEventListener 함수에서 지정한 이벤트 핸들러 내부의 this는 Event Listener에 바인딩된 요소(currentTarget)를 가리킨다. 이것은 이벤트 객체의 currentTarget 프로퍼티와 같다. 12345678&lt;button id=&quot;myBtn&quot;&gt;Click me!!!&lt;/button&gt;var myBtn = document.getElementById(&apos;myBtn&apos;);myBtn.addEventListener(&apos;click&apos;, function (event) &#123; console.log(this); // &lt;button id=&quot;myBtn&quot;&gt;Click me!!!&lt;/button&gt; console.log(event.currentTarget); // &lt;button id=&quot;myBtn&quot;&gt;Click me!!!&lt;/button&gt; console.log(this === event.currentTarget); // true&#125;);","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://cheonmro.github.io/categories/Javascript/"}],"tags":[{"name":"Event Binding","slug":"Event-Binding","permalink":"https://cheonmro.github.io/tags/Event-Binding/"}]},{"title":"Event와 Event 종류","slug":"event-type","date":"2018-09-02T05:29:53.000Z","updated":"2018-09-02T05:29:53.438Z","comments":true,"path":"2018/09/02/event-type/","link":"","permalink":"https://cheonmro.github.io/2018/09/02/event-type/","excerpt":"","text":"Event(이벤트)란 무엇인가? 이벤트는 어떤 사건을 말한다. 브라우저에서 사건(Event)이란, 예를 들어, 사용자가 어떤 웹페이지에서 버튼을 클릭했을 ‘때’ 또는 어떤 박스에서 값을 입력했을 ‘때’를 의미한다. 이벤트는 이벤트가 발생했을 때, 그에 맞는 대응을 하도록 코드를 작성해야 한다. 이를 위해서는 보통, 이벤트는 함수에 연결되며 그 함수는 이벤트가 발생하기 전에는 실행되지 않다가 이벤트가 발생하면 실행되는데, 이 함수(콜백함수)를 이벤트 핸들러라고 한다.1234var elem = document.getElementById(&apos;alertButton&apos;);elem.addEventListener(&apos;click&apos;, function() &#123; alert(&apos;Hello World&apos;);&#125;); id가 alertButton인 DOM 요소의 버튼을 클릭했을 때(이벤트), ‘Hello World’를 보여주는 alert가 실행되는 콜백함수가 이벤트 핸들러이다. Event 종류 브라우저에 사용하는 이벤트는 다양하지만, 자주 사용되거나 대표적인 이벤트만 정리한다. 1. UI Event Event Description load 웹페이지의 로드가 완료되었을 때 unload 웹페이지가 언로드될 때(주로 새로운 페이지를 요청한 경우) error 브라우저가 자바스크립트 오류를 만났거나 요청한 자원이 존재하지 않는 경우 resize 브라우저 창의 크기를 조절했을 때 scroll 사용자가 페이지를 위아래로 스크롤할 때 select 텍스트를 선택했을 때 load 이벤트를 사용하는 예제123window.addEventListener(&quot;load&quot;, function(event) &#123; console.log(&quot;All resources finished loading!&quot;);&#125;); 2. Keyboard Event Event Description keydown 키를 누르고 있을 때 keyup 누르고 있던 키를 뗄 때 keypress 키를 누르고 뗏을 때 keyup 이벤트를 사용하는 예제12345inputTodo.addEventListener(&apos;keyup&apos;, function (e) &#123; if (e.keyCode !== 13 || !inputTodo.value) return; addTodo(inputTodo.value); inputTodo.value = &apos;&apos;;&#125;); 3. Mouse Event Event Description click 마우스 버튼을 클릭했을 때 dbclick 마우스 버튼을 더블 클릭했을 때 mousedown 마우스 버튼을 누르고 있을 때 mouseup 누르고 있던 마우스 버튼을 뗄 때 mousemove 마우스를 움직일 때 (터치스크린에서 동작하지 않는다) mouseover 마우스를 요소 위로 움직였을 때 (터치스크린에서 동작하지 않는다) mouseout 마우스를 요소 밖으로 움직였을 때 (터치스크린에서 동작하지 않는다) click 이벤트를 사용하는 예제1234todoList.addEventListener(&apos;click&apos;, function (e) &#123; if (!e.target || e.target.nodeName !== &apos;SPAN&apos; || e.target.parentNode.nodeName === &apos;LABEL&apos;) return; removeTodo(e.target.dataset.id);&#125;); 4. Focus Event Event Description focus 요소가 포커스를 얻었을 때 blur 요소가 포커스를 잃었을 때 focus와 blur 이벤트를 사용하는 예제12345678var form = document.getElementById(&quot;form&quot;);form.addEventListener(&quot;focus&quot;, function( event ) &#123; event.target.style.background = &quot;pink&quot;;&#125;, true);form.addEventListener(&quot;blur&quot;, function( event ) &#123; event.target.style.background = &quot;&quot;;&#125;, true); 5. Form Event Event Description input input 또는 textarea 요소의 값이 변경되었을 때 change select box, checkbox, radio button의 상태가 변경되었을 때 submit form을 submit할 때 (버튼 또는 키) reset reset 버튼을 클릭할 때 (최근에는 사용 안함) change 이벤트를 사용하는 예제12345678910todoList.addEventListener(&apos;change&apos;, function (e) &#123; toggleTodoComplete(e.target.id);&#125;);var toggleTodoComplete = function (id) &#123; todos = todos.map(function (todo) &#123; return todo.id === +id ? Object.assign(&#123;&#125;, todo, &#123; completed: !todo.completed &#125;) : todo; &#125; ); renderTodos();&#125;; 6. Clipboard Event Event Description cut 콘텐츠를 잘라내기할 때 copy 콘텐츠를 복사할 때 paste 콘텐츠를 붙여넣기할 때 copy 이벤트를 사용하는 예제12345document.addEventListener(&apos;copy&apos;, function(e)&#123; e.clipboardData.setData(&apos;text/plain&apos;, &apos;Hello, world!&apos;); e.clipboardData.setData(&apos;text/html&apos;, &apos;&lt;b&gt;Hello, world!&lt;/b&gt;&apos;); e.preventDefault(); // We want our data, not data from any selection, to be written to the clipboard&#125;); 7. Websocket Event Event Description open 웹소켓 연결이 되었을 때 message 웹소켓을 통해 메세지가 전달되었을 때 error 몇개의 메세지가 전달이 안된 상태로 웹소켓 연결이 끝났을 때 close 웹소켓 연결이 끝났을 때 8. CSS Animation Event Event Description animationstart CSS 애니메이션이 시작되었을 때 animationend CSS 애니메이션이 끝났을 때 animationiteration CSS 애니메이션이 반복될 때 이외에 다른 이벤트는 MDN에서 확인할 수 있다.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://cheonmro.github.io/categories/Javascript/"}],"tags":[{"name":"Event","slug":"Event","permalink":"https://cheonmro.github.io/tags/Event/"}]},{"title":"Event Loop(이벤트루프)와 Javascript Concurrency(동시성)","slug":"event-loop-and-concurrency","date":"2018-09-02T03:09:06.000Z","updated":"2018-09-02T03:09:06.542Z","comments":true,"path":"2018/09/02/event-loop-and-concurrency/","link":"","permalink":"https://cheonmro.github.io/2018/09/02/event-loop-and-concurrency/","excerpt":"","text":"Browser Architecture 출처: Browser Architecture Browser안에는 위와 같이 자바스크립트엔진 뿐만 아니라 다른 것들이 같이 포함되어 있다. 자바스크립트엔진(크롬: V8) Heap과 Stack으로 구성되어있고, 자바스크립트가 브라우저에서 실행되는 곳이 자바스크립트엔진, 정확히는 Stack이다. Web APIs 비동기 방식으로 호출되는 것들(Timer 함수/DOM Event/Ajax)이 정의되는 영역이다. Callback Queue Web APIs으로부터 옮겨와 자바스크립트엔진의 Stack으로 이동하기 위해 기다리는 곳이다. Event Loop Callback Queue에서 기다리고 있는 비동기 방식으로 호출되는 것들(Timer 함수/DOM Event/Ajax)을 Stack이 완전히 비어있을 때 이동시키는 역할을 한다. 자바스크립트 기본 특징 자바스크립트는 싱글쓰레드(single-threaded), 즉 1개의 쓰레드를 가지고있다. 1개의 쓰레드를 가지고 있다는 말은 한번에 하나일을 처리한다는 것이다. 자바스크립트엔진의 Stack에서 한번에 하나의 일(함수 호출)을 처리한다는 뜻이다. 그런데, 실제로 자바스크립트 기반의 애플리케이션은 여러가지일이 동시에 일어난다. 왜 그럴까? 이걸 전문적으로 말하면 자바스크립트는 동시성(Concurrency)을 지원한다는 것인데, 어떻게 그럴 수 있을까? 여기서 이벤트루프(Event Loop)에 대한 개념이 나온다. 먼저 동기적(한번에 하나의 일을 처리)으로 작동하는 기본적인 자바스크립트 코드가 돌아가는 원리를 알아보자. (기본) 자바스크립트 동작 원리 다시 한번 Architecture를 보자. 출처: Browser Architecture 비동기로 호출되는 것들(Timer 함수/DOM Event/Ajax)이 없는 자바스크립트 코드의 경우, 자바스크립트엔진의 Stack에서만 하나씩 호출되어 코드가 돌아간다. 즉, Web AIPs, Callback Queue, 그리고 Event Loop 등을 사용하지 않는다. 아래 동기적 코드를 보자.123456789function multiply(a, b) &#123; return a*b;&#125;function square(a) &#123; const sq = multiply(a, a); console.log(sq);&#125;square(3); 이 코드는 어떤 순서로 호출되어 값이 나오게 될까? 호출되는 순서는 다음과 같다. square(3) 때문에, square 함수가 먼저 호출된다. sq에 multiply 함수를 할당하기 위해, multiply 함수가 호출된다. multiply의 return 값이 나온다. console.log(sq)의 결과값이 나온다. 이 순서를 Stack에서 확인해보자. 출처: 동기적 자바스크립트 위 그림과 같이, Stack에서 push로 하나씩 함수가 쌓이고, pop으로 마지막에 쌓인 것부터 하나씩 호출되어 실행되고, 제거된다. 이런식으로, 한번에 하나씩 순서대로 일이 진행되어, 결과값이 나오게 된다. 이게 동기적 방식이다. Error: Maximum call stack size exceededStack안에 쌓이는 각 함수를 Stack Frame이라고 한다. 보통, 이런 각 Stack Frame은 ms(1초=1000ms)안에 동작이 끝난다. 그런데, Stack에는 Stack Frame의 수가 정해져 있고, 이 수를 넘게되면 에러가 발생하게 된다. 아래 코드를 보자. 1234function foo() &#123; return foo();&#125;foo(); 위 코드를 작성하고 실행하게 되면, 다음과 같은 에러가 발생한다.1RangeError: Maximum call stack size exceeded 이 에러의 원인은 Stack안에 정해진 Stack Frame의 수를 초과했다는 뜻이다. 즉, foo 함수가 호출될 때, return 값으로 foo 함수가 호출되기 때문에, 계속해서 호출되게 되고, 그 말은 Stack에 계속해서 foo 함수가 쌓인다는 뜻이다. 그래서 정해진 Stack Frame의 수를 초과하게 되어, 위와 같은 에러가 발생하게 된다. 이런 자바스크립트의 Stack에 대한 개념을 모르게되면, 이 에러가 발생했을 때 해결하기가 어려울 수 있다. 그럼, 자바스크립트에 동시성(Concurrency)을 어떻게 지원하는지 알아보자. 비동기적 자바스크립트 동작 원리 다시 한번 Architecture를 보자. 출처: Browser Architecture 비동기로 호출되는 것들(Timer 함수/DOM Event/Ajax)이 있는 자바스크립트 코드의 경우, 자바스크립트엔진의 Stack에서 Web AIPs로 이동하게 되고, 다시 Callback Queue로 이동하게 된다. 그리고 Stack에 있는 모든 함수가 제거되고 난뒤, Event Loop로 인해 Stack으로 이동되어, 함수가 호출되고 제거된다. 아래 비동기적 코드를 보자.12345console.log(&quot;Print this 1st&quot;);setTimeout(() =&gt; &#123; console.log(&quot;Print this 3rd&quot;);&#125;, 500);console.log(&quot;Print this 2nd&quot;); 이 코드는 어떤 순서로 호출되어 값이 나오게 될까?123&quot;Print this 1st&quot;&quot;Print this 2nd&quot;&quot;Print this 3rd&quot; 비동기 함수인 setTimeout 함수가 0.5초뒤에 실행되니, 그 전에 마지막 console.log가 먼저 출력되어, 순서가 저렇게 된것일까? 이 과정을 정확하게 위해서는 이벤트루프(Event Loop) 개념을 이해해야 한다. 이 순서를 Architecture에서 확인해보자.위 코드가 실제로 실행되는 과정은 아래와 같다. 출처: 비동기적 자바스크립트 먼저, 첫번째 console.log가 호출되고, 제거된다. 그리고, 비동기 함수인 setTimeout 함수가 호출된뒤, Web APIs로 이동한다. 이와 동시에, Stack에서 다음 console.log가 쌓인다. 이동한 setTimeout 함수는 Web APIs에서 0.5초(500ms) 동안 있다가, Callback Queue로 이동한다. Event Loop는 Stack에 있는 모든 함수가 제거된 것을 확인한 후, Callback Queue에 있는 setTimeout 함수를 Stack으로 보내고 실행한다. 그리고, 그 setTimeout 함수는 Stack에서 제거된다. 자바스크립트에서의 비동기적 방식은 위와 같이 진행되기 때문에, 비동기 함수보다 다른 일반 함수들이 먼저 실행되고, 그 다음에 비동기 함수가 진행된다. 결국, 자바스크립트엔진 밖에 있는 Web APIs, Callback Queue, 그리고 Event Loop가 비동기 함수를 따로 관리함으로써 자바스크립트에 동시성이 가능하게 된다. 따라서, 자바스크립트 기반의 애플리케이션은 여러가지 일들이 동시에 발생할 수 있는 것이다. 만약, setTimeout 함수의 두번째 인수가 ‘0’초면 어떻게 될까?아래 코드를 보자.12345console.log(&quot;Print this 1st&quot;);setTimeout(() =&gt; &#123; console.log(&quot;Print this 3rd&quot;);&#125;, 0);console.log(&quot;Print this 2nd&quot;); 이 코드는 어떤 순서로 호출되어 값이 나오게 될까?123&quot;Print this 1st&quot;&quot;Print this 2nd&quot;&quot;Print this 3rd&quot; 이 또한 setTimeout 함수의 두번째 인수가 0.5초일때와 동일하게 나온다. 즉, timer 함수의 시간과 상관없이, 이벤트루프는 Stack에 있는 다른 모든 함수가 제거된 뒤, timer 함수를 Stack으로 이동시키기 때문이다. 단지, Wep APIs에서 0.5초 걸리느냐, 0초 걸리느냐에 차이이다. 다른 비동기인 DOM 이벤트의 경우는 어떻게 될까?아래 코드를 보자.12345678910111213141516171819202122function func1() &#123; console.log(&apos;func1&apos;); func2();&#125;function func2() &#123; // &lt;button id=&quot;bar&quot;&gt;bar&lt;/button&gt; var elem = document.getElementById(&apos;bar&apos;); elem.addEventListener(&apos;click&apos;, function () &#123; this.style.backgroundColor = &apos;blue&apos;; console.log(&apos;func2&apos;); &#125;); func3();&#125;function func3() &#123; console.log(&apos;func3&apos;);&#125;func1(); 위 코드의 실행순서는 다음과 같다. 함수 func1()이 호출되면 함수 func1()은 Stack에 쌓인다. 함수 func1()은 함수 func2를 호출하므로 함수 func2()가 Stack에 쌓이고 addEventListener가 호출된다. 이 addEventListener는 Wep APIs로 이동한다. Stack에는 func3()가 쌓인다. 이때, 만약 bar 버튼이 클릭되면, ‘click’ 이벤트가 발생하게 되어, addEventListener는 Callback Queue로 이동하게 된다. Stack에 있던 모든 함수가 제거되어 완전히 비어지면, 이벤트 루프는 이 addEventListener를 Stack으로 이동시키고, 실행하게 된다.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://cheonmro.github.io/categories/Javascript/"}],"tags":[{"name":"Event Loop","slug":"Event-Loop","permalink":"https://cheonmro.github.io/tags/Event-Loop/"}]},{"title":"Ajax란 무엇인가?","slug":"ajax","date":"2018-08-31T00:48:40.000Z","updated":"2018-10-31T15:06:57.854Z","comments":true,"path":"2018/08/31/ajax/","link":"","permalink":"https://cheonmro.github.io/2018/08/31/ajax/","excerpt":"","text":"Ajax란? Ajax는 Asynchronous JavaScript And XML의 약자로, XMLHttpRequest 객체를 이용하여 비동기 방식으로 서버와 통신을 하는 것을 말한다. 웹 브라우저의 클라이언트와 서버간 통신은 url를 이용한 http 통신으로 이루어진다. 즉 브라우저가 서버로 request를 날리기 위해서는 해당 브라우저의 url 주소를 변경하여야 하는데 이때는 페이지 이동이 일어나게 된다. 하지만 ajax 의 경우 브라우저의 url 주소의 변경을 이용하지 않고 내부적으로 통신하여 response 를 받아오기 때문에 특정 데이터만 불러오거나 비동기로 데이터를 불러와야하는 경우 사용된다. 이때 Same Origin Policy 정책으로 인해 cross domain 을 허용하지 않기 때문에 외부 도메인을 사용하여야 하는경우 JSONP, XML 등을 이용하여야 한다. 비동기적이란, 서버에 요청을 하고 그냥 기다리는 것이 아닌, 기다림과 동시에 다른 작업을 할 수 있다는 것을 말한다. Ajax가 가지고 있는 중요 특징은 바로 이 비동기성으로, 서버로부터 웹페이지가 반환될 때, 화면 전체를 갱신하지 않고, 페이지 일부만을 갱신하게 해준다. 즉, 페이지 이동이나 새로고침 없이 페이지 일부만을 갱신할 수 있다. 예를 들어, 사용자가 페이지에서 어떤 이벤트를 발생시키면, 페이지 전체가 아닌 페이지 일부분만을 업데이트해서 보여주기 때문에, 페이지 전체가 Refresh 되지 않아, 사용자가 그 일부의 데이터를 기다리면서, 다른 일을 하여도 문제가 없다. Ajax를 사용하는 대표적인 애플리케이션이 페이스북 타임라인이다. 페이스북 타임라인을 밑으로 내려가면서 보면, 그 페이스북 페이지 자체는 그대로 있는데, 필요한 타임라인 데이터만 받아올 수 있다. 웹 사이트 중 페이지 전환없이 새로운 데이터를 불러오는 사이트는 대부분 Ajax 기술을 사용하고 있다. JSON이란? JSON은 JavaScript Object Notation의 약자로, 클라이언트와 서버간에 데이터를 교환하기 위해 필요한 데이터 포맷을 말한다. 예전에는 데이터 교환을 위한 데이터 포맷으로 XML을 사용했으나, 요즘에는 데이터 구조화도 잘 되어있고, 가볍고 가독성이 좋은 JSON을 사용한다. JSON의 형태는 자바스크립트의 객체 리터럴과 비슷하지만, 순수 문자열로 구성된 규칙이 있는 구조화된 데이터 포맷이다. 12345&#123; &quot;id&quot;: 1, &quot;content&quot;: &quot;HTML&quot;, &quot;completed&quot;: false&#125; JSON의 이름(key)는 반드시 큰따옴표(“”)로 둘러싸야 한다.(작은따옴표(‘’)는 사용이 안된다.) JSON.parse() &amp; JSON.stringify() 클라이언트와 서버간에 통신을 할때는, JSON 형태, 즉 문자열로 데이터를 주고 받는다. 그러나, 서버로부터 응답받은 데이터를 클라이언트(브라우저)에서 사용하기 위해서는 JSON 형태의 문자열을 객체로 바꿔줘야 한다. 이를 역직렬화(Deserializing)이라고 하는데, 이를 위해서는 내장 객체 JSON의 static 메소드인 JSON.parse()를 사용해야 한다. 이와 반대로, 클라이언트(브라우저)에서 서버로 데이터를 보내기 위해서는 객체를 문자열로 바꿔줘야 한다. 이때는 JSON.stringify()를 사용해야 한다. JSON.stringify()에 대해 자세히 확인해보자. Ajax Request &amp; Response Javascript를 이용해서 서버로 보내는 Ajax Request를 만들기 위해서는 XMLHttpRequest 객체를 사용해서 Ajax 요청을 생성하고 전송한다. 서버로부터 응답을 받을때도 XMLHttpRequest 객체를 사용해서 처리한다. 즉, XMLHttpRequest 객체의 프로퍼티 및 메소드를 사용하여 코드를 작성한다. 코드 작성시, 크게 3가지로 나눌 수 있다. 서버로 요청 보내기 서버로 요청보낼때, Request Header 보내기 서버로부터 받은 응답 처리하기 1. Ajax Request 보내기 XMLHttpRequest 객체를 사용해서 Ajax 요청 처리에 대한 코드는 다음과 같다. 123var xhr = new XMLHttpRequest();xhr.open(&apos;GET&apos;, &apos;/users&apos;);xhr.send(); 1-1. XMLHttpRequest 인스턴스 생성 12// XMLHttpRequest 생성자로 xhr 인스턴스를 생성var xhr = new XMLHttpRequest(); XMLHttpRequest 객체는 다양한 프로퍼티 및 메소드를 가지고 있다. 1-2. XMLHttpRequest.open()으로 요청 준비 12// XMLHttpRequest가 가지고 있는 open 메소드로 요청을 준비xhr.open(&apos;GET&apos;, &apos;/users&apos;); XMLHttpRequest.open 메소드를 사용할 때, 인수는 다음과 같다. 첫번째 인수: HTTP Method(GET/POST/PUT/PATCH/DELETE 등)를 사용 두번째 인수: 요청 보낼 URL 세번째 인수(옵션): async로 비동기를 나타낸다.(true면 비동기, false면 동기인데, 아무것도 작성안하면 default로 비동기이다.) 1-3. XMLHttpRequest.send()로 요청 전송 12// XMLHttpRequest가 가지고 있는 send 메소드로 요청을 전송xhr.send(); 서버에 요청을 준비하는 단계를 보자.1xhr.open(&apos;GET&apos;, &apos;/users&apos;); 이때 HTTP Method로 ‘GET’을 사용하게 되면, URL의 일부분인 query string(쿼리문자열)로 데이터를 서버로 전송하기 때문에, send 메소드에 인수로 데이터를 보낼 필요가 없다. send 메소드에 인수를 Request Body라고 하는데, 이부분이 null이 되어, 무시된다. 그럼 만약, ‘GET’이 아닌 ‘POST’를 하게되면 어떻게 될까? 2. 서버로 요청보낼때, Request Header 보내기 ‘POST’의 경우, 데이터(payload)를 Request Body에 담아 전송한다.1234xhr.send((&#123; name: &quot;donald&quot;, country: &quot;United States&quot;&#125;)); 이럴 경우, XMLHttpRequest.setRequestHeader() 메소드를 사용해서, HTTP Request Header의 값을 설정해야 한다. 이때, setRequestHeader 메소드는 open 메소드 다음에, send 메소드 전에 호출해야 한다. 다음과 같이 작성하면 된다.123456xhr.open(&apos;POST&apos;, &apos;/users&apos;);xhr.setRequestHeader(&apos;Content-type&apos;, &apos;application/json&apos;);xhr.send(&#123; name: &quot;donald&quot;, country: &quot;United States&quot;&#125;); setRequestHeader 메소드를 사용할 때, 인수는 다음과 같다. 첫번째 인수: 자주 사용하는 Request Header인 Content-type 또는 Accept을 사용한다. 두번째 인수: MIME 타입 예를 들어, 아래와 같은 코드를 보자.1xhr.setRequestHeader(&apos;Content-type&apos;, &apos;application/json&apos;); ‘Content-type’은 Request Body에 담아 전송할 데이터의 MIME-type을 지정할 때 사용한다.MIME-type은 아래 테이블에 있는 타입들이며, 사용시에는 아래 서브타입처럼 작성한다. 타입 서브타입 text 타입 text/plain, text/html, text/css, text/javascript Application 타입 application/json, application/x-www-form-urlencode File 업로드하기 위한 타입 multipart/formed-date Request Body에 담아 전송할 데이터의 MIME-type을 지정하는 예제 코드는 다음과 같다.123456xhr.open(&apos;POST&apos;, &apos;/users&apos;);xhr.setRequestHeader(&apos;Content-type&apos;, &apos;application/json&apos;);xhr.send(JSON.stringify(&#123; name: &quot;donald&quot;, country: &quot;United States&quot;&#125;); ‘Accept’은 HTTP 클라이언트가 서버에 요청할 때, 서버가 센드백할 데이터의 MIME-type을 지정할 때 사용한다.예를 들어, 아래와 같이 작성한다.1xhr.setRequestHeader(&apos;Accept&apos;, &apos;application/json&apos;); 만약 ‘Accept’ 헤더를 설정하지 않을 경우, send 메소드가 호출될 때, ‘Accept’ 헤더가 /와 함께 전송된다.(/은 모든 MIME 타입을 의미한다.) 자세한 ‘Accept’에 대한 개념은 MDN에서 확인해보자. 클라이언트와 서버사이에서의 Request &amp; Response Message는 다음과 같다. 출처: HTTP Request and Resopnse Message 3. 서버로부터 받은 응답 처리하기 XMLHttpRequest 객체를 사용해서 Ajax 응답 처리에 대한 코드는 다음과 같다. 123456789xhr.onreadystatechange = function (e) &#123; if (xhr.readyState === XMLHttpRequest.DONE) &#123; if(xhr.status === 200) &#123; console.log(xhr.responseText); &#125; else &#123; console.log(&apos;Error!&apos;); &#125; &#125;&#125;; 3-1. XMLHttpRequest.onreadystatechange 호출XMLHttpRequest가 가지고 있는 readyState 프로퍼티가 변경(사용자로부터 이벤트 발생) 될 때마다, XMLHttpRequest가 가지고 있는 프로퍼티인 onreadystatechange(이벤트 핸들러)를 호출한다.123xhr.onreadystatechange = function (e) &#123; // readyState 프로퍼티가 변경될 때마다, 이 함수를 호출&#125; 3-2. XMLHttpRequest.readyState로 서버가 응답했는지 확인123if (xhr.readyState === XMLHttpRequest.DONE) &#123; // readyState가 완료되면, 이 함수를 호출&#125; XMLHttpRequest.readyState의 값은 아래와 같다. Value State Description 0 UNSENT XMLHttpRequest.open() 메소드 호출 이전 1 OPENED XMLHttpRequest.open() 메소드 호출 완료 2 HEADERS_RECEIVED XMLHttpRequest.send() 메소드 호출 완료 3 LOADING 서버 응답 중(XMLHttpRequest.responseText 미완성 상태) 4 DONE 서버 응답 완료 xhr.readyState의 값이 4(DONE)이면, 서버가 응답을 완료했다는 뜻이다. 3-3. XMLHttpRequest.status로 정상 응답인지 확인12345if(xhr.status === 200) &#123; console.log(xhr.responseText);&#125; else &#123; console.log(&apos;Error!&apos;);&#125; 응답코드가 200번 대 숫자면 정상 응답이므로, xhr.status가 정상적인 응답코드이면, 서버로부터 전송되는 데이터가 담겨 있는 xhr.responseText가 클라이언트로 전달된다.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://cheonmro.github.io/categories/Javascript/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"https://cheonmro.github.io/tags/Ajax/"}]},{"title":"REST API란 무엇인가?","slug":"rest-api","date":"2018-08-30T04:06:44.000Z","updated":"2018-08-30T04:06:44.265Z","comments":true,"path":"2018/08/30/rest-api/","link":"","permalink":"https://cheonmro.github.io/2018/08/30/rest-api/","excerpt":"","text":"REST API란? REpresentational State Transfer의 약자로, 서버의 자원을 정의하고, 자원에 대한 주소를 지정하는 방법(표기법)을 말한다. 2000년, 아파치 HTTP 서버 프로젝트의 공동설립자인 Roy fielding(로이 필딩)에 의해 처음 소개가 되었는데, 이 분은 HTTP/1.0,1.1 스펙 작성에 참여하신 분이다. 그는 웹의 장점을 최대한 활용할 수 있는 Architecture로써 REST를 소개하면서, REST API 규칙을 만들었다. 이런 REST API 규칙을 잘 지킨 서비스 디자인을 “RESTful”하다고 표현한다. REST API는 HTPP 프로토콜을 정확히 의도에 맞게 활용하여 디자인하게 유도하기 때문에, 디자인 기준이 명확해지고, 의미적인 범용성을 지닌다. 즉, 서버가 이해하기 쉽게 자원에 대한 주소를 지정하는 표기법이 REST API이다. REST API 구성 요소 REST API를 구성하는 것은 다음과 같이 3가지가 있다. 자원(Resource) 행위(Verb) 표현(Representation) 자원(Resource) 자원(Resource)이란, 해당 소프트웨어가 관리하는 모든 것이 될 수 있다.JSON, XML 등의 문서가 될 수 있고, 그림파일이 될 수도 있다.즉, 어떤 데이터(문서, 파일, 비디오 등)를 말한다. 예를 들어, 서버 데이터베이스에 사용자들에 대한 정보가 들어가 있다면, 이 사용자들의 정보가 데이터이기 때문에, 자원(Resource)이 된다. 이때, 이 사용자들에 대한 데이터를 대표하는 이름을 users라고 해보자. 만약, 이 사용자들 중에서 어떤 한 명의 사용자에 대한 자원을 얻고자 한다면 어떻게 해야할까? 그럴때는, users/id 처럼, 사용자들 중 특정 id로 사용자를 구분해서 사용할 수 있다. 자원(Resource)은 HTTP URI로 표현한다. 예를 들어, http://localhost:4000/users/1 이런식으로 작성하며, 이 URI를 이용하여 원하는 자원(Resource)에 접근할 수 있다. 행위(Verb) REST API에서 말하는 행위(Verb)는 자원에 대한 행위를 말한다. 즉, HTTP Method를 사용해서 자원을 얻거나, 만들거나, 변경하거나, 삭제하는 등의 행위를 할 수 있다. HTTP Method 중 대표적으로 자주 사용되는 메서드는 다음과 같다. GET : 서버 자원을 가져오고자 할 때 사용한다.(Retrieve: 모든/특정 자원을 조회) POST : 서버에 자원을 새로 등록하고자 할 때 사용한다.(Create: 자원을 생성) PUT : 서버의 자원을 새로 요청한 자원으로 변경하고자 할 때 사용한다.(Update: 자원을 갱신) PATCH : 서버 자원의 일부만 수정하고자 할 때 사용한다. DELETE : 서버의 자원을 삭제하고자 할 때 사용한다.(Delete: 자원을 삭제) 위 4가지(GET/POST/PUT/DELETE)를 이용해서 CRUD를 구현할 수 있다. 표현(Representation) 표현(Representation)은 자원에 대한 행위의 내용을 말하는데, 이때 내용은 서버에 요청할 때 무엇인가를 새로 생성하거나, 변경할 때 필요한 내용을 말한다. 이때, HTTP Message인 payload를 사용한다. 서버 자원에 무언가 새로운 것을 생성할 때, HTTP Method 중 POST와 함께 payload를 같이 요청한다. 예를 들어, 사용자들에 대한 정보가 있는 users에 새로운 사용자 정보를 생성하고 싶다면, 이 새로운 사용자에 대한 정보를 새로 만들어서 추가해줘야 하는데, 이것을 payload라고 한다. 1234567POST http://localhost:4000/users/&#123; &quot;id&quot;: 1, &quot;name: &quot;Ro&quot;, &quot;country&quot;: &quot;Korea&quot;&#125; 위 객체를 payload라고 하는데, 위 자원(http://localhost:4000/users/) 에 POST 방식으로 위 payload(객체)와 함께 서버에 요청을 해야한다. REST API 중심 규칙 위와 같은 내용을 잘 정리한 것이 REST API 중심 규칙이다.REST한 API를 설계하기 위한 중심 규칙은 대표적으로 2가지이다. 1. URI는 정보의 자원을 표현해야 한다. URI는 정보의 자원을 표현하는데 중점을 두어야 하기 때문에, 어떤 행위를 나타내는 동사보다는 자원의 의미를 명확히 전달하기 위해 명사를 사용해야 한다. id가 1인 사용자에 대한 자원을 얻고 싶다면, 다음과 같이 작성해야 한다. 1GET /users/1 행위를 나타내는 다음과 같은 URI는 잘못된 방법이다. 12GET /getUsers/1GET /users/show/1 2. 자원에 대한 행위는 HTTP Method로 표현한다. 1DELETE /users/1 REST API Architecture REST API는 자원과 메서드만 보고 요청의 내용을 명확하게 알 수 있다는 것이 장점이다. 이런 REST API의 Architecture를 보면 다음과 같다. 출처: REST API Architecture 어떤 클라이언트(웹브라우저/안드로이드 앱/ios 앱)에서 서버에 요청을 할 때 HTTP 통신을 하고, HTTP Method를 사용하여 원하는 행위를 하여 서버로부터 응답을 받는다. REST API 사용 예제 Ajax를 사용하여 REST API를 어떻게 사용하는지 알아보자. 사용자에 대한 정보인 users 데이터는 다음과 같다고 해보자. 123456789101112131415161718192021222324&#123; &quot;users&quot;: [ &#123; &quot;id&quot;: 1, &quot;name&quot;: &quot;Ro&quot;, &quot;country&quot;: &quot;Korea&quot; &#125;, &#123; &quot;id&quot;: 2, &quot;name&quot;: &quot;John&quot;, &quot;country&quot;: &quot;Canada&quot; &#125;, &#123; &quot;id&quot;: 3, &quot;name&quot;: &quot;Doh&quot;, &quot;country&quot;: &quot;China&quot; &#125;, &#123; &quot;id&quot;: 4, &quot;name&quot;: &quot;Hitaro&quot;, &quot;country&quot;: &quot;Japan&quot; &#125; ]&#125; 1. GET 1-1. users 자원에서 모든 사용자의 정보를 가져온다.(모든 사용자)1GET http://localhost:4000/users 위와 같이 users에 대한 자원을 GET하게 되면 다음과 같이 모든 users에 대한 정보를 가져올 수 있다. 12345678910111213141516171819202122[ &#123; &quot;id&quot;: 1, &quot;name&quot;: &quot;Ro&quot;, &quot;country&quot;: &quot;Korea&quot; &#125;, &#123; &quot;id&quot;: 2, &quot;name&quot;: &quot;John&quot;, &quot;country&quot;: &quot;Canada&quot; &#125;, &#123; &quot;id&quot;: 3, &quot;name&quot;: &quot;Doh&quot;, &quot;country&quot;: &quot;China&quot; &#125;, &#123; &quot;id&quot;: 4, &quot;name&quot;: &quot;Hitaro&quot;, &quot;country&quot;: &quot;Japan&quot; &#125; ] 이것을 코드로 작성하면 다음과 같다. 12345678910111213var req = new XMLHttpRequest();req.open(&apos;GET&apos;, &apos;http://localhost:4000/users&apos;);req.send();req.onreadystatechange = function (e) &#123; if (req.readyState === XMLHttpRequest.DONE) &#123; if(req.status === 200) &#123; console.log(req.responseText); &#125; else &#123; console.log(&quot;Error!&quot;); &#125; &#125;&#125;; 1-2. users 자원에서 id가 1인 사용자의 정보를 가져온다.(특정 사용자)1GET http://localhost:4000/users/1 위와 같이 users 자원에서 id가 1인 사용자에 대한 자원을 GET하게 되면 다음과 같이 id가 1인 사용자에 대한 정보를 가져올 수 있다. 12345&#123; &quot;id&quot;: 1, &quot;name&quot;: &quot;Ro&quot;, &quot;country&quot;: &quot;Korea&quot;&#125; 이것을 코드로 작성하면 다음과 같다. 12345678910111213var req = new XMLHttpRequest();req.open(&apos;GET&apos;, &apos;http://localhost:4000/users/1&apos;);req.send();req.onreadystatechange = function (e) &#123; if (req.readyState === XMLHttpRequest.DONE) &#123; if(req.status === 200) &#123; console.log(req.responseText); &#125; else &#123; console.log(&quot;Error!&quot;); &#125; &#125;&#125;; 2. POSTusers 자원에 새로운 사용자의 정보를 생성한다.123POST http://localhost:4000/users&quot;Content-Type: application/json&quot;&apos;&#123;&quot;name&quot;: &quot;donald&quot;, &quot;country&quot;: &quot;United States&quot;&#125;&apos; 새로운 사용자의 정보를 생성하기 위해서는 payload가 필요하며, 위와 같이 Content-Type 등을 추가로 작성해야 한다. 12345&#123; &quot;name&quot;: &quot;donald&quot;, &quot;country&quot;: &quot;United States&quot;, &quot;id&quot;: 5&#125; 이것을 코드로 작성하면 다음과 같다. 1234567891011121314151617var req = new XMLHttpRequest();req.open(&apos;POST&apos;, &apos;http://localhost:4000/users&apos;);req.setRequestHeader(&apos;Content-type&apos;, &apos;application/json&apos;);req.send(JSON.stringify(&#123; name: &quot;donald&quot;, country: &quot;United States&quot;&#125;));req.onreadystatechange = function (e) &#123; if (req.readyState === XMLHttpRequest.DONE) &#123; if(req.status === 201) &#123; console.log(req.responseText); &#125; else &#123; console.log(&quot;Error!&quot;); &#125; &#125;&#125;; 3. PUTusers 자원에서 새로 추가된 name을 jack으로 변경한다.123PUT http://localhost:4000/users/5&quot;Content-Type: application/json&quot;&apos;&#123;&quot;name&quot;: &quot;jack&quot;, &quot;country&quot;: &quot;United States&quot;&#125;&apos; PUT은 특정 id에 대한 어떤 정보를 변경할 때, payload에 모든 정보를 포함해서 보내준다. 12345&#123; &quot;name&quot;: &quot;jack&quot;, &quot;country&quot;: &quot;United States&quot;, &quot;id&quot;: 5&#125; 이것을 코드로 작성하면 다음과 같다. 1234567891011121314151617var req = new XMLHttpRequest();req.open(&apos;PUT&apos;, &apos;http://localhost:4000/users/5&apos;);req.setRequestHeader(&apos;Content-type&apos;, &apos;application/json&apos;);req.send(JSON.stringify(&#123; name: &apos;jack&apos;, country: &quot;United States&quot;&#125;));req.onreadystatechange = function (e) &#123; if (req.readyState === XMLHttpRequest.DONE) &#123; if(req.status === 200) &#123; console.log(req.responseText); &#125; else &#123; console.log(&quot;Error!&quot;); &#125; &#125;&#125;; 4. DELETEusers 자원에서 id가 5인 사용자를 삭제한다.1DELETE http://localhost:4000/users/5 사용자의 id까지 포함해서 DELETE 해야한다. 1&#123;&#125; 이것을 코드로 작성하면 다음과 같다. 12345678910111213var req = new XMLHttpRequest();req.open(&apos;DELETE&apos;, &apos;http://localhost:4000/users/5&apos;);req.send();req.onreadystatechange = function (e) &#123; if (req.readyState === XMLHttpRequest.DONE) &#123; if(req.status === 200) &#123; console.log(req.responseText); &#125; else &#123; console.log(&quot;Error!&quot;); &#125; &#125;&#125;;","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://cheonmro.github.io/categories/Javascript/"}],"tags":[{"name":"REST API","slug":"REST-API","permalink":"https://cheonmro.github.io/tags/REST-API/"}]},{"title":"트랜스파일링을 위한 typescript 개발환경 구축 방법","slug":"typescript-compiler","date":"2018-08-08T06:19:55.000Z","updated":"2018-08-08T06:19:55.741Z","comments":true,"path":"2018/08/08/typescript-compiler/","link":"","permalink":"https://cheonmro.github.io/2018/08/08/typescript-compiler/","excerpt":"","text":"Typescript와 트랜스파일링 자바스크립트의 문제점을 보완하기 위해 typescript을 사용한다. 그러나, typescript으로 작성한 파일은 브라우저에서 동작하지 않는다. 따라서, typescript로 작성한 파일을 자바스크립트로 변환해야 하는데, 이를 트랜스파일링 또는 컴파일이라고 한다. 트랜스파일링을 하기 위해서는 typescript 컴파일러를 설치하여 사용하는 typescript 개발환경을 구축해야한다. typescript 컴파일러 설치 방법 다음과 같이 typescript를 전역에 설치한다.1npm install -g typescript 설치가 완료되면, typescript의 버전 체크를 하여, typescript 컴파일러 설치가 제대로 되었는지 확인한다.1tsc -v typescript 컴파일러로 트랜스파일링 하기 typescript로 작성된 파일(.ts)을 자바스크립트 파일로 트랜스파일링 하기 위해서는, 위에서 설치한 typescript 컴파일러(tsc)를 사용한다. 1개의 파일 트랜스파일링 하기 아래의 코드를 작성하고, 확장자를 .ts로 하는 typescript 파일로 만든다.1234567891011121314class Cafe &#123; private name: string; constructor(name: string) &#123; this.name = name; &#125; greeting() &#123; return &quot;Welcome to&quot; + this.name; &#125;&#125;const cafe = new Cafe(&apos;Starbucks&apos;);console.log(cafe.greeting()); 위 typescript 파일을 트랜스파일링하여 자바스크립트로 만들기 위해서는 아래의 명령어를 작성하면 된다.1tsc cafe tsc 다음에 위 파일(cafe.ts)의 이름(cafe)을 입력하면 된다. 그러면, 트랜스파일링이 되어, 또 하나의 자바스크립트 파일이 생성된다.1234567891011121314&quot;use strict&quot;;exports.__esModule = true;var Cafe = /** @class */ (function () &#123; function Cafe(name) &#123; this.name = name; &#125; Cafe.prototype.greeting = function () &#123; return &quot;Welcome to&quot; + this.name; &#125;; return Cafe;&#125;());exports.Cafe = Cafe;var cafe = new Cafe(&apos;Starbucks&apos;);console.log(cafe.greeting()); 그런데, 트랜스파일링된 자바스크립트 파일은 ES3 버전으로 생성되는데, 이는 트랜스파일링해서 생성되는 기본 버전이 ES3이기 때문이다. target 컴파일 옵션을 사용해서 원하는 버전으로 트랜스파일링 하기 만약 원하는 버전으로 트랜스파일링 하고 싶다면, typescript 컴파일 옵션중 –target또는 -t를 사용하면 된다.1tsc cafe -t es6 ES6 버전은 아래와 같이 나온다.12345678910class Cafe &#123; constructor(name) &#123; this.name = name; &#125; greeting() &#123; return &quot;Welcome to&quot; + this.name; &#125;&#125;const cafe = new Cafe(&apos;Starbucks&apos;);console.log(cafe.greeting()); 그러면, 처음에 생성된 ES3 버전의 자바스크립트 파일이 ES6 버전의 자바스크립트 파일로 코드의 내용이 변경된다. 2개의 파일 트랜스파일링 하기 2개의 typescript 파일을 작성하여, 트랜스파일링을 해보자.123456789101112131415// cafe.tsexport class Cafe &#123; protected name: string; constructor(name: string) &#123; this.name = name; &#125; greeting() &#123; return &quot;Welcome to&quot; + this.name; &#125;&#125;const cafe = new Cafe(&apos;Starbucks&apos;);console.log(cafe.greeting()); 123456789101112// bakery.tsimport &#123; Cafe &#125; from &apos;./cafe&apos;;class Bakery extends Cafe &#123; bake(): string &#123; return `$&#123;this.name&#125; is baking bread. Wow!!`; &#125;&#125;const bakery = new Bakery(&apos;Starbucks&apos;);console.log(bakery.greeting());console.log(bakery.bake()); 위 두개의 typescript 파일들을 트랜스파일링 하기 위한 명령어를 작성하면 된다.1tsc cafe bakery 그러면, 두개의 typescript 파일들이 두개의 자바스크립트 파일로 트랜스파일링 된다. 3개 이상의 파일 트랜스파일링 하기 3개 이상의 모든 typescript 파일들을 한번에 트랜스파일링 하기위해서는 와일드카드(*)를 사용해야 한다.1tsc *.ts 자동으로 트랜스파일링 하기 typescript 컴파일 옵션 중 —watch 또는 -w 를 사용하면, 파일의 내용이 변경되었을 때, 이를 감지하여 자동으로 그 파일이 트랜스파일링 된다.1tsc bakery —watch","categories":[{"name":"typescript","slug":"typescript","permalink":"https://cheonmro.github.io/categories/typescript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://cheonmro.github.io/tags/typescript/"},{"name":"typescript compiler","slug":"typescript-compiler","permalink":"https://cheonmro.github.io/tags/typescript-compiler/"}]},{"title":"typescript란 무엇인가?","slug":"what-is-typescript","date":"2018-08-07T13:36:53.000Z","updated":"2018-08-28T11:45:51.125Z","comments":true,"path":"2018/08/07/what-is-typescript/","link":"","permalink":"https://cheonmro.github.io/2018/08/07/what-is-typescript/","excerpt":"","text":"typescript란 무엇인가? typescript는 자바스크립트에서 좀 더 확장된 언어로, 자바스크립트의 문법을 포함하면서 자바스크립트가 가지고 있는 문제를 보완하기 위한 문법을 가진 언어이다. 2012년에 마이크로소프트에서 발표한 오픈소스로써, C#을 개발한 아네르스 하일스베르가 개발하였다. 위 그림과 같이, 타입스크립트는 ES5, ES6를 모두 포함하는 자바스크립트의 상위집합이기 때문에, 타입스크립트에서 기존의 자바스크립트 문법을 그대로 사용할 수 있다. 또한, 타입스크립트는 아직 ECMAScript 표준에 포함되지는 않았지만(2018년 7월 기준), ECMAScript의 업그레이드에 따른 새로운 기능(스펙)을 계속 추가하기 때문에, ECMAScript의 표준을 따라가는 것처럼 보인다. typescript를 왜 사용할까? C나 JAVA와 같은 C-family 언어와는 다른 자바스크립트만의 특성이 있다. 프로토타입 기반 객체지향 언어 스코프와 this 동적 타입 언어 이와 같은 특성들은 클래스 기반 객체지향 언어(C, JAVA 등)에 익숙한 개발자에게는 혼란스럽다.또한, 할당하는 값에 따라 타입이 바뀌는 문제도 있어, 꼭 타입 체크를 해줘야 하는 점도 있다. 이런 문제들을 보완하기 위해, 타입스크립트에는 클래스, 정적 타이핑 등이 포함되어있다. 자바스크립트의 프레임워크인 Angular는 주력 언어로 타입스크립트를 채용했기 때문에, Angular를 사용하는 개발자는 타입스크립트를 이해하는 것이 필수적이다. 즉, Angular는 타입스크립트 뿐만 아니라, 자바스크립트, Dart 등으로도 작성이 가능하지만, Angular 사이트에 나와있는 문서나 커뮤니티 활동에서도 가장 많이 사용되고 있어, Angular를 사용하고 싶다면 타입스크립트를 아는 것이 좋다.","categories":[{"name":"typescript","slug":"typescript","permalink":"https://cheonmro.github.io/categories/typescript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://cheonmro.github.io/tags/typescript/"}]},{"title":"hexo 블로그 포스트 작성 및 배포하는 방법","slug":"how-to-write-posts","date":"2018-08-05T15:37:33.000Z","updated":"2018-08-05T15:37:33.768Z","comments":true,"path":"2018/08/06/how-to-write-posts/","link":"","permalink":"https://cheonmro.github.io/2018/08/06/how-to-write-posts/","excerpt":"","text":"hexo 블로그에 포스트 작성 및 배포하는 방법 새 포스트 작성을 위한 글제목 명령어를 입력한다. 1hexo new option 글제목 이 명령어를 작성하게 되면, 글제목 폴더와 글제목.md 파일이 만들어진다.이미지는 글제목 폴더에서 관리하고, 글의 내용은 글제목.md 파일에서 관리한다.만약, 글제목 폴더가 만들어지지 않는다면, _config.yml에서 post_asset_folder: true를 추가하면 된다. 이때, option에는 ‘post’ 또는 ‘draft’가 올 수 있다. 만약 작성한 글을 바로 배포하려면 ‘post’라고 쓴다.1hexo new post 글제목 바로 배포하지 않고, 초안으로 보관만 하려고 할 때는 ‘draft’라고 쓴다.1hexo new draft 글제목 draft 글을 배포하기 위해서 _posts 폴더로 이동시킨다. ‘draft’를 사용하여 명령어를 입력하게 되면, source/_drafts 폴더에 저장된다.이 폴더에 저장이 되면, 배포 대상에서 제외되기 때문에, 원래 사용하던 ‘hexo server’로는 확인할 수 없고 ‘–draft’라는 옵션을 추가해여 로컬 서버에서 확인이 가능하다.1hexo server --draft 초안이 다 완성이 되어 배포를 하고 싶을 경우, 해당 파일과 폴더가 source/_posts 폴더에 있어야 한다.이때, 아래와 같은 명령어를 입력하면 해당 파일과 폴더과 source/_posts로 이동하게 된다.1hexo publish post 글제목 _posts 폴더에 있는 글을 블로그에 배포한다. 최종적으로, source/_posts안에 있는 모든 글들을 배포하기 위해 아래의 명령어를 입력한다.1hexo generate --deploy","categories":[{"name":"hexo","slug":"hexo","permalink":"https://cheonmro.github.io/categories/hexo/"}],"tags":[{"name":"hexo posts","slug":"hexo-posts","permalink":"https://cheonmro.github.io/tags/hexo-posts/"}]},{"title":"hexo를 이용해서 블로그를 설치하는 방법","slug":"how-to-setup-hexo","date":"2018-08-05T15:24:54.000Z","updated":"2018-08-05T15:24:54.154Z","comments":true,"path":"2018/08/06/how-to-setup-hexo/","link":"","permalink":"https://cheonmro.github.io/2018/08/06/how-to-setup-hexo/","excerpt":"","text":"hexo를 이용해서 블로그 설치하기 hexo 설치하기 hexo 설치하기 위해서는 기본적으로 설치해야할 것이 2가지가 있다. Node.js Git 위 2개를 설치했다면, 먼저 npm을 사용해서 hexo를 설치해야 한다.나같은 경우에는 git을 관리하는 dev 폴더안에서 설치했다.1npm install hexo-cli -g 본인이 원하는 이름(나의 경우: myblog)으로 hexo init을 하고, npm을 설치한다.123hexo init myblogcd myblognpm install hexo 서버를 통해 구축된 hexo 기본 사이트를 확인한다.1hexo server 위와 같이 따라서 설치하면 기본적인 hexo 블로그를 로컬 호스트로 구축을 할 수 있다. Github에서 제공하는 github.io로 사이트 구축하기 hexo 블로그를 사용하기 위해서는 깃헙에서 제공하는 블로그용 깃헙사이트가 필요하다. Github에서 블로그용으로 만들 repo를 생성한다.repo를 username.github.io 이런식으로 만들면 된다. 내 컴퓨터로 클론한다.나같은 경우 dev 폴더안에서 클론했다.1git clone https://github.com/cheonmro/cheonmro.github.io.git _config.yml에서 세팅하기 실제 사이트 url로 배포하기 위해 기본적인 세팅이 필요하다.세팅 관련해서는 항상 _config.yml에서 한다. 앞으로 hexo 블로그를 이용해서 작성할 모든 내용들을, 위에서 생성한 블로그용 깃헙에서 관리를 할 것이기 때문에, 아래와 같이 type에 git으로 하고, repository에 자신의 블로그용 깃헙 주소를 작성한다.1234deploy: type: git repository: https://github.com/cheonmro/cheonmro.github.io branch: master 구축한 사이트 배포하기 지금까지 구축한 hexo 블로그를 배포(deploy)한다.1hexo deploy 위 명령어를 실행하게 되면, 자동으로 commit, push가 되어, 깃헙과 웹사이트(블로그)에 파일들이 generate되어, 기본적인 사이트 구축이 완성되게 된다.(웹사이트 자체를 배포할 때 사용한다.) 위에서 구축한 사이트를 직접 확인한다.1https://cheonmro.github.io/ hexo 블로그의 테마를 바꾸는 방법 위와 같이, 기본적인 hexo 블로그 설치는 간단한다.기본적으로 themes 폴더안에 있는 landscape 테마를 바탕으로한 기본 사이트가 구축된다. hexo 블로그에서 테마를 바꾸고 싶을 때는, 원하는 테마를 themes 안에 가져오고, _config.yml에서 theme의 이름만 바꿔주면 된다. 원하는 테마를 themes 폴더안으로 git clone 한다.(나같은 경우는 hexo-theme-hipaper 테마를 사용했다.)1git clone https://github.com/iTimeTraveler/hexo-theme-hipaper.git _config.yml에서 theme 옆에 이름을 새로 변경할 테마의 이름으로 바꾼다.1theme: hexo-theme-hipaper 기존 테마를 지우고, 새로 변경할 테마로 바꾸려면, hexo 블로그를 다시 배포(deploy)해야한다.1hexo deploy 위와같이 하면, Github의 파일들이 새로 변경할 테마의 내용들로 바뀌고, 사이트 또한 새롭게 변경된다. 만약, “Deployer not found: git” 이라는 에러가 난다면, deployer를 설치하면 된다.1npm install hexo-deployer-git --save 그리고, 다시 배포한다.1hexo deploy","categories":[{"name":"hexo","slug":"hexo","permalink":"https://cheonmro.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://cheonmro.github.io/tags/hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-08-05T13:24:49.289Z","updated":"2018-08-05T13:24:49.289Z","comments":true,"path":"2018/08/05/hello-world/","link":"","permalink":"https://cheonmro.github.io/2018/08/05/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}