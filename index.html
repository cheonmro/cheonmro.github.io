<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Page 1 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://cheonmro.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >
  <link rel="stylesheet" href="/css/fashion.css" >
  <link rel="stylesheet" href="/css/glyphs.css" >

</head>



  <body>


  


<header id="allheader" class="site-header" role="banner"
   >
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" rel="home" >
                <img style="margin-bottom: 10px;"  width="124px" height="124px" alt="Hike News" src="https://hexo.io/logo.svg">
              </a>
            
          </h1>

          

          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>

            <div class="clearfix sf-menu">
              <ul id="main-nav" class="menu sf-js-enabled sf-arrows"  style="touch-action: pan-y;">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/">Home</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/categories">Categories</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/about">me &amp; projects</a> </li>
                    
              </ul>
            </div>
          </nav>

      </div>
  </div>
</header>


  <div id="container">
    <div id="wrap">

      <div id="content" class="outer">
        
          <section id="main">
  
    <article id="post-react-lifecycle-api"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/03/08/react-lifecycle-api/">Lifecycle API</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/03/08/react-lifecycle-api/" class="article-date">
	  <time datetime="2019-03-08T14:49:53.000Z" itemprop="datePublished">March 8, 2019</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/React/">React</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Lifecycle-API란-무엇인가"><a href="#Lifecycle-API란-무엇인가" class="headerlink" title="Lifecycle API란 무엇인가?"></a>Lifecycle API란 무엇인가?</h1><hr>
<p><strong>Lifecycle API란, 컴포넌트가 브라우저에서 생성될 때/업데이트 될 때/제거될 때, 호출되는 API이다.</strong></p>
<p>React 컴포넌트의 lifecycle은 다음과 같다.</p>
<p><img src="/images/lifecycle.png" alt="React 컴포넌트의 lifecycle"><br>출처: <a href="https://velopert.com/1130" target="_blank" rel="noopener">React 컴포넌트의 lifecycle</a></p>
<p><br></p>
<h1 id="React-lifecycle-API-3단계"><a href="#React-lifecycle-API-3단계" class="headerlink" title="React lifecycle API 3단계"></a>React lifecycle API 3단계</h1><hr>
<p><strong>Mounting: React 컴포넌트의 인스턴스가 생성되고, DOM에 삽입되는 과정의 lifecycle</strong></p>
<ul>
<li>constructor</li>
<li>componentWillMount</li>
<li>render</li>
<li>componentDidMount</li>
</ul>
<p><strong>Updating: prop 또는 state의 변경으로 해당 컴포넌트가 re-rendering 되는 경우의 lifecycle</strong></p>
<ul>
<li>componentWillReceiveProps(props가 변경될 때만)</li>
<li>shouldComponentUpdate</li>
<li>componentWillUpdate</li>
<li>render</li>
<li>componentDidUpdate</li>
</ul>
<p><strong>Unmounting: 컴포넌트가 제거되는 과정의 lifecycle</strong></p>
<ul>
<li>componentWillUnmount</li>
</ul>
<p><br></p>
<h1 id="Mounting"><a href="#Mounting" class="headerlink" title="Mounting"></a>Mounting</h1><hr>
<p><strong>React 컴포넌트의 인스턴스가 생성되고, DOM에 삽입되는 과정의 lifecycle</strong></p>
<p><br></p>
<h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><hr>
<p><strong>우선, lifecycle API 전에 컴포넌트가 새로 만들어질 때마다 제일 먼저 호출되는 것이 바로, constructor(컴포넌트 생성자 함수)이다.</strong></p>
<p>참고로, 컴포넌트에서 state를 정의할 때는 2가지 방법 중 하나를 사용하면 된다.</p>
<ul>
<li>Class fields 문법</li>
<li>Constructor 사용</li>
</ul>
<h3 id="Class-fields-문법"><a href="#Class-fields-문법" class="headerlink" title="Class fields 문법"></a>Class fields 문법</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class InvestContainer extends Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    number: 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="Constructor-사용"><a href="#Constructor-사용" class="headerlink" title="Constructor 사용"></a>Constructor 사용</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class InvestContainer extends Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      number: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>super(props)를 호출한 이유:</strong></p>
<p>ES6 class의 constructor에서 super 메소드를 사용하는 이유는, 자식 클래스에서 super 메소드를 사용함으로써 자식 class의 constructor 내부에서 부모 클래스의 constructor를 호출한다. 즉, 부모 클래스의 인스턴스를 생성해서, this를 사용할 수 있게 된다. 만약 super 키워드를 사용하지 않으면, this에 대한 참조 에러가 발생한다. 다시 말하면, super 메소드를 호출하기 이전에는 this를 참조할 수 없다는 것을 의미한다.</p>
<p>리액트에서 컴포넌트를 class형으로 만들때는, 모두 기본적으로 리액트에 있는 ‘Component’라는 부모 클래스로부터 상속받아 자식 클래스로 시작하게 된다. 그래서 자식 클래스에서는 super 메소드를 사용해서 , 부모 클래스(Component)의 constructor를 호출, 즉 Component 클래스의 인스턴스를 생성해서 this를 사용할 수 있게 되는 것이다. 그 다음에, this를 이용해 프로퍼티를 초기화할 수 있다.</p>
<p>이 방법이 더 복잡하므로, class fields 문법으로 주로 사용하는 것이 더 편리!</p>
<p><br></p>
<h2 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount"></a>componentWillMount</h2><hr>
<p><strong>컴포넌트가 브라우저에 나타나기 전(화면에 나가기 전)에 호출되는 API이다.</strong></p>
<p>사용 이유</p>
<ul>
<li>mount 직전에 하고 싶은 것들(i.e. 방문자가 어떤 페이지를 방문했는지 Google Anlaytics에 신호할 때)이 있을 경우 사용</li>
<li>루트 컴포넌트에서 APP과 관련된 외부 API를 설정할 때 사용</li>
</ul>
<p>React v16.3 이후부터는 해당 API가 deprecated 되어서, 사용하면 안된다.<br>기존에 이 API에서 하던 것들을 constructor와 componentDidMount에서 처리 가능하다.</p>
<p><br></p>
<h2 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h2><hr>
<p><strong>컴포넌트가 화면에 나타나게 됐을 때, 호출되는 API이다. 즉, 컴포넌트가 생성되어 DOM까지 render가 다 된 후, 실행된다.</strong></p>
<p>사용 이유</p>
<ul>
<li>DOM에 대한 접근이 필요한 모든 설정을 수행할 때 사용(DOM의 속성을 읽거나 직접 변경하는 작업 등)</li>
<li>해당 컴포넌트에서 필요로하는 데이터를 요청하기 위해 사용(axios, fetch 등을 통한 ajax 요청)</li>
<li>외부 라이브러리 연동</li>
</ul>
<p><br></p>
<h1 id="Updating"><a href="#Updating" class="headerlink" title="Updating"></a>Updating</h1><hr>
<p><strong>컴포넌트의 업데이트는 props 또는 state의 변화에 따라 결정된다.</strong></p>
<p><br></p>
<h2 id="componentWillReceiveProps"><a href="#componentWillReceiveProps" class="headerlink" title="componentWillReceiveProps"></a>componentWillReceiveProps</h2><hr>
<p><strong>컴포넌트가 새로운 props를 받게됐을 때 호출되는 API이다. 즉, 새로운 props로 어떠한 작업을 수행하기 전에, 이 새로운 props를 인자로하여 이 API가 호출된다. 새로 받게될 props는 nextProps로 조회 가능하고, this.props는 현재의 props를 말한다.</strong></p>
<p>사용 이유</p>
<ul>
<li>props를 받아서 state를 변경해야 하는 경우 유용하다.</li>
</ul>
<p>다음과 같이 작성할 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">  if (this.props.percent !== nextProps.percent) &#123;</span><br><span class="line">    this.setUpPercent(nextProps.percent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>이 API는 초기 렌더링시에는 호출되지 않는다.</p>
<p><br></p>
<h2 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h2><hr>
<p><strong>컴포넌트 업데이트 직전에 호출되는 API이다.</strong></p>
<p>사용 이유</p>
<ul>
<li>컴포넌트를 최적화하는 작업에 사용<ul>
<li>즉, 해당 컴포넌트의 re-rendering를 제어할 때 사용</li>
</ul>
</li>
</ul>
<p>이 API는 항상 boolean(true 또는 false)을 반환한다. 즉, 해당 컴포넌트를 re-rending할지 말지를 결정하는 API이다.</p>
<p>컴포넌트를 최적화하기 위해서는, 필요없는 re-rending을 막아야 하고, 그러기 위해서는 props 또는 state가 변경되었을 때만, re-rendering 하게끔 이 API안에서 코드를 작성하면 된다.</p>
<p>예를 들어, 다음과 같이 작성하면 된다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">  return this.props.engagement !== nextProps.engagement</span><br><span class="line">    || nextState.input !== this.state.input;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="componentWillUpdate"><a href="#componentWillUpdate" class="headerlink" title="componentWillUpdate"></a>componentWillUpdate</h2><hr>
<p><strong>이 API는 update가 발생하기 전 어떤 작업이 필요한 경우 사용하는 API로써, shouldComponentUpdate에서 true를 반환했을 때만, 호출되는 API이다.</strong> shouldComponentUpdate가 이미 사용되고 있는 컴포넌트에서 componentWillReceiveProps를 대신 사용한다. 이 API가 호출되고 난 다음에는 render() 함수가 호출된다.</p>
<p>사용 이유</p>
<ul>
<li>애니메이션 효과르 초기화할 때 사용</li>
<li>이벤트 리스너를 없앨 때 사용</li>
</ul>
<p>이 API에서는 this.setState()를 사용하면 무한 루프가 일어나게 되므로 사용하면 안된다.</p>
<p><br></p>
<h2 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a>componentDidUpdate</h2><hr>
<p><strong>componentWillUpdate 이후, render() 함수가 호출된 뒤에 호출되는 API이다.</strong><br>이 시점에서는 this.props와 this.state가 새로 변경되었고, 대신에 이전 값들인 prevProps와 prevState를 조회할 수 있다.</p>
<p>사용 이유</p>
<ul>
<li>props 또는 state에 따라서 DOM을 업데이트 할 때 사용</li>
</ul>
<p><br></p>
<h1 id="Unmounting"><a href="#Unmounting" class="headerlink" title="Unmounting"></a>Unmounting</h1><hr>
<p><br></p>
<h2 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h2><hr>
<p><strong>컴포넌트가 소멸된 시점에(DOM에서 삭제된 후) 실행되는 API이다.</strong><br>컴포넌트 내부에서 타이머나 비동기 API를 사용하고 있을 때, 이를 제거하기에 유용하다.</p>
<p>사용 이유</p>
<ul>
<li>등록했었던 이벤트 제거</li>
<li>컴포넌트 내부에서 타이머나 비동기 API를 사용하고 있을 때, 이를 제거하기에 유용하다.</li>
<li>setTimeout 함수를 사용했다면, clearTimeout을 통하여 제거</li>
</ul>
<p><br></p>
<h1 id="React-v16-3-이후에-변경된-부분"><a href="#React-v16-3-이후에-변경된-부분" class="headerlink" title="React v16.3 이후에 변경된 부분"></a>React v16.3 이후에 변경된 부분</h1><hr>
<p>몇개 lifecycle API가 변경된 부분이 있다. 아래의 링크에서 확인해보자.</p>
<p>출처: <a href="https://velog.io/@kyusung/%EB%A6%AC%EC%95%A1%ED%8A%B8-%EA%B5%90%EA%B3%BC%EC%84%9C-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%99%80-%EB%9D%BC%EC%9D%B4%ED%94%84%EC%82%AC%EC%9D%B4%ED%81%B4-%EC%9D%B4%EB%B2%A4%ED%8A%B8" target="_blank" rel="noopener">React v16.3 이후의 lifecycle</a></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/React/">React</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Lifecycle-API/">Lifecycle API</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/">React</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-modules"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/01/02/modules/">Modules</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/01/02/modules/" class="article-date">
	  <time datetime="2019-01-01T15:05:11.000Z" itemprop="datePublished">January 2, 2019</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/ES6/">ES6</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Module이란-무엇인가"><a href="#Module이란-무엇인가" class="headerlink" title="Module이란 무엇인가?"></a>Module이란 무엇인가?</h1><hr>
<p>모듈이란, 애플리케이션을 구성하는 개별적 요소로서, 재사용이 가능한 코드 조각을 말한다.</p>
<p>모듈은 세부 사항을 캡슐화하고, 공개가 필요한 API만을 외부에 노출한다. 일반적으로, 각 모듈은 파일 단위로 분리되어 있고, 애플리케이션은 필요에 따라 모듈을 로드하여 재사용한다. 즉, 모듈은 애플리케이션에 분리되어 개별적으로 존재하다가 애플리케이션의 로드에 의해 비로소 애플리케이션의 로드에 의해 비로소 애플리케이션의 일원이 된다.</p>
<p>모듈은 기능별로 분리되어 작성되므로, 코드의 단위를 명확히 분리하여 애플리케이션을 구성할 수 있고, 재사용에 좋기 때문에, 개발을 효율적으로 할 수 있고, 유지보수 또한 좋다.</p>
<p>ES6에서 모듈을 사용할 때, export와 import 두 개의 키워드를 사용한다.</p>
<p><br></p>
<h1 id="Module-사용의-이점"><a href="#Module-사용의-이점" class="headerlink" title="Module 사용의 이점"></a>Module 사용의 이점</h1><hr>
<ul>
<li>Javascript 애플리케이션을 여러 개의 파일로 분할하여 작성할 수 있다.</li>
<li>재사용이 가능한 코드를 작성하기 때문에, 개발 효율과 유지보수에 좋다.</li>
</ul>
<p><br></p>
<h1 id="Export"><a href="#Export" class="headerlink" title="Export"></a>Export</h1><hr>
<p>모듈은 기본적으로 독립적인 스코프를 가지고 있어서, 모듈안에 선언된 모든 것들은 해당 모듈 내에서만 참조 할 수 있다.</p>
<p>어떤 모듈안에서 선언한 항목(변수/함수/클래스 등)을 외부에 공개하여 다른 모듈들이 사용할 수 있게 하려면, export를 해야한다. 이때, 선언된 변수, 함수, 그리고 클래스 모두를 export 할 수 있고, 키워드는 export를 사용한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// module.js</span><br><span class="line">// 변수의 공개</span><br><span class="line">export const num = 10;</span><br><span class="line"></span><br><span class="line">// 함수의 공개</span><br><span class="line">export function square(x) &#123;</span><br><span class="line">  return x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 클래스의 공개</span><br><span class="line">export class Person &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>각 선언문(변수/함수/클래스) 앞에 export를 붙이는 대신, export 대상을 하나의 객체로 구성하여, 한번에 export를 할 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// module.js</span><br><span class="line">const num = 10;</span><br><span class="line"></span><br><span class="line">function square(x) &#123;</span><br><span class="line">  return x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 변수, 함수 클래스를 하나의 객체로 구성하여 공개</span><br><span class="line">export &#123; num, square, Person &#125;;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h1 id="Import"><a href="#Import" class="headerlink" title="Import"></a>Import</h1><hr>
<p>다른 모듈에서 어떤 export된 모듈을 가져와 사용하려면, 키워드 import를 사용해 로드하여 사용할 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line">// 같은 폴더 내의 module.js 모듈을 로드. 확장자 js는 생략 가능.</span><br><span class="line">import &#123; num, square, Person &#125; from &apos;./module&apos;;</span><br><span class="line"></span><br><span class="line">console.log(num);         // 10</span><br><span class="line">console.log(square(10)); // 100</span><br><span class="line">console.log(new Person(&apos;Lee&apos;)); // Person &#123; name: &apos;Lee&apos; &#125;</span><br></pre></td></tr></table></figure></p>
<p>각각의 이름을 지정하지 않고 하나의 이름으로 한꺼번에 import할 수도 있다. 이때 import되는 항목은 as 뒤에 지정한 이름의 변수에 할당된다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line">// lib라는 이름으로 임포트</span><br><span class="line">import * as lib from &apos;./module&apos;;</span><br><span class="line"></span><br><span class="line">console.log(module.num);         // 10</span><br><span class="line">console.log(module.square(10)); // 100</span><br><span class="line">console.log(new module.Person(&apos;Lee&apos;)); // Person &#123; name: &apos;Lee&apos; &#125;</span><br></pre></td></tr></table></figure></p>
<p>이름을 변경하여 import할 수도 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line">import &#123; num as n, square as sq, Person as P &#125; from &apos;./module&apos;;</span><br><span class="line"></span><br><span class="line">console.log(n);    // 10</span><br><span class="line">console.log(sq(2)); // 4</span><br><span class="line">console.log(new P(&apos;Kim&apos;)); // Person &#123; name: &apos;Kim&apos; &#125;</span><br></pre></td></tr></table></figure></p>
<p>모듈에서 하나만을 export할 때는 default 키워드를 사용할 수 있다. 다만, default를 사용하는 경우, var, let, const는 사용할 수 없다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// lib.js</span><br><span class="line">function (x) &#123;</span><br><span class="line">  return x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default;</span><br></pre></td></tr></table></figure></p>
<p>위 코드를 아래와 같이 축약 표현할 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// module.js</span><br><span class="line">export default function (x) &#123;</span><br><span class="line">  return x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>default 키워드와 함께 export한 모듈은 {} 없이 임의의 이름으로 import한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line">import square from &apos;./module&apos;;</span><br><span class="line"></span><br><span class="line">console.log(square(3)); // 9</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h1 id="Vue에서의-Modules-사용하는-방법"><a href="#Vue에서의-Modules-사용하는-방법" class="headerlink" title="Vue에서의 Modules 사용하는 방법"></a>Vue에서의 Modules 사용하는 방법</h1><hr>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/ES6/">ES6</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Modules/">Modules</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-arrow-function"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/01/01/arrow-function/">Arrow Function</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/01/01/arrow-function/" class="article-date">
	  <time datetime="2019-01-01T13:41:36.000Z" itemprop="datePublished">January 1, 2019</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/ES6/">ES6</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="화살표-함수-Arrow-Function-란-무엇인가"><a href="#화살표-함수-Arrow-Function-란-무엇인가" class="headerlink" title="화살표 함수(Arrow Function)란 무엇인가?"></a>화살표 함수(Arrow Function)란 무엇인가?</h1><hr>
<p>화살표 함수는 기존의 function 키워드 대신 화살표(=&gt;)를 사용하여, 보다 간단히 함수를 선언하는 방식이다. 문법은 다음과 같다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 매개변수 지정 방법</span><br><span class="line">    () =&gt; &#123; ... &#125; // 매개변수가 없을 경우</span><br><span class="line">     x =&gt; &#123; ... &#125; // 매개변수가 한 개인 경우, 소괄호를 생략할 수 있다.</span><br><span class="line">(x, y) =&gt; &#123; ... &#125; // 매개변수가 여러 개인 경우, 소괄호를 생략할 수 없다.</span><br><span class="line"></span><br><span class="line">// 함수 몸체 지정 방법</span><br><span class="line">x =&gt; &#123; return x * x &#125;  // single line block</span><br><span class="line">x =&gt; x * x             // 함수 몸체가 한줄의 구문이라면 중괄호를 생략할 수 있으며 암묵적으로 return된다. 위 표현과 동일하다.</span><br><span class="line"></span><br><span class="line">() =&gt; &#123; return &#123; a: 100 &#125;; &#125;</span><br><span class="line">() =&gt; (&#123; a: 100 &#125;)  // 위 표현과 동일하다. 객체는 반환할 때, 소괄호를 사용한다.</span><br><span class="line"></span><br><span class="line">() =&gt; &#123;           // multi line block.</span><br><span class="line">  const x = 100;</span><br><span class="line">  return x * x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h1 id="화살표-함수의-호출"><a href="#화살표-함수의-호출" class="headerlink" title="화살표 함수의 호출"></a>화살표 함수의 호출</h1><hr>
<p><strong>화살표 함수는 익명 함수로만 사용할 수 있기 때문에, 화살표 함수를 호출하기 위해서는 함수 표현식을 사용해야 한다.</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// ES5</span><br><span class="line">var pow = function (x) &#123; return x * x; &#125;;</span><br><span class="line">console.log(pow(5)); // 25</span><br><span class="line"></span><br><span class="line">// ES6</span><br><span class="line">const pow = x =&gt; x * x;</span><br><span class="line">console.log(pow(5)); // 25</span><br></pre></td></tr></table></figure></p>
<p>콜백함수에서도 화살표 함수를 사용할 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// ES5</span><br><span class="line">var arr = [2, 4, 6];</span><br><span class="line">var pow = arr.map(function (x) &#123; // x는 요소값</span><br><span class="line">  return x * x;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(pow); // [ 4, 16, 36 ]</span><br><span class="line"></span><br><span class="line">// ES6</span><br><span class="line">const arr = [2, 4, 6];</span><br><span class="line">const pow = arr.map(x =&gt; x * x);</span><br><span class="line"></span><br><span class="line">console.log(pow); // [ 4, 16, 36 ]</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h1 id="화살표-함수와-function으로-생성한-함수의-차이점"><a href="#화살표-함수와-function으로-생성한-함수의-차이점" class="headerlink" title="화살표 함수와 function으로 생성한 함수의 차이점"></a>화살표 함수와 function으로 생성한 함수의 차이점</h1><hr>
<p><strong>두 방식의 가장 큰 차이점은 this 이다.</strong></p>
<ul>
<li><strong>function 함수</strong>: 생성자 함수와 객체의 메소드를 제외한 모든 함수(내부 함수, 콜백 함수 포함) 내부의 this는 전역 객체를 가리킨다.</li>
<li><strong>화살표 함수</strong>: 언제나 상위 스코프의 this를 가리킨다.</li>
</ul>
<p><br></p>
<h2 id="function-키워드로-생성한-함수의-this"><a href="#function-키워드로-생성한-함수의-this" class="headerlink" title="function 키워드로 생성한 함수의 this"></a>function 키워드로 생성한 함수의 this</h2><hr>
<p>Javascirpt에서의 this는 함수를 호출할 때 함수가 어떻게 호출되었는지에 따라 this에 바인딩할 객체가 동적으로 결정된다. <a href="https://cheonmro.github.io/2018/11/01/what-is-this/">Javascript에서의 this</a>를 참고한다.</p>
<p><strong>생성자 함수와 객체의 메소드를 제외한 모든 함수(내부 함수, 콜백 함수 포함) 내부의 this는 전역 객체를 가리키기 때문이다. 즉, 콜백 함수 내부의 this는 전역 객체 window를 가리킨다.</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Prefixer(prefix) &#123;</span><br><span class="line">  this.prefix = prefix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Prefixer.prototype.prefixArray = function (arr) &#123;</span><br><span class="line">  // (1)</span><br><span class="line">  return arr.map(function (x) &#123;</span><br><span class="line">    return this.prefix + &apos; &apos; + x; // (2)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var pre = new Prefixer(&apos;Hi&apos;);</span><br><span class="line">console.log(pre.prefixArray([&apos;Ro&apos;, &apos;Park&apos;]));</span><br></pre></td></tr></table></figure></p>
<p>위치에 따라 this의 값은 달라진다.</p>
<ul>
<li>(1): 여기서, this는 생성자 함수 Prefixer가 생성한 객체, 즉 생성자 함수의 인스턴스(위 예제의 경우 pre)이다.</li>
<li>(2): 여기서, this는 전역 객체 window를 가리킨다.</li>
</ul>
<p>콜백 함수 내부의 this가 메소드를 호출한 객체(생성자 함수의 인스턴스)를 가리키게 하는 3가지 방법이 있다.</p>
<ol>
<li>that = this</li>
<li>map(func, this)</li>
<li>bind(this)</li>
</ol>
<ol>
<li><p>that = this</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Prefixer(prefix) &#123;</span><br><span class="line">  this.prefix = prefix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Prefixer.prototype.prefixArray = function (arr) &#123;</span><br><span class="line">  var that = this;  // this: Prefixer 생성자 함수의 인스턴스</span><br><span class="line">  return arr.map(function (x) &#123;</span><br><span class="line">    return that.prefix + &apos; &apos; + x;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var pre = new Prefixer(&apos;Hi&apos;);</span><br><span class="line">console.log(pre.prefixArray([&apos;Lee&apos;, &apos;Kim&apos;]));</span><br></pre></td></tr></table></figure>
</li>
<li><p>map(func, this)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Prefixer(prefix) &#123;</span><br><span class="line">  this.prefix = prefix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Prefixer.prototype.prefixArray = function (arr) &#123;</span><br><span class="line">  return arr.map(function (x) &#123;</span><br><span class="line">    return this.prefix + &apos; &apos; + x;</span><br><span class="line">  &#125;, this); // this: Prefixer 생성자 함수의 인스턴스</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var pre = new Prefixer(&apos;Hi&apos;);</span><br><span class="line">console.log(pre.prefixArray([&apos;Lee&apos;, &apos;Kim&apos;]));</span><br></pre></td></tr></table></figure>
</li>
<li><p>bind(this)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Prefixer(prefix) &#123;</span><br><span class="line">  this.prefix = prefix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Prefixer.prototype.prefixArray = function (arr) &#123;</span><br><span class="line">  return arr.map(function (x) &#123;</span><br><span class="line">    return this.prefix + &apos; &apos; + x;</span><br><span class="line">  &#125;.bind(this)); // this: Prefixer 생성자 함수의 인스턴스</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var pre = new Prefixer(&apos;Hi&apos;);</span><br><span class="line">console.log(pre.prefixArray([&apos;Ro&apos;, &apos;Park&apos;]));</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><br></p>
<h2 id="화살표-함수의-this"><a href="#화살표-함수의-this" class="headerlink" title="화살표 함수의 this"></a>화살표 함수의 this</h2><hr>
<p><strong>화살표 함수의 this는 언제나 상위 스코프의 this를 가리킨다.</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Prefixer(prefix) &#123;</span><br><span class="line">  this.prefix = prefix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Prefixer.prototype.prefixArray = function (arr) &#123;</span><br><span class="line">  // this는 상위 스코프인 prefixArray 메소드 내의 this를 가리킨다.</span><br><span class="line">  return arr.map(x =&gt; `$&#123;this.prefix&#125;  $&#123;x&#125;`);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const pre = new Prefixer(&apos;Hi&apos;);</span><br><span class="line">console.log(pre.prefixArray([&apos;Ro&apos;, &apos;Park&apos;]));</span><br></pre></td></tr></table></figure></p>
<p>화살표 함수는 call, applay, bind 메소드를 사용하여 this를 변경할 수 없다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">window.x = 1;</span><br><span class="line">const normal = function () &#123; return this.x; &#125;;</span><br><span class="line">const arrow = () =&gt; this.x;</span><br><span class="line"></span><br><span class="line">console.log(normal.call(&#123; x: 10 &#125;)); // 10</span><br><span class="line">console.log(arrow.call(&#123; x: 10 &#125;));  // 1</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h1 id="화살표-함수를-사용하면-안되는-경우"><a href="#화살표-함수를-사용하면-안되는-경우" class="headerlink" title="화살표 함수를 사용하면 안되는 경우"></a>화살표 함수를 사용하면 안되는 경우</h1><hr>
<p>화살표 함수는 Lexical this를 지원하므로 콜백 함수로 사용하기 편리하지만, 화살표 함수를 사용하지 말아야 하는 경우도 있다.</p>
<h2 id="메소드"><a href="#메소드" class="headerlink" title=" 메소드"></a><1> 메소드</1></h2><hr>
<p>메소드를 정의할 때는, 화살표 함수를 사용하면 안된다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">  name: &apos;Ro&apos;,</span><br><span class="line">  sayHi: () =&gt; console.log(`Hi $&#123;this.name&#125;`)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.sayHi(); // Hi undefined</span><br></pre></td></tr></table></figure></p>
<p>위와 같이, sayHi라는 메소드를 정의할 때 화살표 함수를 사용하게 되면, 화살표 함수 내부의 this는 상위 컨택스트인 전역 객체 window를 가리킨다.</p>
<p>ES6의 축약 메소드 표현을 사용하면, 다음과 같이 작성할 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">  name: &apos;Ro&apos;,</span><br><span class="line">  sayHi() &#123; // === sayHi: function() &#123;</span><br><span class="line">    console.log(`Hi $&#123;this.name&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.sayHi(); // Hi Ro</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="prototype"><a href="#prototype" class="headerlink" title=" prototype"></a><2> prototype</2></h2><hr>
<p>prototype에 할당하기 위한 메소드를 정의할 때는, 화살표 함수를 사용하면 안된다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">  name: &apos;Ro&apos;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.prototype.sayHi = () =&gt; console.log(`Hi $&#123;this.name&#125;`);</span><br><span class="line"></span><br><span class="line">person.sayHi(); // Hi undefined</span><br></pre></td></tr></table></figure></p>
<p>prototype에 메소드를 할당하는 경우, 일반 함수를 사용해야 한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">  name: &apos;Ro&apos;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.prototype.sayHi = function() &#123;</span><br><span class="line">  console.log(`Hi $&#123;this.name&#125;`);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.sayHi(); // Hi Ro</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="생성자-함수"><a href="#생성자-함수" class="headerlink" title=" 생성자 함수"></a><3> 생성자 함수</3></h2><hr>
<p>생성자 함수를 사용할 때는, 화살표 함수를 사용하면 안된다. 생성자 함수는 prototype 프로퍼티를 가지며 prototype 프로퍼티가 가리키는 프로토타입 객체의 constructor를 사용한다. 그러나, 화살표 함수는 prototype 프로퍼티를 가지고 있지 않다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const Foo = () =&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// 화살표 함수는 prototype 프로퍼티가 없다</span><br><span class="line">console.log(Foo.hasOwnProperty(&apos;prototype&apos;)); // false</span><br><span class="line"></span><br><span class="line">const foo = new Foo(); // TypeError: Foo is not a constructor</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="addEventListener-함수의-콜백-함수"><a href="#addEventListener-함수의-콜백-함수" class="headerlink" title=" addEventListener 함수의 콜백 함수"></a><4> addEventListener 함수의 콜백 함수</4></h2><hr>
<p>addEventListener 함수의 콜백 함수를 사용할 때는, 화살표 함수를 사용하면 안된다.</p>
<p>만약, addEventListener 함수의 콜백 함수를 화살표 함수로 정의하면, 화살표 함수 내의 this는 상위 컨택스트인 전역 객체 window를 가리킨다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var button = document.getElementById(&apos;myButton&apos;);</span><br><span class="line"></span><br><span class="line">button.addEventListener(&apos;click&apos;, () =&gt; &#123;</span><br><span class="line">  console.log(this === window); // =&gt; true</span><br><span class="line">  this.innerHTML = &apos;Clicked button&apos;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>그래서, addEventListener 함수의 콜백 함수를 사용할 때는, 일반 함수인 function 키워드를 사용해야 한다. 일반 함수로 정의된 addEventListener 함수의 콜백 함수 내부의 this는 이벤트 리스너에 바인딩된 요소(currentTarget)를 가리킨다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var button = document.getElementById(&apos;myButton&apos;);</span><br><span class="line"></span><br><span class="line">button.addEventListener(&apos;click&apos;, function() &#123;</span><br><span class="line">  console.log(this === button); // =&gt; true</span><br><span class="line">  this.innerHTML = &apos;Clicked button&apos;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h1 id="Vue에서-화살표-함수-사용방법"><a href="#Vue에서-화살표-함수-사용방법" class="headerlink" title="Vue에서 화살표 함수 사용방법"></a>Vue에서 화살표 함수 사용방법</h1><hr>
<p>Vue에서 화살표 함수는 기본적으로 ES6에서의 화살표 함수와 동일하다.</p>
<p>화살표 함수의 사용 여부에 대한 대표적인 경우는 2가지이다.</p>
<ul>
<li>메소드를 정의할 때</li>
<li>콜백함수를 정의할 때</li>
</ul>
<p><br></p>
<h2 id="Vue에서-메소드를-정의할-때"><a href="#Vue에서-메소드를-정의할-때" class="headerlink" title="Vue에서 메소드를 정의할 때"></a>Vue에서 메소드를 정의할 때</h2><hr>
<p>Vue에서 메소드를 정의할 때는, 화살표 함수를 사용하면 안된다. 즉, function 키워드를 사용하는 일반 함수로 정의해야 한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot; v-model=&quot;newTodo&quot;&gt;</span><br><span class="line">      &lt;button v-on:click=&quot;addTodo&quot;&gt;add&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data: () =&gt; (&#123;</span><br><span class="line">        newTodo: &apos;&apos;</span><br><span class="line">    &#125;),</span><br><span class="line">    methods: &#123;</span><br><span class="line">        addTodo: function () &#123;</span><br><span class="line">            console.log(this.newTodo); // input에서 입력한 값을 가져옴</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>methods에서 <code>addTodo</code>를 정의할 때, function 키워드를 사용하면, 이 함수내의 this는 Vue 인스턴스를 가리킨다. 그래서, <code>this.newTodo</code>의 값을 가져올 수 있다.</p>
<p>만약, 화살표 함수로 <code>addTodo</code>를 정의하면 어떻게 될까?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot; v-model=&quot;newTodo&quot;&gt;</span><br><span class="line">      &lt;button v-on:click=&quot;addTodo&quot;&gt;add&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data: () =&gt; (&#123;</span><br><span class="line">        newTodo: &apos;&apos;</span><br><span class="line">    &#125;),</span><br><span class="line">    methods: &#123;</span><br><span class="line">        addTodo: () =&gt; &#123;</span><br><span class="line">            console.log(this.newTodo); // undefined</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>화살표 함수로 <code>addTodo</code>를 정의하면, 이 함수내의 this는 전역객체 window를 가리킨다. 그래서 값이 <code>undefined</code>가 된다.</p>
<p>대신, ES6의 축약 메소드 표현을 사용하면, 다음과 같이 작성할 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    addTodo () &#123;</span><br><span class="line">        console.log(this.newTodoItem) // input에서 입력한 값을 가져옴</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="Vue에서-콜백-함수를-정의할-때"><a href="#Vue에서-콜백-함수를-정의할-때" class="headerlink" title="Vue에서 콜백 함수를 정의할 때"></a>Vue에서 콜백 함수를 정의할 때</h2><hr>
<p>Vue에서 콜백 함수를 정의할 때, 화살표 함수를 사용하면, 정의된 콜백 함수내의 this는 Vue의 인스턴스를 가리킨다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line"></span><br><span class="line">  data: &#123;</span><br><span class="line">    size: &apos;small&apos;,</span><br><span class="line">    items: [ &#123; size: &apos;small&apos; &#125;, &#123; size: &apos;large&apos; &#125; ]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  computed: &#123;</span><br><span class="line">    filterBySize() &#123;</span><br><span class="line">      return this.items.filter((item) =&gt; &#123;</span><br><span class="line">        return item.size === this.size; // this는 Vue의 인스턴스를 가리킴</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>만약, 콜백 함수를 정의할 때, function 키워드를 사용하면, 정의된 콜백 함수내의 this는 상위 컨택스트, 즉 전역 객체 window를 가리킨다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line"></span><br><span class="line">  data: &#123;</span><br><span class="line">    size: &apos;small&apos;,</span><br><span class="line">    items: [ &#123; size: &apos;small&apos; &#125;, &#123; size: &apos;large&apos; &#125; ]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  computed: &#123;</span><br><span class="line">    filterBySize() &#123;</span><br><span class="line">      let size = this.size // 여기서 this는 Vue 인스턴스를 가리키기 때문에, 미리 size라는 변수에 위 data의 size의 값을 할당</span><br><span class="line">      return this.items.filter(function(item) &#123;</span><br><span class="line">        return item.size === size;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h1 id="결론-Vue에서의-화살표-함수-및-일반-함수-사용-방법"><a href="#결론-Vue에서의-화살표-함수-및-일반-함수-사용-방법" class="headerlink" title="결론: Vue에서의 화살표 함수 및 일반 함수 사용 방법"></a>결론: Vue에서의 화살표 함수 및 일반 함수 사용 방법</h1><hr>
<ul>
<li><strong>메소드를 정의할 때는, 일반 함수를 사용한다.</strong> 이때, funtion 키워드르 안쓰고 싶다면, ES6의 축약 메소드 표현을 사용해서, 간단히 작성하면 된다.</li>
<li><strong>콜백 함수를 정의할 때는, 화살표 함수를 사용한다.</strong> 이때, 정의된 콜백 함수내의 this는 해당 컨택스트, 즉 정의된 콜백 함수를 가지고 있는 Vue 인스턴스를 가리킨다.</li>
</ul>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/ES6/">ES6</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Arrow-Function/">Arrow Function</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-computed-methods"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/01/01/computed-methods/">Computed vs. Methods vs. Watch</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/01/01/computed-methods/" class="article-date">
	  <time datetime="2019-01-01T11:26:03.000Z" itemprop="datePublished">January 1, 2019</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Vue/">Vue</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Computed-vs-Methods"><a href="#Computed-vs-Methods" class="headerlink" title="Computed vs. Methods"></a>Computed vs. Methods</h1><hr>
<p><strong>핵심은 캐싱(값의 저장)이 있냐 없냐에 차이다.</strong></p>
<p><strong>공통점</strong>: <strong>둘 다 인스턴내에서 함수를 정의하는 부분이고, 데이터가 변동됨에 따라 안에 있는 함수를 재호출하게 된다.</strong><br><strong>차이점</strong>: <strong>데이터가 변동되지 않는다고 가정했을 때이다.</strong></p>
<ul>
<li><strong>Computed: 종속 대상의 값이 저장(캐싱) 되어, 이미 계산되어진 값을 가져온다.</strong><ul>
<li>종속된 대상이 변경될 때만, 함수를 실행하고, 종속 대상이 변경되지 않으면, computed를 여러번 요청해도 계산을 다시 하지 않고, 계산되어 있는(computed) 결과를 즉시 반환한다.</li>
<li>데이터 변동이 없는 상태에서, 이전의 계산된 값을 캐시해 두었다가 함수 호출시 재사용한다.</li>
</ul>
</li>
<li><strong>methods: 렌더링을 다시 할때마다, 항상 함수를 실행하여 함수의 로직에 결과물을 반환한다.</strong><ul>
<li>사용할때마다, 함수의 계산을 다시 한다.</li>
</ul>
</li>
</ul>
<p><br></p>
<h2 id="캐싱이-왜-필요할까"><a href="#캐싱이-왜-필요할까" class="headerlink" title="캐싱이 왜 필요할까?"></a>캐싱이 왜 필요할까?</h2><hr>
<p>computed의 속성이 계산이 많이 걸리는 함수라고 하자. 만약, 캐싱을 하지 않으면, computed의 속성의 getter 함수를 꼭 필요한 것보다 더 많이 실행하게 된다. 그래서, 캐싱을 원하지 않으면, methods를 사용한다.</p>
<p><br></p>
<h1 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h1><hr>
<ul>
<li><strong>데이터가 자주 변동되지 않으면, 비용적인 면에서는 computed가 좋다.</strong></li>
<li><strong>데이터가 수시로 없데이트 되면, 계속해서 캐시를 저장하는 computed보다 methods가 더 좋다.</strong></li>
</ul>
<p>그래서, html에서는 computed는 변수처럼 쓰이고, methods는 함수처럼 쓰인다.<br>예) parse 함수</p>
<ul>
<li>Computed: parse를 그대로 사용한다.</li>
<li>Methods: parse() 이런식으로 사용한다.</li>
</ul>
<p><br></p>
<h1 id="Computed-vs-Watch"><a href="#Computed-vs-Watch" class="headerlink" title="Computed vs. Watch"></a>Computed vs. Watch</h1><hr>
<ul>
<li>Watch: 감시할 데이터를 지정하고 그 데이터가 바뀌면 이런 함수를 실행하라는 방식으로 소프트웨어 공학에서 이야기하는 ‘명령형 프로그래밍’ 방식</li>
<li>Computed: 계산해야 하는 목표 데이터를 정의하는 방식으로 소프트웨어 공학에서 이야기하는 ‘선언형 프로그래밍’ 방식</li>
</ul>
<p><br></p>
<h1 id="Computed-Watch는-언제-왜-사용해야-할까"><a href="#Computed-Watch는-언제-왜-사용해야-할까" class="headerlink" title="Computed/Watch는 언제, 왜 사용해야 할까?"></a>Computed/Watch는 언제, 왜 사용해야 할까?</h1><hr>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Vue/">Vue</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Computed/">Computed</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Methods/">Methods</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue/">Vue</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-vue-routing"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/01/01/vue-routing/">Vue에서 Routing 사용하는 방법</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/01/01/vue-routing/" class="article-date">
	  <time datetime="2019-01-01T10:37:12.000Z" itemprop="datePublished">January 1, 2019</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Vue/">Vue</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Routing-라우팅-이란-무엇인가"><a href="#Routing-라우팅-이란-무엇인가" class="headerlink" title="Routing(라우팅)이란 무엇인가?"></a>Routing(라우팅)이란 무엇인가?</h1><hr>
<p><strong>라우팅</strong>이란, <strong>웹 페이지간의 이동 방법을 말하며, 웹 앱의 형식 중 하나인 SPA에서 주로 사용한다.</strong></p>
<p>라우팅의 장점은 화면 간의 전환이 매끄러워, UX를 향상 시킬 수 있다.</p>
<p>일반적인 웹(MPA)에서는 특정 행동(링크 클릭, 또는 특정 이벤트)를 한 후, 페이지를 이동하게 되면, 흰색의 빈 페이지가 깜박거린 후, 이동된 화면이 나타나게 된다. 이런 부분들을 라우팅으로 처리하면 깜빡러미 없이 매끄럽게 화면이 전환될 수 있다.</p>
<p><br></p>
<h1 id="Vue에서의-라우팅"><a href="#Vue에서의-라우팅" class="headerlink" title="Vue에서의 라우팅"></a>Vue에서의 라우팅</h1><hr>
<p>Vue 라우터는 Vue에서 라우팅을 할 수 있도록 지원하는 공식 라이브러리이다.</p>
<p><br></p>
<h2 id="Vue에서-라우팅-설치-및-등록"><a href="#Vue에서-라우팅-설치-및-등록" class="headerlink" title="Vue에서 라우팅 설치 및 등록"></a>Vue에서 라우팅 설치 및 등록</h2><hr>
<p>&lt;설치&gt;</p>
<p><code>Npm install vue-router</code></p>
<p>&lt;등록&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Import VueRouter from ‘vue-router’</span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter)</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="기본적인-Vue-Routing-사용법"><a href="#기본적인-Vue-Routing-사용법" class="headerlink" title="기본적인 Vue Routing 사용법"></a>기본적인 Vue Routing 사용법</h2><hr>
<p>Vue 라우터 라이브러리를 사용하면, 2개의 tag를 사용한다.</p>
<ul>
<li><code>&lt;router-link to=“url&quot;&gt;</code>: 페이지 이동 태그로, 화면에서는 <code>&lt;a&gt;</code>로 표시되며 클릭하게되면, to속성에 입력한 URL로 이동</li>
<li><code>&lt;router-view&gt;</code>: 페이지 표시 태그로, 변경되는 URL에 따라 해당 컴포넌트를 출력해주는 영역</li>
</ul>
<p>기본적인 라우팅을 만들어보자. 위에 버튼 두개가 있는데, 왼쪽은 todo 페이지로 이동, 오른쪽은 user 페이지로 이동하는 라우팅을 만들어 보자.</p>
<p><strong>(1) vue-router를 설치하고, router.js를 만들어 다음과 같이 작성한다.</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// router.js</span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import VueRouter from &apos;vue-router&apos;</span><br><span class="line">import Todo from &apos;./components/Todo.vue&apos;</span><br><span class="line">import User from &apos;./components/User.vue&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">    mode: &apos;history&apos;,</span><br><span class="line">    routes: [</span><br><span class="line">      &#123; path: &apos;/&apos;, component: Todo &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path: &apos;/user&apos;,</span><br><span class="line">            component: User,</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>Todo와 User 컴포넌트를 만들고, import 한뒤, router 인스턴스를 생성하고, path와 path에 맞는 컴포넌트를 맵핑한다.</p>
<p>‘History’ mode는 기본적으로 url에 #이 들어가 있는데, 이를 제거해 준다.</p>
<p><strong>(2) main.js에 등록하여, 전역에서 사용할 수 있게 한다.</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import App from &apos;./App.vue&apos;</span><br><span class="line">import store from &apos;./store&apos;</span><br><span class="line">import router from &apos;./router&apos;</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = false</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  store,</span><br><span class="line">  router,</span><br><span class="line">  render: h =&gt; h(App),</span><br><span class="line">&#125;).$mount(&apos;#app&apos;)</span><br></pre></td></tr></table></figure></p>
<p><strong>(3) App.vue에 라우터 링크를 추가한다.</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// App.vue</span><br><span class="line">&lt;section&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;router-link to=&quot;/&quot;&gt;&lt;button&gt;Go to Todo page&lt;/button&gt;&lt;/router-link&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;router-link to=&quot;/user&quot;&gt;&lt;button&gt;Go to User page&lt;/button&gt;&lt;/router-link&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/section&gt;</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure></p>
<p>이렇게 되면, 각 버튼을 클릭하면, 각 버튼에 해당하는 path로 이동하여, path에 맵핑된 컴포넌트를 화면에 뿌려준다.</p>
<p><br></p>
<h2 id="Nested-라우팅"><a href="#Nested-라우팅" class="headerlink" title="Nested 라우팅"></a>Nested 라우팅</h2><hr>
<p><strong>Nested(중첩된) 라우터는 라우터로 페이지를 이동할 때, 최소 2개 이상의 컴포넌트를 화면에 나타내는 것을 말한다.<br>상위 컴포넌트 1개와 하위 컴포넌트 N개로 구성할 수 있다.</strong></p>
<p>예를 들어, User 페이지에서 url에 따라, User의 Profile과 User의 Post를 각각 보여주는 라우터를 만들어보자.</p>
<p><strong>(1) 두 개의 컴포넌트 UserProfile과 UserPost를 만들고, 상위 컴포넌트인 User에 그 하위 컴포넌트로 UserProfile과 UserPost를 라우팅으로 등록한다.</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// router.js</span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import VueRouter from &apos;vue-router&apos;</span><br><span class="line">import Todo from &apos;./components/Todo.vue&apos;</span><br><span class="line">import User from &apos;./components/User.vue&apos;</span><br><span class="line">import UserProfile from &apos;./components/UserProfile.vue&apos;</span><br><span class="line">import UserPost from &apos;./components/UserPost.vue&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">    mode: &apos;history&apos;,</span><br><span class="line">    routes: [</span><br><span class="line">      &#123; path: &apos;/&apos;, component: Todo &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path: &apos;/user&apos;,</span><br><span class="line">            component: User,</span><br><span class="line">            children: [</span><br><span class="line">                &#123;</span><br><span class="line">                    path: &apos;userProfile&apos;,</span><br><span class="line">                    component: UserProfile</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    path: &apos;userPost&apos;,</span><br><span class="line">                    component: UserPost</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><strong>(2) 상위 컴포넌트인 User.vue에 다음과 같이 링크를 추가한다. 이때, 상위 컴포넌트에 <code>&lt;router-view&gt;&lt;/router-view&gt;</code>를 추가하여, 상위 컴포넌트내에서 그 하위 컴포넌트들이 화면에 보이게 한다.</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// User.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;user&quot;&gt;</span><br><span class="line">        &lt;p&gt;This is User page.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">        &lt;br&gt;</span><br><span class="line"></span><br><span class="line">        &lt;router-link to=&quot;/user/userProfile&quot;&gt;UserProfile 컴포넌트로 이동&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">        &lt;br&gt;</span><br><span class="line"></span><br><span class="line">        &lt;router-link to=&quot;/user/UserPost&quot;&gt;UserPost 컴포넌트로 이동&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">        &lt;br&gt;</span><br><span class="line"></span><br><span class="line">        &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="동적-라우팅"><a href="#동적-라우팅" class="headerlink" title="동적 라우팅"></a>동적 라우팅</h2><hr>
<p><strong>동적 라우팅</strong>이란, <strong>일정한 패턴의 URI 경로를 하나의 컴포넌트에 연결하는 방법이다. 일정한 패턴의 URI란, 예를 들어, projects 페이지에서 각 페이지별로 상세하게 보고 싶은데, 이때 URI를 projects/1, projects/2 이런식으로 각 프로젝트를 id로 구별하는 것을 말한다. 이를 하나의 컴포넌트(Projects.vue)로 연결하여 사용한다.</strong></p>
<p>하나의 메인 페이지에서 어떤 링크(버튼 등)를 클릭하면, projects 페이지가 나오고, 그 projects 페이지에는 여러개의 프로젝트들이 보여진다. 그리고, 각 프로젝트를 클릭하면, 각 프로젝트에 대한 상세 정보가 나오게 한다. 이때, 클릭 시 라우팅의 URI는 projects/1 이런식으로 지정하여 만든다.</p>
<p><strong>(1) 우선, store.js에서 dummy 데이터를 만들자.</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// store.js</span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import Vuex from &apos;vuex&apos;</span><br><span class="line">import axios from &apos;axios&apos;</span><br><span class="line">import VueAxios from &apos;vue-axios&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex);</span><br><span class="line">Vue.use(VueAxios, axios);</span><br><span class="line"></span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        projects: [</span><br><span class="line">            &#123;</span><br><span class="line">                id: 1,</span><br><span class="line">                text: &apos;vue&apos;,</span><br><span class="line">                completed: false</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                id: 2,</span><br><span class="line">                text: &apos;react&apos;,</span><br><span class="line">                completed: false</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    actions: &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><strong>(2) router.js에서 Projects에 대한 path를 등록하고, 이에 대한 children으로써, Project에 대한 path를 등록한다. 이때, path는 ‘:id’로 등록한다.</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// router.js</span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import VueRouter from &apos;vue-router&apos;</span><br><span class="line">import Projects from &apos;./components/Projects.vue&apos;</span><br><span class="line">import Project from &apos;./components/Project.vue&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">    mode: &apos;history&apos;,</span><br><span class="line">    routes: [</span><br><span class="line">        &#123;</span><br><span class="line">            path: &apos;/projects&apos;,</span><br><span class="line">            component: Projects,</span><br><span class="line">            children: [</span><br><span class="line">                &#123;</span><br><span class="line">                    name: &apos;project&apos;,</span><br><span class="line">                    path: &apos;:id&apos;,</span><br><span class="line">                    component: Project</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export default router</span><br></pre></td></tr></table></figure></p>
<p><strong>(3) App.vue에서 Projects 페이지로 이동하는 라우터 링크를 작성한다. 그리고, 링크 클릭 시, Projects 페이지의 정보를 보여주기 위해, router-view를 아래에 작성한다.</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// App.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;p&gt;This is main page&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">        &lt;router-link to=&quot;/projects&quot;&gt;&lt;button&gt;Go to Project page&lt;/button&gt;&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">      &lt;br&gt;</span><br><span class="line"></span><br><span class="line">      &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>(4) Projects 페이지는 프로젝트가 나열되어 나오게 한다. 그리고, 각 프로젝트에 라우터 링크를 걸어, 그 링크를 클릭시, 클릭한 프로젝트에 대한 상세 정보가 나오는 Project 페이지가 나오게 한다. 이때, router-link에는 name과 params를 같이 넣어 주는데, 이는 router.js에서 등록한 그대로 작성하면 된다.</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// Projects.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;Projects page&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div v-for=&quot;project in projects&quot; :key=&quot;project.id&quot;&gt;</span><br><span class="line">            &lt;router-link :to=&quot;&#123; name: &apos;project&apos;, params: &#123; id: project.id &#125; &#125;&quot;&gt;</span><br><span class="line">                [ID: &#123;&#123;project.id&#125;&#125;] &#123;&#123;project.text&#125;&#125;</span><br><span class="line">            &lt;/router-link&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;br&gt;</span><br><span class="line"></span><br><span class="line">        &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    computed: &#123;</span><br><span class="line">        projects () &#123;</span><br><span class="line">            return this.$store.state.projects</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>(5) 위에서 어떤 하나의 프로젝트를 클릭하면, 그 프로젝트 컴포넌트에서 작성한 화면을 보여준다.(Project.vue). 이때, this.$route.params.id로 id에 접근할 수 있다.</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Project.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;p&gt;Project each view: &#123;&#123; this.$route.params.id &#125;&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export defualt &#123;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="Named-라우팅"><a href="#Named-라우팅" class="headerlink" title="Named 라우팅"></a>Named 라우팅</h2><hr>
<p><strong>Named 라우팅</strong>이란, <strong>각 화면의 영역을 각각 용도, 모듈별로 구분할 수 있는데, 이때, 이름으로 구분하는 것을 말한다.</strong> 일반적인 웹 앱에서는 header, footer, body로 나누어 화면을 구성한다.</p>
<p><strong>(1) App.vue에서 각 화면별로 이름을 지정하여 화면의 영역을 나눈다.</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// App.vue</span><br><span class="line">&lt;router-view name=&quot;header&quot;&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;router-view&gt;&lt;/router-view&gt;&lt;!-- name을 지정하지 않으면, default --&gt;</span><br><span class="line">&lt;router-view name=&quot;footer&quot;&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>(2) 각 화면에 대한 컴포넌트로 만든 뒤, router.js로 import 한다. 그리고, routes에 다음과 같이 지정한다.</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// router.js</span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import VueRouter from &apos;vue-router&apos;</span><br><span class="line">import Body from &apos;./components/Body.vue&apos;</span><br><span class="line">import Header from &apos;./components/Header.vue&apos;</span><br><span class="line">import Footer from &apos;./components/Footer.vue&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">    mode: &apos;history&apos;,</span><br><span class="line">    routes: [</span><br><span class="line">        &#123;</span><br><span class="line">            path: &apos;/&apos;,</span><br><span class="line">            components: &#123;</span><br><span class="line">                default: Body,</span><br><span class="line">                header: Header,</span><br><span class="line">                footer: Footer</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>‘Components’ 속성에 Key(router-view 이름)-Value(컴포넌트)로 등록하면, 컴포넌트에서 <code>&lt;router-view&gt;</code>에 각 컴포넌트의 화면이 보여진다.</p>
<p>이런 컴포넌트 구조는(Header-Body(default)-Footer) 모든 페이지의 기본형식이기 때문에, path를 ‘/‘로 사용하여, 기본페이지로 사용할 수 있다.</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Vue/">Vue</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Routing/">Routing</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue/">Vue</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-axios-and-vue"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/12/27/axios-and-vue/">Vue에서 Axios 사용하는 방법</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/12/27/axios-and-vue/" class="article-date">
	  <time datetime="2018-12-27T12:39:31.000Z" itemprop="datePublished">December 27, 2018</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Vue/">Vue</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Axios란-무엇인가"><a href="#Axios란-무엇인가" class="headerlink" title="Axios란 무엇인가?"></a>Axios란 무엇인가?</h1><hr>
<p><strong>axios란, Pormise 기반의 http 통신을 위한 클라이언트 라이브러리이다.</strong></p>
<p>vue에는 vue-resource라는 것이 있으나, 2016년 9월 이후 업데이트가 되어있지않고, Evan You(Vue 만든사람) 또한, 공식적으로 추천하지 않고, axios 쓰는 것을 추천한다.</p>
<p><br></p>
<h1 id="Axios-설치하기"><a href="#Axios-설치하기" class="headerlink" title="Axios 설치하기"></a>Axios 설치하기</h1><hr>
<p>npm으로 axios를 설치한다.</p>
<p><code>npm install axios vue-axios</code></p>
<p><br></p>
<h1 id="Axios-등록하기"><a href="#Axios-등록하기" class="headerlink" title="Axios 등록하기"></a>Axios 등록하기</h1><hr>
<p><strong>Vue 애플리케이션을 개발할 때, Vuex(store.js)의 actions에서 axios를 사용하므로, store.js에 axios를 등록한다.</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// store.js</span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import Vuex from &apos;vuex&apos;</span><br><span class="line"></span><br><span class="line">// axios &amp; vue-axios를 import</span><br><span class="line">import axios from &apos;axios&apos;</span><br><span class="line">import VueAxios from &apos;vue-axios&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex);</span><br><span class="line">// axios &amp; vue-axios를 등록</span><br><span class="line">Vue.use(VueAxios, axios);</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h1 id="Axios-사용하기"><a href="#Axios-사용하기" class="headerlink" title="Axios 사용하기"></a>Axios 사용하기</h1><hr>
<h2 id="1-JSON-server-만들기"><a href="#1-JSON-server-만들기" class="headerlink" title="1. JSON server 만들기"></a>1. JSON server 만들기</h2><hr>
<p><strong>가상의 서버에서 데이터를 만들어 사용하기 위해, 프론트엔드 개발자가 직접 JSON server를 구축하여, axios 통신을 테스트할 수 있다.</strong></p>
<p><code>npm install -g json-server</code></p>
<p><br></p>
<h2 id="2-JSON-server-만들기"><a href="#2-JSON-server-만들기" class="headerlink" title="2. JSON server 만들기"></a>2. JSON server 만들기</h2><hr>
<p><strong>JSON server에 가상 데이터를 만들기 위해, db.json 파일을 src 폴더 아래에 만들고, 다음과 같이 데이터를 추가한다.</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// db.json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;todos&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;id&quot;: &quot;1&quot;,</span><br><span class="line">         &quot;text&quot;: &quot;vue&quot;,</span><br><span class="line">         &quot;completed&quot;: false</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">          &quot;id&quot;: &quot;2&quot;,</span><br><span class="line">          &quot;text&quot;: &quot;react&quot;,</span><br><span class="line">          &quot;completed&quot;: false</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">          &quot;id&quot;: &quot;3&quot;,</span><br><span class="line">          &quot;text&quot;: &quot;angular&quot;,</span><br><span class="line">          &quot;completed&quot;: true</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">          &quot;id&quot;: &quot;4&quot;,</span><br><span class="line">          &quot;text&quot;: &quot;python&quot;,</span><br><span class="line">          &quot;completed&quot;: false</span><br><span class="line">      &#125;</span><br><span class="line">       ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="3-JSON-server-띄우기-Running"><a href="#3-JSON-server-띄우기-Running" class="headerlink" title="3. JSON server 띄우기(Running)"></a>3. JSON server 띄우기(Running)</h2><hr>
<p><code>json-server --watch src/db.json --port 4000</code></p>
<p><br></p>
<h2 id="4-Vuex-store-js-의-actions에-메소드-등록하기"><a href="#4-Vuex-store-js-의-actions에-메소드-등록하기" class="headerlink" title="4. Vuex(store.js)의 actions에 메소드 등록하기"></a>4. Vuex(store.js)의 actions에 메소드 등록하기</h2><hr>
<p>actions에 등록하고, 등록할 때, mutations를 commit하여 변경된 상태를 추적가능하게 하면 된다.</p>
<p>서버와 통신을 할 때, CRUD라는 것이 있는데, todo 앱과 비교하면 다음과 같다.</p>
<ul>
<li><strong>Create</strong>: addTodo</li>
<li><strong>Read</strong>: getTodo</li>
<li><strong>Update</strong>: changeTodo(toggle)</li>
<li><strong>Delete</strong>: deleteTodo</li>
</ul>
<p>Vuex(store.js)의 actions에 메소드 등록할 때, 위에 4가지로 나눠서 코드를 작성해보자.</p>
<p><br></p>
<h3 id="Create-addTodo"><a href="#Create-addTodo" class="headerlink" title=". Create: addTodo"></a><1>. Create: addTodo</1></h3><hr>
<p><strong>Create는 클라이언트단에서 데이터를 새로 생성하여, 서버에 추가하는 것이다. todo 앱에서는 addTodo가 된다.</strong></p>
<p>Vuex(store.js)의 actions에 메소드 등록할 때, <strong>axios의 post<strong>를 사용한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// store.js</span><br><span class="line">actions: &#123;</span><br><span class="line">  addTodo: function(context, payload) &#123;</span><br><span class="line">    // post를 사용할 때는, 요청할 uri에 보낼 데이터를 같이 요청한다.</span><br><span class="line">    axios.post(&apos;http://localhost:4000/todos&apos;, &#123;</span><br><span class="line">        id: 4,</span><br><span class="line">        text: payload,</span><br><span class="line">        completed: false</span><br><span class="line">    &#125;)</span><br><span class="line">        // 요청이 성공하면, mutations에 commit을 하여, 원래 데이터에 요청한 데이터를 추가한다.</span><br><span class="line">        .then((res) =&gt; &#123;</span><br><span class="line">            console.log(res);</span><br><span class="line">            context.commit(&apos;addTodo&apos;, res.data)</span><br><span class="line">        &#125;)</span><br><span class="line">        // 요청이 실패하면, 에러에 대한 조치를 취한다.</span><br><span class="line">        .catch((err) =&gt; &#123;</span><br><span class="line">            console.log(err);</span><br><span class="line">        &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></strong></strong></p>
<p>actions에서 commit한 mutations에 로직을 작성한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  addTodo (state, todo) &#123;</span><br><span class="line">    state.todoList = [...state.todoList, todo]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="Read-getTodo"><a href="#Read-getTodo" class="headerlink" title=". Read: getTodo"></a><2>. Read: getTodo</2></h3><hr>
<p><strong>Read는 클라이언트단에서 데이터를 서버에 요청하여, 데이터를 받는 것이다. todo 앱에서는 getTodo가 된다.</strong></p>
<p>Vuex(store.js)의 actions에 메소드 등록할 때, <strong>axios의 get</strong>을 사용한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// store.js</span><br><span class="line">actions: &#123;</span><br><span class="line">  getTodo: function(context) &#123;</span><br><span class="line">    // get을 사용할 때는, 요청할 uri를 작성한다.</span><br><span class="line">    axios.get(&apos;http://localhost:4000/todos&apos;)</span><br><span class="line">        // 요청이 성공하면, mutations에 commit을 하여, 원래 데이터에 요청받은 데이터를 할당한다.</span><br><span class="line">        .then((res) =&gt; &#123;</span><br><span class="line">            console.log(res);</span><br><span class="line">            context.commit(&apos;getTodo&apos;, res.data)</span><br><span class="line">        &#125;)</span><br><span class="line">        // 요청이 실패하면, 에러에 대한 조치를 취한다.</span><br><span class="line">        .catch((err) =&gt; &#123;</span><br><span class="line">            console.log(err);</span><br><span class="line">        &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>actions에서 commit한 mutations에 로직을 작성한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  getTodo (state, data) &#123;</span><br><span class="line">    state.todoList = data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="Update-changeTodo-toggle"><a href="#Update-changeTodo-toggle" class="headerlink" title=". Update: changeTodo(toggle)"></a><3>. Update: changeTodo(toggle)</3></h3><hr>
<p><strong>Update는 클라이언트단에서 기존에 있던 데이터를 서버에 요청하여, 데이터를 변경하는 것이다. todo 앱에서는 toggle이 된다.</strong></p>
<p>Vuex(store.js)의 actions에 메소드 등록할 때, <strong>axios의 patch</strong>를 사용한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// store.js</span><br><span class="line">actions: &#123;</span><br><span class="line">  toggle: function(context, payload) &#123;</span><br><span class="line">    // patch를 사용할 때는, 요청할 uri에 변경할 데이터의 uri를 붙여서 보낸다. 예를 들어, /todos/id가 올 수 있다.</span><br><span class="line">    axios.patch(`http://localhost:4000/todos/$&#123;payload&#125;`)</span><br><span class="line">        // 요청이 성공하면, mutations에 commit을 하여, 특정 데이터가 변경된 상태로 데이터가 변경된다.</span><br><span class="line">        .then((res) =&gt; &#123;</span><br><span class="line">            console.log(res);</span><br><span class="line">            context.commit(&apos;toggle&apos;, payload)</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch((err) =&gt; &#123;</span><br><span class="line">            console.log(err);</span><br><span class="line">        &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>actions에서 commit한 mutations에 로직을 작성한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  toggle (state, id) &#123;</span><br><span class="line">    const index = state.todolist.findIndex((item)=&gt;item.id === id);</span><br><span class="line">    state.todolist[index].completed = !this.todolist[index].completed;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="Delete-deleteTodo"><a href="#Delete-deleteTodo" class="headerlink" title=". Delete: deleteTodo"></a><4>. Delete: deleteTodo</4></h3><hr>
<p><strong>Update는 클라이언트단에서 기존에 있던 데이터를 서버에 요청하여, 데이터를 변경하는 것이다. todo 앱에서는 toggle이 된다.</strong></p>
<p>Vuex(store.js)의 actions에 메소드 등록할 때, <strong>axios의 patch</strong>를 사용한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// store.js</span><br><span class="line">actions: &#123;</span><br><span class="line">  deleteTodo: function(context, payload) &#123;</span><br><span class="line">    // delete를 사용할 때는, 요청할 uri에 제거할 데이터의 uri를 붙여서 보낸다. 예를 들어, /todos/id가 올 수 있다.</span><br><span class="line">    axios.delete(`http://localhost:4000/todos/$&#123;payload&#125;`)</span><br><span class="line">        // 요청이 성공하면, mutations에 commit을 하여, 특정 데이터가 지워진 상태로 데이터가 변경된다.</span><br><span class="line">        .then((res =&gt; &#123;</span><br><span class="line">            console.log(res);</span><br><span class="line">            context.commit(&apos;deleteTodo&apos;, payload)</span><br><span class="line">        &#125;))</span><br><span class="line">        .catch((err) =&gt; &#123;</span><br><span class="line">            console.log(err);</span><br><span class="line">        &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>actions에서 commit한 mutations에 로직을 작성한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  deleteTodo (state, id) &#123;</span><br><span class="line">    state.todoList = state.todoList.filter((t) =&gt; &#123;</span><br><span class="line">        return t.id !== id</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Vue/">Vue</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Axios/">Axios</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue/">Vue</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-how-to-use-vuex"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/12/27/how-to-use-vuex/">Vuex 사용법</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/12/27/how-to-use-vuex/" class="article-date">
	  <time datetime="2018-12-27T11:34:01.000Z" itemprop="datePublished">December 27, 2018</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Vue/">Vue</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="State란-무엇인가"><a href="#State란-무엇인가" class="headerlink" title="State란 무엇인가?"></a>State란 무엇인가?</h1><hr>
<p>state는 컴포넌트 간에 공유할 data를 말한다. 각 컴포넌트에서의 data 속성과 동일하기 때문에, 각 컴포넌트의 인스턴스에서 <code>data()</code> 속성을 사용하는 대신, Vuex에 state로 등록하여 사용한다.</p>
<p><br></p>
<h1 id="State-등록하기"><a href="#State-등록하기" class="headerlink" title="State 등록하기"></a>State 등록하기</h1><hr>
<p>store.js에 state(데이터)를 등록한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// store.js</span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import Vuex from &apos;vuex&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"></span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  // state안에 데이터를 등록</span><br><span class="line">  state: &#123;</span><br><span class="line">    value: 10</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h1 id="State-사용하기"><a href="#State-사용하기" class="headerlink" title="State 사용하기"></a>State 사용하기</h1><hr>
<p>가져와서 사용할 각 컴포넌트에서 Vuex의 state에 접근하여 사용한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// App.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  // store.js의 state에 있는 데이터(value)에 접근하여 가져와서 사용</span><br><span class="line">    &#123;&#123; this.$store.state.value &#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></p>
<p>위와 같은 방식으로, 어떤 컴포넌트든 Vuex(store.js)에 접근하여 state를 가져와 사용할 수 있다.</p>
<p>그러나, Template의 표현식은 최대한 간소화해야 한다. 다음과 같이 <code>computed</code>를 사용해서 state에 접근할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &#123;&#123; getValue &#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    getValue() &#123;</span><br><span class="line">      return this.$store.state.value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="Getters란-무엇인가"><a href="#Getters란-무엇인가" class="headerlink" title="Getters란 무엇인가?"></a>Getters란 무엇인가?</h1><hr>
<p>Getters는 인스턴스의 computed(계산된 속성)과 같은 역할을 한다. 인스턴스에서 computed는 이미 어떤 값이 캐싱되어 있어, 종속된 값이 변경되지 않으면, 이미 계산되 값이 바로 나오고, 종속된 값이 변경된 경우에만 다시 재계산되어 나온다.</p>
<p>그래서, Getters를 사용하면 여러 컴포넌트에서 같은 로직을 비효율적으로 사용하는 것을 막는다. 즉, 각 컴포넌트에서는 수행 로직을 호출만 하면, Vuex의 Getters를 보내주어, 코드의 가독성과 성능이 좋아진다.</p>
<p><br></p>
<h1 id="Getters-등록하기"><a href="#Getters-등록하기" class="headerlink" title="Getters 등록하기"></a>Getters 등록하기</h1><hr>
<p>store.js에 getters를 등록한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// store.js</span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import Vuex from &apos;vuex&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"></span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    todos: [</span><br><span class="line">      &#123; id: 1, text: &apos;vue&apos;, complete: true &#125;,</span><br><span class="line">      &#123; id: 2, text: &apos;react&apos;, complete: false &#125;,</span><br><span class="line">      &#123; id: 3, text: &apos;angular&apos;, complete: true &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  // todos의 complete가 true인 데이터만 필터</span><br><span class="line">  getters: &#123;</span><br><span class="line">    doneTodos: state =&gt; &#123;</span><br><span class="line">      return state.todos.filter(todo =&gt; todo.complete)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h1 id="Getters-사용하기"><a href="#Getters-사용하기" class="headerlink" title="Getters 사용하기"></a>Getters 사용하기</h1><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// App.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  // doneTodos를 화면에 보여줌</span><br><span class="line">    &#123;&#123; doneTodos &#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  // store.js의 getters에 있는 doneTodos에 접근하여 사용</span><br><span class="line">  computed: &#123;</span><br><span class="line">    doneTodos() &#123;</span><br><span class="line">      return this.$store.getters.doneTodos</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="mapGetters-사용하기"><a href="#mapGetters-사용하기" class="headerlink" title="mapGetters 사용하기"></a>mapGetters 사용하기</h1><hr>
<p>Vuex에 내장된 helper 함수 중, mapGetters를 사용하여, 좀 더 간단하게 작성할 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// App.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &#123;&#123; doneTodos &#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">// mapGetters를 import</span><br><span class="line">import &#123; mapGetters &#125; from &apos;vuex&apos;</span><br><span class="line"></span><br><span class="line">// computed에서 mapGetters를 사용</span><br><span class="line">export default &#123;</span><br><span class="line">  // Vuex 의 Getters 메서드 명과 App.vue 메서드 명이 동일할 때, [] 사용</span><br><span class="line">  computed: mapGetters([</span><br><span class="line">  &apos;doneTodos&apos;</span><br><span class="line">]),</span><br><span class="line"></span><br><span class="line">  // Vuex 의 Mutations 메서드 명과 App.vue 메서드 명을 다르게 매칭할 때, &#123;&#125; 사용</span><br><span class="line">  computed: mapGetters(&#123;</span><br><span class="line">    // 앞 doneTodos 해당 컴포넌트의 메서드를, 뒤 &apos;doneTodos&apos;는 Vuex의 getters를 의미</span><br><span class="line">    doneTodos: &apos;doneTodos&apos;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h1 id="Mutations란-무엇인가"><a href="#Mutations란-무엇인가" class="headerlink" title="Mutations란 무엇인가?"></a>Mutations란 무엇인가?</h1><hr>
<p>Mutations(변이)란, Vuex의 데이터, 즉 state 값을 변경하는 로직들을 의미한다. Vuex 저장소에서 실제로 상태를 변경하는 유일한 방법이다.</p>
<p>Mutations 특징</p>
<ul>
<li>모든 state의 변화를 추적해야 하기 때문에, 순차적, 즉 동기적으로 일을 처리한다.</li>
<li>컴포넌트의 인스턴스에서는 methods에서 사용하여, Vuex의 mutations에 접근한다.</li>
<li>이때, 인자를 받아서 Vuex로 보낼 수 있다.</li>
</ul>
<p>Getters와의 차이점</p>
<ul>
<li>인자를 받아서 Vuex에 넘겨줄 수 있다.</li>
<li>methods에서 사용(Getters는 computed에서 사용)</li>
</ul>
<p>Actions와의 차이점</p>
<ul>
<li>mutations: 동기적 로직</li>
<li>actions: 비동기적 로직</li>
</ul>
<p>만약, 여러 개의 컴포넌트에서 같은 state 값을 동시에 제어하게 되면, state 값이 어느 컴포넌트에서 호출해서 어떻게 변경된지를 추적하기가 어렵기 때문에, mutations에서는 동기적으로 하나씩 일을 처리하여, 상태의 변화를 정확하게 추적할 수 있다.</p>
<!-- mutations는 state를 변경할 때, commit을 사용한다. -->
<p><br></p>
<h1 id="Mutations-등록하기"><a href="#Mutations-등록하기" class="headerlink" title="Mutations 등록하기"></a>Mutations 등록하기</h1><hr>
<p>먼저 Vuex(store.js)에 mutations를 등록해야 한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// store.js</span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line"></span><br><span class="line">mutations: &#123;</span><br><span class="line">  getTodo (state, payload) &#123;</span><br><span class="line">    state.todoList = payload;</span><br><span class="line">  &#125;,</span><br><span class="line">  // function을 같이 써줘도 된다.</span><br><span class="line">  addTodo: function(state, payload) &#123;</span><br><span class="line">    state.todoList = [...state.todoList, payload];</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>mutations는 getters와 다르게, 인자를 받아서 Vuex에 넘겨줄 수 있다.</p>
<ul>
<li>첫번째 인자: state로, store.js에 있는 state를 의미한다.</li>
<li>두번째 인자: payload로, 컴포넌트에서 보내주는 데이터이다.(만약 데이터가 없다면, 생략 가능)</li>
</ul>
<p><br></p>
<h1 id="Mutations-사용하기"><a href="#Mutations-사용하기" class="headerlink" title="Mutations 사용하기"></a>Mutations 사용하기</h1><hr>
<p>컴포넌트의 인스턴스에서는 methods에서 사용하여, <code>commit</code>으로 Vuex(store.js)의 mutations에 접근한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// App.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;section&gt;</span><br><span class="line">    &lt;div class=&quot;row justify-content-center mt-4&quot;&gt;</span><br><span class="line">      &lt;input v-model=&quot;inputField&quot; v-on:keyup.enter=&quot;addTodo&quot; class=&quot;mr-1&quot; placeholder=&quot;Todo Item&quot; /&gt;</span><br><span class="line">      &lt;button @click=&quot;addTodo&quot; class=&quot;btn btn-primary&quot;&gt;Add Todo&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/section&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  // store.js에서의 mutations 중 &apos;getTodo&apos;에 접근</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    this.$store.commit(&apos;getTodo&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line">  // store.js에서의 mutations 중 &apos;addTodo&apos;에 접근</span><br><span class="line">  methods: &#123;</span><br><span class="line">    addTodo: function() &#123;</span><br><span class="line">        if(this.inputField) &#123;</span><br><span class="line">          // &apos;addTodo&apos;는 mutations에 있는 &apos;addTodo&apos;, this.inputField는 Vuex(store.js)에 넘겨줄 데이터</span><br><span class="line">           this.$store.commit(&apos;addTodo&apos;, this.inputField);</span><br><span class="line">           this.inputField = &apos;&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>참고로, main.js에 전역 인스턴스에 store를 등록했기 때문에, this.$store를 사용할 수 있다.</p>
<p><br></p>
<h1 id="mapMutations-사용하기"><a href="#mapMutations-사용하기" class="headerlink" title="mapMutations 사용하기"></a>mapMutations 사용하기</h1><hr>
<p>Vuex에 내장된 helper 함수 중, mapMutations를 사용하여, 좀 더 코드 가독성을 높일 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// App.vue</span><br><span class="line">// mapMutations를 import 해야함</span><br><span class="line">import &#123; mapMutations &#125; from &apos;vuex&apos;</span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">  // Vuex 의 Mutations 메서드 명과 App.vue 메서드 명이 동일할 때, [] 사용</span><br><span class="line">  ...mapMutations([</span><br><span class="line">    &apos;addTodo&apos;</span><br><span class="line">  ]),</span><br><span class="line"></span><br><span class="line">  // Vuex 의 Mutations 메서드 명과 App.vue 메서드 명을 다르게 매칭할 때, &#123;&#125; 사용</span><br><span class="line">  ...mapMutations(&#123;</span><br><span class="line">    addTodo: &apos;addTodo&apos; // 앞 addTodo는 해당 컴포넌트의 메서드를, 뒤 &apos;addTodo&apos;는 Vuex의 mutations를 의미</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h1 id="Actions란-무엇인가"><a href="#Actions란-무엇인가" class="headerlink" title="Actions란 무엇인가?"></a>Actions란 무엇인가?</h1><hr>
<p>actions란, Vue에서 비동기적으로 처리되야 하는 것들을 관리하기 위한것이다. 즉, 서버와의 http 통신이나 setTimeout() 등과 같이, 결과를 받아올 타이밍이 예측되지 않은 로직을 actions에 선언하고 처리한다.</p>
<p>대표적으로 비동기인 다음의 2가지를 actions에서 주로 사용한다.</p>
<ul>
<li>http통신</li>
<li>setTimeout()</li>
</ul>
<p><br></p>
<h1 id="http-통신-axios-사용"><a href="#http-통신-axios-사용" class="headerlink" title=" http 통신: axios 사용"></a><1> http 통신: axios 사용</1></h1><hr>
<h2 id="Actions-등록하기"><a href="#Actions-등록하기" class="headerlink" title="Actions 등록하기"></a>Actions 등록하기</h2><hr>
<p>먼저 Vuex(store.js)에 actions를 등록해야 한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// store.js</span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line"></span><br><span class="line">  actions: &#123;</span><br><span class="line">      addTodo: function(context, payload) &#123;</span><br><span class="line">        axios.post(&apos;http://localhost:4000/todos&apos;, &#123;</span><br><span class="line">            id: 4,</span><br><span class="line">            text: payload,</span><br><span class="line">            completed: false</span><br><span class="line">        &#125;)</span><br><span class="line">            .then((res) =&gt; &#123;</span><br><span class="line">              // 상태(state)가 변경된 것을 추적하기 위해, mutations의 메소드를 호출(commit)</span><br><span class="line">                context.commit(&apos;addTodo&apos;, res.data)</span><br><span class="line">            &#125;)</span><br><span class="line">            .catch((err) =&gt; &#123;</span><br><span class="line">                console.log(err);</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="Mutations-등록하기-1"><a href="#Mutations-등록하기-1" class="headerlink" title="Mutations 등록하기"></a>Mutations 등록하기</h2><hr>
<p>actions에 등록을 했어도, 상태가 변경된 것을 추적하기 위해서는 mutations의 메소드를 호출(commit) 해야한다. 그리고, mutations에 actions에 등록한 메소드를 작성한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  addTodo (state, todo) &#123;</span><br><span class="line">      state.todoList = [...state.todoList, todo]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="Actions-사용하기"><a href="#Actions-사용하기" class="headerlink" title="Actions 사용하기"></a>Actions 사용하기</h2><hr>
<p>actions를 호출할 때는 <code>dispatch</code>를 사용한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// App.vue</span><br><span class="line">methods: &#123;</span><br><span class="line">  addTodo() &#123;</span><br><span class="line">    // &apos;addTodo&apos;는 actions에 있는 &apos;addTodo&apos;, this.inputField는 Vuex(store.js)에 넘겨줄 데이터</span><br><span class="line">    this.$store.dispatch(&apos;addTodo&apos;, this.inputField);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="mapActions-사용하기"><a href="#mapActions-사용하기" class="headerlink" title="mapActions 사용하기"></a>mapActions 사용하기</h2><hr>
<p>Vuex에 내장된 helper 함수 중, mapActions를 사용하여, 좀 더 간단하게 작성할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// App.vue</span><br><span class="line">import &#123;mapActions&#125; from &apos;vuex&apos;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    // Vuex 의 Actions 메서드 명과 App.vue 메서드 명이 동일할 때, [] 사용</span><br><span class="line">    ...mapActions([</span><br><span class="line">      &apos;addTodo&apos;,</span><br><span class="line">      &apos;getTodo&apos;</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    // Vuex 의 Actions 메서드 명과 App.vue 메서드 명을 다르게 매칭할 때, &#123;&#125; 사용</span><br><span class="line">  ...mapActions(&#123;</span><br><span class="line">    addTodo: &apos;addTodo&apos; // 앞 addTodo는 해당 컴포넌트의 메서드를, 뒤 &apos;addTodo&apos;는 Vuex의 actions를 의미</span><br><span class="line">  &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="setTimeout-사용"><a href="#setTimeout-사용" class="headerlink" title=" setTimeout() 사용"></a><2> setTimeout() 사용</2></h1><hr>
<h2 id="Actions-등록하기-1"><a href="#Actions-등록하기-1" class="headerlink" title="Actions 등록하기"></a>Actions 등록하기</h2><hr>
<p>먼저 Vuex(store.js)에 actions를 등록해야 한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// store.js</span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line"></span><br><span class="line">  delayTime: function (context, payload) &#123;</span><br><span class="line">     return setTimeout(function () &#123;</span><br><span class="line">       commit(&apos;addTodo&apos;, payload); // mutations에 있는 &apos;addTodo&apos; 호출</span><br><span class="line">     &#125;, 5000);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="Mutations-등록하기-2"><a href="#Mutations-등록하기-2" class="headerlink" title="Mutations 등록하기"></a>Mutations 등록하기</h2><hr>
<p>actions에 등록을 했어도, 상태가 변경된 것을 추적하기 위해서는 mutations의 메소드를 호출(commit) 해야한다. 그리고, mutations에 actions에 등록한 메소드를 작성한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  addTodo (state, todo) &#123;</span><br><span class="line">      state.todoList = [...state.todoList, todo]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="Actions-사용하기-1"><a href="#Actions-사용하기-1" class="headerlink" title="Actions 사용하기"></a>Actions 사용하기</h2><hr>
<p>actions를 호출할 때는 <code>dispatch</code>를 사용한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// App.vue</span><br><span class="line">addTime(time) &#123;</span><br><span class="line">   this.$store.dispatch(&apos;delayTime&apos;, time);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Vue/">Vue</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vuex/">Vuex</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-what-is-vuex"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/12/26/what-is-vuex/">Vuex란 무엇인가?</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/12/26/what-is-vuex/" class="article-date">
	  <time datetime="2018-12-26T11:16:20.000Z" itemprop="datePublished">December 26, 2018</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Vue/">Vue</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Vuex란-무엇인가"><a href="#Vuex란-무엇인가" class="headerlink" title="Vuex란 무엇인가?"></a>Vuex란 무엇인가?</h1><hr>
<p><strong>Vuex란, 상태관리 패턴에 대한 라이브러리로써, 애플리케이션의 모든 컴포넌트에 대한 중앙집중식 저장소 역할을 하며, 예측 가능한 방식으로 상태를 변경할 수 있다.</strong></p>
<p><br></p>
<h1 id="Vuex는-왜-사용하는가"><a href="#Vuex는-왜-사용하는가" class="headerlink" title="Vuex는 왜 사용하는가?"></a>Vuex는 왜 사용하는가?</h1><hr>
<p>Vuex는 <strong>상태관리(State Management)를 위해 사용한다. 여기서 말하는 상태(State)란, 데이터를 말하며, 컴포넌트간에 데이터 통신 및 전달을 효율적으로 관리를 쉽게 하기 위해 Vuex를 사용한다.</strong></p>
<p>Vuex는 중대형 규모의 앱 컴포넌트들을 관리할 때 좋은데, 일반적으로 앱의 규모가 커지면 다음과 같은 문제가 생긴다.</p>
<ul>
<li>단순 부모-자식간의 데이터 통신이 아닌, 그 중간에 많은 컴포넌트들이 있을 경우, 데이터 통신 방식이 복잡해짐</li>
<li>EventBus를 사용하여 상하위 관계가 아닌 컴포넌트들간의 통신시에 관리가 안됨</li>
</ul>
<p>이런 문제를 해결하기 위해, Vuex를 사용하여 모든 데이터(State)를 한 곳에서 중앙 집중식으로 관리한다. 즉, Vuex는 공통의 상태를 공유하는 여러 컴포넌트가 있을 경우, 이를 Vuex 한 곳(전역)에서 집중적으로 관리하는 역할을 한다. 그러나, 만약 공통으로 공유하는 것이 아닌, 개별의 로컬 컴포넌트에서 사용하는 경우에는, 꼭 Vuex에 저장할 필요가 없다.</p>
<p><br></p>
<h1 id="Vuex-Architecture"><a href="#Vuex-Architecture" class="headerlink" title="Vuex Architecture"></a>Vuex Architecture</h1><hr>
<p>위에서, Vuex는 상태관리 패턴에 대한 라이브러리라고 했다. 즉, <strong>상태관리 패턴</strong>이란, <strong>상태를 관리하기 위한 하나의 패턴방식을 말한다. Vuex에서의 패턴방식은 <code>단반향 데이터 흐름</code>을 따른다.</strong></p>
<p><img src="/images/vuex1.png" alt="Vuex One-Way Data Flow"><br>출처: <a href="https://vuex.vuejs.org/" target="_blank" rel="noopener">Vuex One-Way Data Flow</a></p>
<p>상태관리는 3가지로 구성되어 있다.</p>
<ul>
<li><strong>state</strong>: 컴포넌트간에 공유하는 data</li>
<li><strong>view</strong>: data가 보여지는 template</li>
<li><strong>actions</strong>: 사용자의 입력에 따라 반응하는 methods</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line"></span><br><span class="line">  // state</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &apos;hello world&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // view</span><br><span class="line">  template: `</span><br><span class="line">    &lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;</span><br><span class="line">  `,</span><br><span class="line"></span><br><span class="line">  // actions</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeMsg () &#123;</span><br><span class="line">      this.msg = &apos;world hello&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="Vuex-Architecture-1"><a href="#Vuex-Architecture-1" class="headerlink" title="Vuex Architecture"></a>Vuex Architecture</h1><hr>
<p>전체적인 Vuex Architecture는 다음과 같다.</p>
<p><img src="/images/vuex2.png" alt="Vuex Architecture"><br>출처: <a href="https://vuex.vuejs.org/" target="_blank" rel="noopener">Vuex Architecture</a></p>
<p><br></p>
<h1 id="Vuex-설치-및-등록"><a href="#Vuex-설치-및-등록" class="headerlink" title="Vuex 설치 및 등록"></a>Vuex 설치 및 등록</h1><hr>
<ol>
<li><p>npm을 이용해서 설치한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vuex</span><br></pre></td></tr></table></figure>
</li>
<li><p>Vuex를 등록할 js 파일을 새로 생성하는데, 보통 관례로 store.js로 만든다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// store.js</span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import Vuex from &apos;vuex&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"></span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  //</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Vuex를 전역에서 사용하기 위해, main.js에 등록한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import App from &apos;./App.vue&apos;</span><br><span class="line">// store를 import</span><br><span class="line">import store from &apos;./store&apos;</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = false</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  // store를 루트(전역) 인스턴스에 등록</span><br><span class="line">  store,</span><br><span class="line">  render: h =&gt; h(App),</span><br><span class="line">&#125;).$mount(&apos;#app&apos;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>루트 인스턴스에 store 옵션을 제공함으로써 저장소는 루트의 모든 하위 컴포넌트에 주입되고, 하위 컴포넌트에서 this.$store로 사용할 수 있다. (루트 인스턴스: main.js에 있는 최상단의 인스턴스)</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Vue/">Vue</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vuex/">Vuex</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-vue-architecture"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/12/23/vue-architecture/">Vue Architecture</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/12/23/vue-architecture/" class="article-date">
	  <time datetime="2018-12-23T11:57:29.000Z" itemprop="datePublished">December 23, 2018</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Vue/">Vue</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Component-단위로-개발하는-Vue"><a href="#Component-단위로-개발하는-Vue" class="headerlink" title="Component 단위로 개발하는 Vue"></a>Component 단위로 개발하는 Vue</h1><hr>
<p>Vue는 컴포넌트 단위로 개발할 수 있다. <strong>컴포넌트(Component)란, html, css, javascript를 1개의 파일 단위로 나눠서 개발하는 것을 말한다.</strong> Vue에서는 이를 싱글 파일 컴포넌트라고 하는데, UI 단위로 나눠서 개발하여, 코드의 재사용 측면에서 좋다.</p>
<p>즉, Vue.js는 컴포넌트를 조합해 전체 애플리케이션을 만든다. 이때, 컴포넌트들은 부모-자식 관계를 갖는 트리구조로 작성할 수 있다.</p>
<p>Vue 프로젝트를 생성하게 되면, 다양한 파일이 만들어진다.</p>
<p><br></p>
<h1 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h1><hr>
<p><strong>index.html: 어플리케이션 전체의 뼈대가 되는 html 파일이다.</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;&gt;</span><br><span class="line">    &lt;title&gt;what&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;noscript&gt;</span><br><span class="line">      &lt;strong&gt;We&apos;re sorry but what doesn&apos;t work properly without JavaScript enabled. Please enable it to continue.&lt;/strong&gt;</span><br><span class="line">    &lt;/noscript&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;!-- built files will be auto injected --&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h1 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h1><hr>
<p><strong>main.js: Vue 인스턴스를 생성해주는 파일이다.</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import App from &apos;./App.vue&apos;</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = false</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  render: h =&gt; h(App),</span><br><span class="line">&#125;).$mount(&apos;#app&apos;)</span><br></pre></td></tr></table></figure></p>
<p>이 자바스크립트 파일은 new 연산자를 사용해서 Vue 인스턴스를 생성해준다. Vue는 기본적으로 인스턴스를 생성하여 개발을 하는데, 컴포넌트 단위로 개발을 할 경우, main.js에서 new 연산자로 Vue 인스턴스를 생성하게 해주고, 각 컴포넌트에서 각 UI에 맞게 인스턴스를 활용해서 컴포넌트를 개발한다.</p>
<p>render에서 h() 안에 있는 ‘App’은 첫 화면에 뿌려질 Vue 컴포넌트를 의미한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">render: h =&gt; h(App)</span><br></pre></td></tr></table></figure></p>
<p>$mount() 안에 있는 ‘#app’은 id를 ‘app’으로 가지고 있는 html 태그를 의미한다. 이 태그로 마운트한다는 것인데, 마운트한다는 것은 위 App 컴포넌트를 이 html 태그(id를 ‘app’으로 가지고 있는 태그)에 연결시킨다는 의미이다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$mount(&apos;#app&apos;)</span><br></pre></td></tr></table></figure></p>
<p>즉, 위 index.html에 있는 <code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code> 안으로 App 컴포넌트를 연결(넣는다)한다는 뜻이다.</p>
<p><br></p>
<h1 id="component-vue"><a href="#component-vue" class="headerlink" title="component.vue"></a>component.vue</h1><hr>
<p><strong>component.vue: 재사용성을 고려해 UI 단위로 개발하는 vue 파일이다.</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt;</span><br><span class="line">    &lt;HelloWorld msg=&quot;Welcome to Your Vue.js App&quot;/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import HelloWorld from &apos;./components/HelloWorld.vue&apos;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;app&apos;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    HelloWorld</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">#app &#123;</span><br><span class="line">  font-family: &apos;Avenir&apos;, Helvetica, Arial, sans-serif;</span><br><span class="line">  -webkit-font-smoothing: antialiased;</span><br><span class="line">  -moz-osx-font-smoothing: grayscale;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: #2c3e50;</span><br><span class="line">  margin-top: 60px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p>
<p>component는 위와 같이 3가지로 구성되어 있다.</p>
<ul>
<li>template</li>
<li>script</li>
<li>style</li>
</ul>
<p>Vue의 MVVM 패턴에 따라 나누면 다음과 같은 3가지로 구성되어 있다.</p>
<ul>
<li>ViewModel</li>
<li>View</li>
<li>Model</li>
</ul>
<p><br></p>
<p><strong>1. ViewModel</strong></p>
<p><strong>Vue.js에서 모든 Vue 인스턴스는 ViewModel인데, 이 ViewModel은 Model과 View 사이에서 양방향 데이터 바인딩을 해줌으로써, 동기화 역할을 한다.</strong> ViewModel은 Vue 생성자 혹은 하위 클래스들에 의해 인스턴스화된다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123; /* options */ &#125;)</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<p><strong>2. View</strong></p>
<p><strong>Vue.js는 DOM 기반의 템플릿을 사용하는데, View의 실제 돔(DOM)은 Vue instance에 의해 관리된다.</strong> 각 Vue 인스턴스는 해당 DOM 요소에 연관된다. Vue 인스턴스가 생성되면 필요한 데이터 바인딩을 설정하는 동안 루트 요소의 모든 자식 노드를 반복적으로 탐색한다. 뷰가 컴파일이 되면 데이터 변경에 반응할 수 있게 된다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></p>
<p>즉, 해당 HTML 컴포넌트 범위(해당 DOM 요소가 담긴 템플릿)를 Vue 인스턴스의 vm.$el에 설정한다. 뷰는 Vue 인스턴스가 생성 될 때, 컴파일 되며 뷰모델의 다양한 동작 기능들이 바인딩 된다. 그렇게 됨으로써 뷰의 변경이 감지되면 뷰모델이 이를 감지하여 반응할 수 있게된다. 또한, 뷰의 변경은 집단적으로, 비동기로 실행되기 때문에 높은 성능을 발휘한다.</p>
<p><br></p>
<p><strong>3. Model</strong></p>
<p><strong>Vue.js에서 모델은 단순히 자바스크립트 객체 혹은 데이터 객체로 표현할 수 있다. 데이터 객체의 프로퍼티를 조작하면 이를 관찰하는 뷰 인스턴스가 변경을 알린다.</strong> Vue.js는 ES5 getter/setters로 데이터 객체의 프로퍼티를 변환한다. 그렇기에 뷰를 변경하기 위해 Vue에 명시적으로 신호를 보낼 필요가 없다. 그리고, 각 뷰 인스턴스는 데이터 객체에 있는 모든 프로퍼티들을 프록시한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  name: &apos;app&apos;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    HelloWorld</span><br><span class="line">  &#125;,</span><br><span class="line">  // Model</span><br><span class="line">  data: function() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &apos;hello&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Vue/">Vue</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Architecture/">Architecture</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue/">Vue</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-package-json"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/12/23/package-json/">package.json, node_modules, 그리고 package-lock.json간의 관계</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/12/23/package-json/" class="article-date">
	  <time datetime="2018-12-22T15:13:46.000Z" itemprop="datePublished">December 23, 2018</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Node-js/">Node.js</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="npm이란-무엇인가"><a href="#npm이란-무엇인가" class="headerlink" title="npm이란 무엇인가?"></a>npm이란 무엇인가?</h1><hr>
<p><strong>npm(node package manager)</strong>은 노드 패키지 매니저의 약자로써, 모듈(패키지) 관리(설치, 업데이트, 삭제)를 하기위한 매니저이다.</p>
<p>노드의 정의는 크게 2가지로 나눌 수 있다.</p>
<ul>
<li><strong>서버</strong>: 네트워크를 통해 클라이언트에 정보나 서비스를 제공하는 컴퓨터 또는 프로그램을 말한다.</li>
<li><strong>자바스크립트 런타임</strong>: 자바스크립트 프로그램을 컴퓨터에서 실행할 수 있게 하는 환경을 말한다.</li>
</ul>
<p><strong>npm에서의 노드는 자바스크립트 런타임을 의미한다.</strong> 즉, 대부분의 자바스크립트 프로그램은 패키지라는 이름으로 npm에 등록되어 특정 기능을 하는 패키지가 필요하면, npm에서 찾아 설치하면 된다. npm에 업로드된 노드 모듈(자바스크립트 기반으로 만들어진 프로그램 파일)을 패키지라고 부른다. 그래서, npm을 자바스크립트 패키지 매니저라고도 부른다.</p>
<p>모듈이 다른 모듈을 사용할 수 있는 것처럼, 어떤 패키지가 다른 패키지를 사용할 수 있다. 이런 관계를 <strong>의존 관계(dependencies)</strong>라고 부른다.</p>
<p>이런 패키지 매니저가 npm 말고도, 페이스북에서 만든 yarn도 있다.</p>
<p><br></p>
<h1 id="npm은-왜-사용하는가"><a href="#npm은-왜-사용하는가" class="headerlink" title="npm은 왜 사용하는가?"></a>npm은 왜 사용하는가?</h1><hr>
<p>npm에는 약 60만 개(2018년 6월 기준)의 패키지가 등록되어 있는데, 이는 대부분 오픈소스로 등록되어 있어 웹개발을 할 때 많은 도움이 된다.</p>
<p>또한, 새로운 모듈(패키지)를 설치하거나 관리를 위해, npm은 npm cli를 제공해서 cli 명령어로 설치, 업데이트 및 삭제를 쉽게 할 수 있다.</p>
<p><br></p>
<h1 id="package-json이란-무엇인가"><a href="#package-json이란-무엇인가" class="headerlink" title="package.json이란 무엇인가?"></a>package.json이란 무엇인가?</h1><hr>
<p><strong>package.json</strong>이란, <strong>생성한 프로젝트의 메타정보와 이 프로젝트가 의존하고 있는(설치한) 모듈들에 대한 정보들을 json 형태로 모아놓은 파일이다.</strong></p>
<p>package.json 파일내에 있는 각 속성들에 대해서는 다음 링크를 참고하면 좋을 것 같다.<br><a href="https://programmingsummaries.tistory.com/385" target="_blank" rel="noopener">package.json에 대한 자세한 설명</a></p>
<p><br></p>
<h1 id="package-json은-왜-사용하는가"><a href="#package-json은-왜-사용하는가" class="headerlink" title="package.json은 왜 사용하는가?"></a>package.json은 왜 사용하는가?</h1><hr>
<p>만약 이 package.json 파일을 사용하지 않을 경우 다음과 같은 문제가 발생할 수 있다.</p>
<ul>
<li>프로젝트에서 사용하는 외부 모듈들이 많아지게 되면, 관리하기가 어려워진다.</li>
<li>각 패키지들은 고유한 버전이 있기 때문에, 따로 기록해 두어야 한다. 왜냐하면, 패키지의 버전도 빈번하게 업데이트가 되기 때문이다.</li>
<li>새로운 프로젝트를 진행할 때, 필요한 모듈들이 많다면 매번 npm 명령으로 설치해야 하는 번거로움이 있다.</li>
</ul>
<p>이런 경우, 필요한 패키지들의 목록을 파일로 정리해놓고, 목록 파일을 이용하여 단 한번의 명령어로 필요한 패키지들을 모두 설치할 수 있다. 이러한 패키지 정의 파일을 package.json 파일이라고 한다. 즉, <strong>package.json은 프로젝트에 대한 메타정보, 그리고 설치한 패키지의 의존성 및 버전을 관리하는 파일이다.</strong></p>
<p>vue cli로 Vue 프로젝트를 생성하면, 자동으로 package.json 파일이 만들어 지지만, npm init을 사용하면, package.json 파일을 직접 만들 수도 있다. 그리고, 팀 내에서 동일한 개발환경을 구축하려고 할 때, 이미 작성된 package.json 파일이 있다면, 팀 내에 배포하여 동일한 개발환경을 빠르게 구축할 수 있다.</p>
<p><br></p>
<h1 id="node-modules란-무엇인가"><a href="#node-modules란-무엇인가" class="headerlink" title="node_modules란 무엇인가?"></a>node_modules란 무엇인가?</h1><hr>
<p>Vue 프로젝트를 생성하면, package.json 파일 뿐만 아니라, node_modules 디렉토리가 같이 생성된다. package.json에는 프로젝트가 의존하고 있는 모듈들에 대한 정보가 나와있고, node_modules 디렉토리에는 package.json에 있는 모듈 뿐만 아니라, package.json에 있는 모듈이 의존하고 있는 모듈 전부를 포함하고 있다. 그래서 node_modules 디렉토리안에는 정말 많은 모듈들이 들어가 있다. npm으로 새로운 모듈(패키지)를 설치하게 되면, package.json과 node_modules에 추가된다.</p>
<p>참고로, git에 커밋할 때, node_modules을 제외해도 된다. 왜냐하면, node_modules가 없어도, package.json에 설치한 패키지들이 모두 있기 때문에, <code>npm install</code>로 node_modules를 언제든지 설치가 가능하기 때문이다.</p>
<p><br></p>
<h1 id="package-lock-json이란-무엇인가"><a href="#package-lock-json이란-무엇인가" class="headerlink" title="package-lock.json이란 무엇인가?"></a>package-lock.json이란 무엇인가?</h1><hr>
<p><strong>package-lock.json은 이 package-lock.json이 생성되는 시점의 의존성 트리(node_modules)에 대한 정보를 가지고 있는 파일을 말한다.</strong> 의존성 트리는 package.json에 등록된 모듈과 그 모듈들이 의존하고 있는 모듈 전부를 포함하고 있기 때문에, 결국 package-lock.json도 이 모든 모듈들을 가지고 있다. npm을 사용해서 node_modules나 package.json을 수정하게 되면, package-lock.json 또한 자동으로 업데이트가 된다.</p>
<p><br></p>
<h1 id="package-lock-json은-왜-사용하는가"><a href="#package-lock-json은-왜-사용하는가" class="headerlink" title="package-lock.json은 왜 사용하는가?"></a>package-lock.json은 왜 사용하는가?</h1><hr>
<p>package.json 파일에는 의존성 모듈(dependencies)의 version range가 사용된다. version range란, 특정 버전이 아닌, 버전의 범위를 의미한다. 예를 들어, <code>npm install express</code>로 express를 설치하면, package.json에는 ‘^4.10.3’(Caret Ranges)과 같이 버전 범위가 추가된다. 이 버전의 express가 추가된 package.json을 가지고 <code>npm install</code>을 실행하면, 현재는 4.10.3 버전이 설치되지만, express의 버전이 업데이트된 상태로 publish가 된 후에, 동일한 package.json 파일로 <code>npm install</code>을 실행했을 경우, 원래 버전이 아닌, 새로 업데이트된 버전으로 express가 변경된다. 이럴 경우, 기존에 가지고 있던 node_modules(의존성 트리)에 있던 모듈의 버전과 충돌이 일어나, 오류를 발생시킬 수 있다. 이 문제를 해결하기 위해, package-lock.json을 사용하는 것이다.</p>
<p>package-lock.json은 node_modules(의존성 트리)에 대한 정보를 가지고 있는데, package-lock.json이 업데이트가 되는 시점에 node_modules(의존성 트리)을 재생성할 수 있다. 그래서, package-lock.json 파일이 있다면, <code>npm install</code>로 package.json과 package-lock.json에 있는 모듈이 새로 업데이트되는 동시에, node_modules(의존성 트리)가 새로 생성되어, 각 파일이 가지고 있는 모듈의 버전을 동일하게 맞출 수가 있게 된다.</p>
<p>즉, package.json에 있는 모듈의 버전은 <code>npm install</code>을 수행하는 시점에 따라 달라진다. 이 말은, <code>npm install</code>을 수행하는 시점에 publish 되어있는 모듈의 버전으로 업데이트가 된다는 뜻이다. 이렇게 되면, package.json과 package-lock.json에 있는 모듈이 같은 버전으로 업데이트가 되고, 이때 package-lock.json 때문에 node_modules(의존성 트리)가 재생성되어, 3개의 파일에 있는 모듈이 모두 같은 버전으로 맞춰지게 되어 오류가 안나게 된다.</p>
<p>이런 이유로, git에 커밋할 때, package.json 파일 뿐만 아니라, packge-lock.json 파일 또한 같이 커밋을 해야 한다.</p>
<p><br></p>
<h1 id="패키지-version"><a href="#패키지-version" class="headerlink" title="패키지 version"></a>패키지 version</h1><hr>
<p>노드 패키지들의 버전은 세 자리로 되어있는데, 이는 SemVer 방식의 버전 넘버링을 따르기 때문이다. SemVer는 Semantic Versioning(유의적 버전)의 약어인데, 이는 버전을 구성하는 세 자리가 모두 의미가 있다는 뜻이다.</p>
<p>서비스를 개발하다 보면, 정말 많은 패키지들을 사용하게 되는데, 이런 많은 패키지들이 서로 얽히다 보면 문제가 생길 수 있다. 예를 들어, 어떤 패키지의 버전을 업그레이드 했는데, 그것을 사용하는 다른 패키지에서 에러가 발생한다면 문제가 된다. 따라서 버전 번호를 어떻게 정하고, 올려야 하는지를 명시하는 규칙을 만들었는데, 이것이 바로 SemVer 이다.</p>
<p>버전은 세 자리로 구성되어 있다.</p>
<ul>
<li><strong>major 버전</strong>: 하위 호환이 안될 정도로 패키지의 내용이 수정되었을 때 올린다.<ul>
<li>주 버전이 0이면, 초기 개발 중이라는 뜻이다.</li>
<li>1부터는 정식 버전이다.</li>
<li>만약, 1.7.1에서 2.0.0으로 올렸다면, 1.7.1 버전 패키지를 사용하고 있던 사람들이 2.0.0으로 업데이트 했을 때, 에러가 발생할 확률이 크다.</li>
</ul>
</li>
<li><strong>minor 버전</strong>: 하위 호환이 되는 업데이트 시에 올린다.<ul>
<li>만약, 1.7.1에서 1.8.0으로 올렸다면, 1.7.1 사용자가 1.8.0으로 업데이트 했을 때, 아무 문제가 없어야 한다.</li>
</ul>
</li>
<li><strong>patch 버전</strong>: 새로운 기능이 추가되었다기 보다는, 기존 기능에 문제가 있어 수정한 것을 내놓았을 때, patch 버전을 올린다.<ul>
<li>1.7.0에서 1.7.1으로 올렸다면, 업데이트 후 문제가 없어야 한다.</li>
</ul>
</li>
</ul>
<p>새 버전을 배포한 후에는, 그 버전의 내용을 절대 수정하면 안된다. 만약, 수정 사항이 생기면, major버전, minor 버전, patch버전 중 하나를 의미에 맞게 올려서 새로운 버전으로 배포해야 한다.</p>
<p>버전의 숫자마다 의미가 부여되어 있기 때문에, 다른 패키지를 사용할 때도 버전만 보고 에러 발생 여부를 판단할 수 있다.</p>
<p>만약, 의존하는 패키지의 major 버전이 업데이트 되었다면, 기존 코드와 호환이 되지 않을 확률이 크기 때문에, 미리 주의를 기울여야 한다. 만약, minor나 patch 버전으로 업데이트 되었다면, 상대적으로 안심하고 버전을 올리 수 있다.</p>
<p>package.json에는 버전 말고도, 다른 기호(‘^’, ‘~’ 등)들이 있다. 이런 기호들은 버전에는 포함되지 않지만, 설치 또는 업데이트 시 어떤 버전의 범위를 설치해야 하는지 알 수 있다.</p>
<ul>
<li><strong>^(캐럿)</strong>: minor 버전까지만 설치 또는 업데이트한다.<ul>
<li>예를 들어, npm install express@^1.7.1 이라면, 1.7.1 &lt;= 버전 &lt; 2.0.0까지 설치가 되고, 2.0.0은 설치되지 않는다.</li>
</ul>
</li>
<li><strong>~(틸트)</strong>: patch 버전까지만 설치 또는 업데이트한다.<ul>
<li>npm install express@~1.7.1 이라면, 1.7.1 &lt;= 버전 &lt; 1.8.0까지 설치가 된다.</li>
</ul>
</li>
</ul>
<p>~ 보다 ^가 많이 사용되는 이유는, minor 버전까지는 하위 호환이 되기 때문이다.</p>
<p><a href="https://semver.npmjs.com/" target="_blank" rel="noopener">npm semver calculator</a>에 방문하면, 패키지 별로 버전 표기법을 사용하여, 업데이터 버전 범위를 확인 가능하다.</p>
<p>참고로, npm install 명령어의 패키명 뒤에 @버전을 추가하면 패키지 버전을 지정하여 설치할 수 있다.</p>
<p><br></p>
<h1 id="nodemon이란"><a href="#nodemon이란" class="headerlink" title="nodemon이란?"></a>nodemon이란?</h1><hr>
<p><strong>nodemon은 프로젝트 폴더의 파일들을 모니터링하고 있다가, 파일이 수정될 경우 자동으로 서버를 재시작을 해준다.</strong> nodemon을 위해서 소스에 다른 설정을 추가할 필요도 없기 때문에 상당히 편리하게 사용할 수 있습니다.</p>
<p><br></p>
<h1 id="–save와-–dev"><a href="#–save와-–dev" class="headerlink" title="–save와 –dev"></a>–save와 –dev</h1><hr>
<p><code>npm install 모듈명 --save</code> 을 입력하면, 설치하는 모듈을 package.json에 등록할 수 있다.(npm@5 부터는 –save는 기본옵션이다.)<br>그래서, npm@5 부터는 –save 옵션을 사용하지 않더라도, 모든 install 명령은 package.json의 dependencies에 설치되어 관리된다.<br>그리고, <code>npm install 모듈명 --save --dev</code>을 입력하면, 설치하는 모듈을 package.json에 등록할 수 있을 뿐만 아니라, –dev 때문에, package.json 파일에서 devDepencies에 등록된다. devDepencies에서 관리하는 모듈들은 개발용 모듈들이고, depencies에서 관리하는 모듈들은 배포용 모듈들이다.</p>
<p>package.json에 명시된 모든 의존 패키지를 한번에 설치하기 위해서는, npm install 명령어를 사용하면 된다.</p>
<p><br></p>
<h1 id="자주-사용하는-npm-명령어"><a href="#자주-사용하는-npm-명령어" class="headerlink" title="자주 사용하는 npm 명령어"></a>자주 사용하는 npm 명령어</h1><hr>
<table>
<thead>
<tr>
<th style="text-align:center">목적</th>
<th style="text-align:center">npm 명령어</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">package.json 생성</td>
<td style="text-align:center">npm init</td>
</tr>
<tr>
<td style="text-align:center">패키지 로컬 설치</td>
<td style="text-align:center">npm install package-name</td>
</tr>
<tr>
<td style="text-align:center">패키지 전역 설치</td>
<td style="text-align:center">npm install -g package-name</td>
</tr>
<tr>
<td style="text-align:center">패키지 개발 설치</td>
<td style="text-align:center">npm install –save –dev package-name</td>
</tr>
<tr>
<td style="text-align:center">package.json의 모든 패키지 설치</td>
<td style="text-align:center">npm install</td>
</tr>
<tr>
<td style="text-align:center">package.json의 모든 패키지 설치</td>
<td style="text-align:center">npm install</td>
</tr>
<tr>
<td style="text-align:center">로컬/개발 패키지 제거</td>
<td style="text-align:center">npm uninstall package-name</td>
</tr>
<tr>
<td style="text-align:center">전역 패키지 제거</td>
<td style="text-align:center">npm uninstall -g package-name</td>
</tr>
<tr>
<td style="text-align:center">패키지 업데이트</td>
<td style="text-align:center">npm update package-name</td>
</tr>
<tr>
<td style="text-align:center">버전 확인</td>
<td style="text-align:center">npm -v</td>
</tr>
<tr>
<td style="text-align:center">npm 명령어 설명 참조</td>
<td style="text-align:center">npm help <command></td>
</tr>
</tbody>
</table>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Node-js/">Node.js</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Node-js/">Node.js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Package-json/">Package.json</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/">Next</a>
  </nav>

</section>
          <aside id="sidebar">
  
    <div style="margin: 20px 0;">
	<div id="search-form-wrap">

    <form class="search-form">
        <label style="width: 72%;">
            <span class="screen-reader-text">Search for:</span>
            <input type="search" class="search-field" style="height: 36px; width: 100%;" placeholder=" Search…" value="" name="s" title="Search for:">
        </label>
        <input type="submit" class="search-form-submit" value="Search">
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
</div>
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Connect With Us</h3>
    <div class="widget widget_athemes_social_icons">

    	<ul class="clearfix widget-social-icons">   
    	
   			<li><a href="https://github.com/cheonmro" title="Github"><i class="fa fa-github" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Weibo"><i class="fa fa-weibo" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Twitter"><i class="fa fa-twitter" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Facebook"><i class="fa fa-facebook" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Google-plus"><i class="fa fa-google-plus" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Instagram"><i class="fa fa-instagram" aria-hidden="true"></i></a></li> 

   		
   		</ul>


   		<!--
   		<ul class="clearfix widget-social-icons">   		
   		<li class="widget-si-twitter"><a href="http://twitter.com" title="Twitter"><i class="ico-twitter"></i></a></li> 
		<li class="widget-si-facebook"><a href="http://facebook.com" title="Facebook"><i class="ico-facebook"></i></a></li>
			<li class="widget-si-gplus"><a href="http://plus.google.com" title="Google+"><i class="ico-gplus"></i></a></li>
			<li class="widget-si-pinterest"><a href="http://pinterest.com" title="Pinterest"><i class="ico-pinterest"></i></a></li>
			<li class="widget-si-flickr"><a href="http://flickr.com" title="Flickr"><i class="ico-flickr"></i></a></li>
			<li class="widget-si-instagram"><a href="http://instagram.com" title="Instagram"><i class="ico-instagram"></i></a></li>
		</ul> -->

    </div>
  </div>


  
    
  <div class="widget_athemes_tabs">
    <ul id="widget-tab" class="clearfix widget-tab-nav">
      <li class="active"><a>Recent Posts</a></li>
    </ul>
    <div class="widget">
      <ul>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2019/03/08/react-lifecycle-api/">Lifecycle API</a></h6>
              <span>March 8, 2019</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2019/01/02/modules/">Modules</a></h6>
              <span>January 2, 2019</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2019/01/01/arrow-function/">Arrow Function</a></h6>
              <span>January 1, 2019</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2019/01/01/computed-methods/">Computed vs. Methods vs. Watch</a></h6>
              <span>January 1, 2019</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2019/01/01/vue-routing/">Vue에서 Routing 사용하는 방법</a></h6>
              <span>January 1, 2019</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/12/27/axios-and-vue/">Vue에서 Axios 사용하는 방법</a></h6>
              <span>December 27, 2018</span>
            </div>

          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithms/">Algorithms</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Blockchain-Market/">Blockchain(Market)</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Blockchain-Tech/">Blockchain(Tech)</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Computer-Science/">Computer Science</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ES6/">ES6</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Javascript/">Javascript</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Network/">Network</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node-js/">Node.js</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/">Vue</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/typescript/">typescript</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>


  
</aside>
        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/about" class="mobile-nav-link">Me &amp; Projects</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2019 Hexo All Rights Reserved.
        
            <span id="busuanzi_container_site_uv">
              本站访客数<span id="busuanzi_value_site_uv"></span>人次  
              本站总访问量<span id="busuanzi_value_site_pv"></span>次
            </span>
          
      </div>
      <div class="site-credit">
        Theme by <a href="https://github.com/iTimeTraveler/hexo-theme-hipaper" target="_blank">hipaper</a>
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
    
</script>
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>


<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-125478847-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->






  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
</body>
</html>
