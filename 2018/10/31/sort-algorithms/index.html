<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>정렬(sort) 알고리즘 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="sort algorithms" />
  
  
  
  
  <meta name="description" content="정렬 알고리즘 정렬 알고리즘이란, 원소들을 번호순이나 사전 순서와 같이 일정한 순서대로 열거하는 알고리즘이다. 정렬 알고리즘은 명함을 어떤 순서로 정리할까?와 같은 문제이다.1만장의 명함이 있고, 가나다 순으로 정리되어 있는데, 어느 날 새로운 명함을 받았다면, 그 명함을 가나다 순에 맞춰 끼워 넣어야 한다면 그 뒤에 명함들은 한 칸씩 뒤로 밀어야 하는 번">
<meta name="keywords" content="sort algorithms">
<meta property="og:type" content="article">
<meta property="og:title" content="정렬(sort) 알고리즘">
<meta property="og:url" content="https://cheonmro.github.io/2018/10/31/sort-algorithms/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="정렬 알고리즘 정렬 알고리즘이란, 원소들을 번호순이나 사전 순서와 같이 일정한 순서대로 열거하는 알고리즘이다. 정렬 알고리즘은 명함을 어떤 순서로 정리할까?와 같은 문제이다.1만장의 명함이 있고, 가나다 순으로 정리되어 있는데, 어느 날 새로운 명함을 받았다면, 그 명함을 가나다 순에 맞춰 끼워 넣어야 한다면 그 뒤에 명함들은 한 칸씩 뒤로 밀어야 하는 번">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2018-10-31T06:54:39.373Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="정렬(sort) 알고리즘">
<meta name="twitter:description" content="정렬 알고리즘 정렬 알고리즘이란, 원소들을 번호순이나 사전 순서와 같이 일정한 순서대로 열거하는 알고리즘이다. 정렬 알고리즘은 명함을 어떤 순서로 정리할까?와 같은 문제이다.1만장의 명함이 있고, 가나다 순으로 정리되어 있는데, 어느 날 새로운 명함을 받았다면, 그 명함을 가나다 순에 맞춰 끼워 넣어야 한다면 그 뒤에 명함들은 한 칸씩 뒤로 밀어야 하는 번">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >
  <link rel="stylesheet" href="/css/fashion.css" >
  <link rel="stylesheet" href="/css/glyphs.css" >

</head>



  <body data-spy="scroll" data-target="#toc" data-offset="50">


  


<header id="allheader" class="site-header" role="banner"
   >
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" rel="home" >
                <img style="margin-bottom: 10px;"  width="124px" height="124px" alt="Hike News" src="https://hexo.io/logo.svg">
              </a>
            
          </h1>

          

          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>

            <div class="clearfix sf-menu">
              <ul id="main-nav" class="menu sf-js-enabled sf-arrows"  style="touch-action: pan-y;">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/">Home</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/categories">Categories</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/about">me &amp; projects</a> </li>
                    
              </ul>
            </div>
          </nav>

      </div>
  </div>
</header>


  <div id="container">
    <div id="wrap">

      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-sort-algorithms" style="width: 66%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      정렬(sort) 알고리즘
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/10/31/sort-algorithms/" class="article-date">
	  <time datetime="2018-10-31T06:54:39.000Z" itemprop="datePublished">October 31, 2018</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Computer-Science/">Computer Science</a>

      
	<!-- <span id="busuanzi_container_page_pv">
	  本文总阅读量<span id="busuanzi_value_page_pv"></span>次
	</span> -->

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="정렬-알고리즘"><a href="#정렬-알고리즘" class="headerlink" title="정렬 알고리즘"></a>정렬 알고리즘</h1><hr>
<p><strong>정렬 알고리즘</strong>이란, 원소들을 번호순이나 사전 순서와 같이 일정한 순서대로 열거하는 알고리즘이다.</p>
<p>정렬 알고리즘은 명함을 어떤 순서로 정리할까?와 같은 문제이다.<br>1만장의 명함이 있고, 가나다 순으로 정리되어 있는데, 어느 날 새로운 명함을 받았다면, 그 명함을 가나다 순에 맞춰 끼워 넣어야 한다면 그 뒤에 명함들은 한 칸씩 뒤로 밀어야 하는 번거로움이 있다. 밀리는 명함이 1장일 수도 있고, 수천장일 수도 있다. 즉, 가나다 순으로 명함을 정리해두는 것이 머릿속에서는 편리하다고 생각되더라도 실제 관리하기에는 여간 불편한 것이 아니다.</p>
<p>정렬 알고리즘에서 중요한 점은 2가지다.</p>
<ul>
<li>어떤 데이터를 사용하는가?</li>
<li>어떤 정렬 조건을 사용하는가?</li>
</ul>
<p>데이터를 정렬할 때, 무조건 하나의 정렬 알고리즘을 사용하는 것은 바람직하지 않다. 데이터를 정렬할 여러 가지 조건(데이터의 개수, 사용할 수 있는 메모리의 양 등)을 분석해서 가장 합당한 정렬 알고리즘을 선택하는 지혜가 필요하다.</p>
<p><br></p>
<h1 id="정렬-알고리즘-종류"><a href="#정렬-알고리즘-종류" class="headerlink" title="정렬 알고리즘 종류"></a>정렬 알고리즘 종류</h1><hr>
<ul>
<li>퀵 정렬 알고리즘(Quick Sort)</li>
<li>병합 정렬 알고리즘(Merge Sort)</li>
<li>버블 정렬 알고리즘(Bubble Sort)</li>
<li>선택 정렬 알고리즘(Selection Sort)</li>
</ul>
<p><br></p>
<h2 id="퀵-정렬-알고리즘-Quick-Sort"><a href="#퀵-정렬-알고리즘-Quick-Sort" class="headerlink" title="퀵 정렬 알고리즘(Quick Sort)"></a>퀵 정렬 알고리즘(Quick Sort)</h2><hr>
<p><strong>퀵 정렬 알고리즘</strong>: 리스트의 한 요소를 피벗(Pivot: 기준값)으로 선정한 다음, 피벗보다 작은 요소를 하위(왼쪽) 리스트로, 피벗보다 큰 요소를 상위(오른쪽) 리스트로 이동시키는 알고리즘이다.</p>
<p>예를 들어, 배열 [3, 9, 4, 7, 5, 0, 1, 6, 8, 2] 있다고 해보자. 여기서 피벗을 5라고 정하고, 5보다 작은 요소를 왼쪽으로, 큰 요소를 오른쪽으로 보내는 작동 방식에 대해 알아보자.</p>
<ul>
<li>왼쪽 맨끝을 s(시작 포인트), 오른쪽 맨끝을 e(끝 포인트)라고 하자.</li>
<li>s부터 피벗과 비교해서, s가 피벗보다 작으면 s는 오른쪽으로 한칸 이동후, 피벗과 비교한다.</li>
<li>만약, s가 피벗보다 크면 잠깐 멈춰있고, e를 피벗과 비교하기 시작한다.</li>
<li>e가 피벗보다 크면 e는 왼쪽으로 한칸 이동후, 피벗과 다시 비교한다.</li>
<li>만약, e가 피벗보다 작으면 잠깐 멈춘후, 아까 멈춘 s의 값과 서로 바꾼다.(swap)</li>
<li>위 배열에서 s는 9가 되고, e는 2가 된다. 이 두 개의 숫자를 서로 바꾼다.</li>
<li>그럼, [3, 2, 4, 7, 5, 0, 1, 6, 8, 9] 배열이 된다.</li>
<li>그리고, 다시 s를 한칸 오른쪽으로 이동후, 피벗과 비교한다.</li>
<li>만약, s의 값이 피벗보다 클 경우, 잠깐 멈춰있고, e도 피벗과 비교하기 시작한다.</li>
<li>이런식으로 1바퀴를 돌게 되면 배열은 다음과 같다. [3, 2, 4, 1, 0, 5, 7, 6, 8, 9]</li>
<li>s와 e가 서로 정한 범위를 벗어나게 되면, 이 루프가 끝나게 된다.</li>
<li>그러면 총 2개의 partition(smaller/bigger)이 만들어진다.</li>
<li>그 다음에는, 양쪽 배열(partition)을 가지고 반복적으로 퀵 정렬 함수를 재귀적으로 호출하면, partition의 값이 1개가 될 때까지 계속적으로 반복해서 작은 값과 큰값의 위치를 바꾸게 된다.</li>
<li>이때, partition이 왼쪽/오른쪽에 1개면 더이상 재귀호출을 하지 않는다.</li>
</ul>
<p>퀵 정렬 알고리즘은 큰 데이터 집합을 가장 빨리 정렬할 수 있는 알고리즘이다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function qSort(arr) &#123;</span><br><span class="line">    if (arr.length == 0) &#123;</span><br><span class="line">        return [];</span><br><span class="line">    &#125;</span><br><span class="line">    let left = [];</span><br><span class="line">    let right = [];</span><br><span class="line">    const pivot = arr[0];</span><br><span class="line">    for (let i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (arr[i] &lt; pivot) &#123;</span><br><span class="line">           left.push(arr[i]);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">           right.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return qSort(left).concat(pivot, qSort(right));</span><br><span class="line">&#125;</span><br><span class="line">console.log(qSort([3, 9, 4, 7, 0, 1, 5, 8, 6, 2])); // [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// random input array for test</span><br><span class="line">var a = [];</span><br><span class="line">for (var i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">   a[i] = Math.floor((Math.random()*100)+1);</span><br><span class="line">&#125;</span><br><span class="line">console.log(a);</span><br><span class="line">console.log(qSort(a));</span><br></pre></td></tr></table></figure></p>
<p>위 코드의 시간복잡도를 계산하면 T(n) = nlogn 이다. 이것을 Big-O 표기법으로 나타내면 O(nlogn)이다. partion을 나누는 수가 n번인데, 이는 partion을 계속 나누다 보면, 결국 낱개가 될 때까지 나누기 때문이다. 그런데 1번 나누면, 2번째 나눌 때는 전체에서 2개로 나눈 결과를 가지고 또 나누는 것이기 때문에, 검색해야하는 데이터의 양이 줄어들었다. 마치, 이진 탐색 알고리즘과 같다. 그래서 logn번 검색하게 된다. 즉, n * logn = nlogn인 시간복잡도가 된다.</p>
<p>그러나, 예외도 있다. partion을 나누기 위한 pivot(기준값)이 전체 배열에서 최소값/최대값일 경우, 시간복잡도는 O(n^2)이 된다. 예를 들어, pivot(기준값)이 전체 배열에서 최소값일 경우, 제일 왼쪽으로 들어가고, 나머지 데이터에서 pivot(기준값)이 또 최소값이어서 이런식으로 된다면, 결국 모든 데이터를 모두 돌게 되어, 시간복잡도가 O(n^2)dl 된다. 하지만, 확률적으로 이런 경우는 거의 없기 때문에, 보통의 시간복잡도는 O(n^2)이 된다.</p>
<p><br></p>
<h2 id="병합-정렬-알고리즘-Merge-Sort"><a href="#병합-정렬-알고리즘-Merge-Sort" class="headerlink" title="병합 정렬 알고리즘(Merge Sort)"></a>병합 정렬 알고리즘(Merge Sort)</h2><hr>
<p><strong>병합 정렬 알고리즘</strong>: 함수가 호출 될때마다, 절반씩 잘라서 재귀적으로 함수를 호출하고 맨끝에 제일 작은 조각부터 두 개씩 병합해서 정렬된 배열을 병합해나가는 방식이 병합 정렬 알고리즘이다. 이미 정렬되어 있는 데이터들을 하나로 합해서 정렬하는 방법. 이러한 정렬 방법은 데이터들을 정렬하는 경우에도 사용되지만 파일에 정렬되어 있는 데이터들을 하나로 합쳐서 정렬하는 경우에도 종종 사용된다. 이미 정렬되어 있는 데이터 그룹들 혹은 묶음들을 하나로 합할 때 사용할 수 있다.</p>
<p>병합 정렬 알고리즘을 사용하는 경우 배열 하나에 저장된, 정렬되지 않은 데이터들을 어떤 방식으로 정렬하는 지 알아보자.</p>
<p>예)<br>정렬되지 않은 데이터가 있다고 해보자. 하나의 데이터 배열을 여러 개로 나누어서, 나중에 병합 하기 위해 묶는데, 이 묶은 데이터 그룹을 런(Run)이라고 한다. 2-way 방식은 2개씩 그룹으로 묶는다. 일단 2개씩 묶으면, 각 그룹별로 정렬을 한다. 예를 들어, 6과 1이 하나의 그룹으로 묶였다면, 1이 왼쪽에 오고, 6이 오른쪽에 오는 식으로 정렬을 한다. 그 다음으로는 2개의 런을 묶어서 하나의 런으로 합하도록 정렬한다. 만약 2, 3 런과 5, 7 런이 하나의 런으로 합쳐진 다음, 2, 3, 5, 7 사이에서 정렬이 된다. 이렇게 런(그룹)을 계속 합쳐나가면서 하나의 런으로 모두 합쳐 정렬하는 방식을 병합 정렬 알고리즘이라고 한다.</p>
<p>병합 정렬의 핵심은 1부터 하나의 런에 들어가는 데이터의 수를 2의 배수 기준으로 늘려서 병합하는 과정을 반복하는 것이다. 이와 같이 반복해서 병합하게 되면 결국 전체 데이터를 모두 정렬하게 되는 결과를 얻을 수 있다.</p>
<p>병합 정렬 알고리즘의 성능은 수치적으로만 보면 퀵 정렬 알고리즘과 비슷하다. 퀵 정렬 알고리즘이나 병합 정렬 알고리즘이나 데이터를 나눈 후에 재귀 호출을 사용하기 때문이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 퀵정렬과 마찬가지로 분할 정복 알고리즘중 하나이다.</span><br><span class="line">function MergeSort(arr) &#123;</span><br><span class="line">  const len = arr.length;</span><br><span class="line">  if(len == 1) &#123;</span><br><span class="line">    return arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const middle = Math.floor(len / 2);</span><br><span class="line">  const left = arr.slice(0, middle);</span><br><span class="line">  const right = arr.slice(middle, len);</span><br><span class="line"></span><br><span class="line">  function merge(left, right) &#123;</span><br><span class="line">    let result = [];</span><br><span class="line">    while(left.length &amp;&amp; right.length) &#123;</span><br><span class="line">      if( left[0] &lt;= right[0] ) &#123;</span><br><span class="line">        result.push(left.shift());</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        result.push(right.shift());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while(left.length) &#123;</span><br><span class="line">      result.push(left.shift());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while(right.length) &#123;</span><br><span class="line">      result.push(right.shift());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return merge(MergeSort(left), MergeSort(right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위 코드의 시간복잡도를 계산하면 T(n) = nlogn 이다. 이것을 Big-O 표기법으로 나타내면 O(nlogn)이다. n개 만큼씩 logn번 돌기 때문에, 병합 정렬 알고리즘의 시간복잡도는 O(nlogn)이 된다. partition이 낱개가 될 때까지 쪼개지니까 n번 호출에, 1번 호출당 검색해야하는 데이터의 양이 절반씩 줄어드니까 logn이다. 따라서 n * logn = nlogn 시간복잡도가 된다. nlogn 시간복잡도는 이진 탐색 알고리즘에서 한 번 돌 때마다 검색 영역에 절반씩 떨어지는 것과 같은 원리이다.</p>
<p>병합 정렬 알고리즘은 물리적으로 배열의 가운데 값으로 partition을 나누기 때문에 최악의 경우에도 시간복잡도는 O(nlogn)이다. 퀵 정렬 알고리즘으로 따지면, pivot(기준값)을 잘 골랐을 때랑 비슷하다. 퀵 정렬 알고리즘도 최악의 경우가 아니라면, 병합 정렬 알고리즘과 같은 시간복잡도는 O(nlogn)이다.</p>
<p>하지만, 병합 정렬 알고리즘은 실행시에 별도의 저장공간을 필요로 하기 때문에, 공간을 사용할 수 없는 경우에는 퀵 정렬 알고리즘을 사용해야 한다.</p>
<p><br></p>
<h2 id="버블-정렬-알고리즘-Bubble-Sort"><a href="#버블-정렬-알고리즘-Bubble-Sort" class="headerlink" title="버블 정렬 알고리즘(Bubble Sort)"></a>버블 정렬 알고리즘(Bubble Sort)</h2><hr>
<p><strong>버블 정렬 알고리즘</strong>: 순차적으로 바로 옆에 있는 데이터와 비교해서 옆의 데이터가 크면 자신과 위치를 바꾼다. 즉, 첫 번째 데이터가 가장 크다면 계속 옆에 있는 데이터와 자리를 바꾸면서 해당 데이터는 결국 맨 끝으로 이동하게 된다. 그리고 두 번째 위치에 있는 데이터를 또다시 옆에 있는 데이터와 비교한다. 이와 같은 과정을 마지막 데이터의 바로 전 데이터까지 반복해서 실행한다. 이 형태가 마치 버블이 부글부글 올라가는 것과 같다고 하여 버블 정렬 알고리즘이라고 한다.</p>
<p>예를 들어, [3, 5, 4, 2, 1] 배열이 있으면, 먼저 3과 5를 비교해서 3이 5보다 크면 둘을 바꾼다. 그런데 여기서는 5가 크므로 그대로 둔다. 그 다음은 5와 4를 비교한다. 이때, 5가 4보다 크므로 그 둘을 바꾼다. 그럼 [3, 4, 5, 2, 1] 배열이 이렇게 바뀐다. 이런식으로 비교하면 결국 5가 제일 마지막으로 이동하게 된다. 즉, [3, 4, 2, 1, 5] 배열이 된다. 그럼 가장 큰 수인 5가 배열에 제일 오른쪽으로 이동하게 되고, 다시 맨 처음부터 이웃 숫자끼리 비교한다. 이런식으로 가장 큰 수를 오른쪽으로 이동시켜 정렬하는 방식을 버블 정렬 알고리즘이라고 한다.</p>
<p>성능이 좋은 편이 아니라, 자주 사용되지는 않는다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 스왑 헬퍼 =&gt; 배열의 위치를 바꾼다.</span><br><span class="line">function swap(arr, index1, index2) &#123;</span><br><span class="line">  let temp = arr[index1];</span><br><span class="line">  arr[index1] = arr[index2];</span><br><span class="line">  arr[index2] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 버블 정렬은 서로 이웃한 데이터들을 비교하며 가장 큰 데이터를 가장 뒤로 보내며 정렬하는 방식</span><br><span class="line">function BubbleSort(arr) &#123;</span><br><span class="line">  let len = arr.length;</span><br><span class="line">  for(let outer = len; outer &gt; 1; outer--) &#123;</span><br><span class="line">    for(let inner = 0; inner &lt; outer; inner++) &#123;</span><br><span class="line">      if( arr[inner] &gt; arr[inner + 1]) &#123;</span><br><span class="line">        swap(arr, inner, inner+1);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return arr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>위 코드의 시간복잡도를 계산하면 T(n) = n^2 이다. 이것을 Big-O 표기법으로 나타내면 O(n^2)이다. 앞에서부터 한 개씩 뒤로 가면서 전체 배열 데이터를 돌기 때문에 n^2 만큼 시간이 걸린다.</p>
<p><br></p>
<h2 id="선택-정렬-알고리즘-Selection-Sort"><a href="#선택-정렬-알고리즘-Selection-Sort" class="headerlink" title="선택 정렬 알고리즘(Selection Sort)"></a>선택 정렬 알고리즘(Selection Sort)</h2><hr>
<p><strong>선택 정렬 알고리즘</strong>: 데이터의 처음부터 끝까지 쭉 훑어가면서 가장 작은 값을 찾아 그 값을 첫 번째 데이터와 자리를 바꾸고, 두 번째로 작은 데이터를 찾아 두 번째의 데이터와 자리를 바꾸는 방법으로 구현하는 정렬 알고리즘이다.</p>
<p>예를 들어, [3, 5, 4, 2, 1] 배열이 있으면, 변수 min = 3으로 할당하고, 그 다음 데이터인 5부터 하나씩 비교해 나간다. 이때, 가장 작은 값이 1 이므로 맨 앞에 있는 3과 1을 바꾼다. 그리고, 다시 두번째 요소인 5부터 오른쪽으로 하나씩 비교하면서 가장 작은 값을 찾아 5와 바꾼다. 이런식으로 정렬하는 방식이 선택 정렬 알고리즘이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 스왑 헬퍼 =&gt; 배열의 위치를 바꾼다.</span><br><span class="line">function swap(arr, index1, index2) &#123;</span><br><span class="line">  let temp = arr[index1];</span><br><span class="line">  arr[index1] = arr[index2];</span><br><span class="line">  arr[index2] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 선택 정렬은 정렬되지 않은 데이터들에 대해 가장 작은 데이터를 찾아 가장 앞의 데이터와 교환해나가는 방식</span><br><span class="line">function SelectionSort(arr) &#123;</span><br><span class="line">  let min;</span><br><span class="line">  for(let outer = 0; outer &lt; arr.length -1; ++outer) &#123;</span><br><span class="line">    min = outer;</span><br><span class="line">    for(let inner = outer + 1; inner &lt; arr.length; ++inner) &#123;</span><br><span class="line">      if( arr[inner] &lt; arr[min] ) &#123;</span><br><span class="line">        min = inner;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    swap(arr, outer, min);</span><br><span class="line">  &#125;</span><br><span class="line">  return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위 코드의 시간복잡도를 계산하면 T(n) = n^2 이다. 이것을 Big-O 표기법으로 나타내면 O(n^2)이다. 앞에서도 한칸씩 가면서 갈때마다 각 배열 요소를 한번씩 다시 돌기 때문에, n^2 만큼 시간이 걸린다.</p>
<p><br></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Computer-Science/">Computer Science</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/sort-algorithms/">sort algorithms</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/10/31/how-browser-works/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          브라우저 동작원리
        
      </div>
    </a>
  
  
    <a href="/2018/10/31/search-algorithms/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">탐색(search) 알고리즘</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">Contents</strong>
    
      <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#정렬-알고리즘"><span class="nav-number">1.</span> <span class="nav-text">정렬 알고리즘</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#정렬-알고리즘-종류"><span class="nav-number">2.</span> <span class="nav-text">정렬 알고리즘 종류</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#퀵-정렬-알고리즘-Quick-Sort"><span class="nav-number">2.1.</span> <span class="nav-text">퀵 정렬 알고리즘(Quick Sort)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#병합-정렬-알고리즘-Merge-Sort"><span class="nav-number">2.2.</span> <span class="nav-text">병합 정렬 알고리즘(Merge Sort)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#버블-정렬-알고리즘-Bubble-Sort"><span class="nav-number">2.3.</span> <span class="nav-text">버블 정렬 알고리즘(Bubble Sort)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#선택-정렬-알고리즘-Selection-Sort"><span class="nav-number">2.4.</span> <span class="nav-text">선택 정렬 알고리즘(Selection Sort)</span></a></li></ol></li></ol>
    
    </div>
  </aside>
</section>
        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/about" class="mobile-nav-link">Me &amp; Projects</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2018 Hexo All Rights Reserved.
        
            <span id="busuanzi_container_site_uv">
              本站访客数<span id="busuanzi_value_site_uv"></span>人次  
              本站总访问量<span id="busuanzi_value_site_pv"></span>次
            </span>
          
      </div>
      <div class="site-credit">
        Theme by <a href="https://github.com/iTimeTraveler/hexo-theme-hipaper" target="_blank">hipaper</a>
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
    
</script>
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>


<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-125478847-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->






  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
</body>
</html>
