<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Page 3 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://cheonmro.github.io/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >
  <link rel="stylesheet" href="/css/fashion.css" >
  <link rel="stylesheet" href="/css/glyphs.css" >

</head>



  <body>


  


<header id="allheader" class="site-header" role="banner"
   >
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" rel="home" >
                <img style="margin-bottom: 10px;"  width="124px" height="124px" alt="Hike News" src="https://hexo.io/logo.svg">
              </a>
            
          </h1>

          

          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>

            <div class="clearfix sf-menu">
              <ul id="main-nav" class="menu sf-js-enabled sf-arrows"  style="touch-action: pan-y;">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/">Home</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/categories">Categories</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/about">me &amp; projects</a> </li>
                    
              </ul>
            </div>
          </nav>

      </div>
  </div>
</header>


  <div id="container">
    <div id="wrap">

      <div id="content" class="outer">
        
          <section id="main">
  
    <article id="post-redux-saga"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/03/17/redux-saga/">Redux-Saga</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/03/17/redux-saga/" class="article-date">
	  <time datetime="2019-03-17T12:35:33.000Z" itemprop="datePublished">March 17, 2019</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/React/">React</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Redux-Saga란-무엇인가"><a href="#Redux-Saga란-무엇인가" class="headerlink" title="Redux-Saga란 무엇인가?"></a>Redux-Saga란 무엇인가?</h1><hr>
<p><strong>Redux-saga란, side effect를 관리하기 위한 middleware이다.</strong></p>
<p>Side effect란, 애플리케이션의 부작용들(데이터 요청 등의 비동기 작업/브라우저 캐시 같은 순수하지 않은 것들)을 말한다.</p>
<p>middleware란, 액션이 dispatch 되어서 리듀서에서 이를 처리하기 전에 그 사이에서 중간자로써 지정된 특정 작업을 하는 것을 말한다.</p>
<p><br></p>
<h1 id="Redux-Saga를-왜-사용하는가"><a href="#Redux-Saga를-왜-사용하는가" class="headerlink" title="Redux-Saga를 왜 사용하는가?"></a>Redux-Saga를 왜 사용하는가?</h1><hr>
<p>비동기 처리 등 순수하게 액션만을 전달하는 것 이상으로 발생하는 상황들(side effects)을 다룰 때, 이 미들웨어를 사용한다.</p>
<p><br></p>
<h1 id="Redux-Thunk-대신에-Redux-Saga를-사용하는-이유는-무엇인가"><a href="#Redux-Thunk-대신에-Redux-Saga를-사용하는-이유는-무엇인가" class="headerlink" title="Redux-Thunk 대신에 Redux-Saga를 사용하는 이유는 무엇인가?"></a>Redux-Thunk 대신에 Redux-Saga를 사용하는 이유는 무엇인가?</h1><hr>
<p>redux-thunk를 사용하면, 비동기 처리를 Action Creator(액션 생성자 함수)에서 작성하게 되어, 로직이 복잡해진다. 기본적으로 Redux에서 Action Creator에서는 액션을 객체형태로 생성하여 dispatch 하는데, redux-thunk에서는 액션을 함수형태로 생성하여 dispatch 하여, Action Creator에 비동기처리 코드나 관련된 로직이 들어가게 된다.</p>
<p>그런데, Redux-saga는 비동기 처리를 기술하는 전용의 방식인 task로 쓰여있다. 즉, 비동기 처리를 각 saga(task)에서 명령을 내리고, 동작을 미들웨어에서 처리한다. 그래서, redux에서의 action creator에서 기존과 그대로 액션을 객체형태로 생성하여 dispatch 할 수가 있고, saga에서의 코드도 더 간단해진다. 결국, Action Creator는 본래의 모습을 되찾아, action 객체를 생성하여 돌려주는 순수한 상태로 돌아가게 된다.</p>
<p>결론적으로, Redux-Saga를 사용하게 되면, 비동기 처리를 액션 생성자로부터 분리하여 작성하기 때문에, 가독성도 좋고 콜백 처리 등에 더 수월하다.</p>
<p><br></p>
<h1 id="Redux-Saga-Architecture"><a href="#Redux-Saga-Architecture" class="headerlink" title="Redux-Saga Architecture"></a>Redux-Saga Architecture</h1><hr>
<p><img src="/images/redux-saga.webp" alt="Redux-Saga Architecture"><br>출처: <a href="https://scotch.io/tutorials/build-a-media-library-with-react-redux-and-redux-saga-part-1" target="_blank" rel="noopener">Redux-Saga Architecture</a></p>
<p><br></p>
<h1 id="Redux-Saga-Flow"><a href="#Redux-Saga-Flow" class="headerlink" title="Redux-Saga Flow"></a>Redux-Saga Flow</h1><hr>
<p><img src="/images/redux-saga-flow.png" alt="Redux-Saga Architecture"><br>출처: <a href="(https://meetup.toast.com/posts/136">Redux-Saga Architecture</a>)</p>
<p>위 Flow를 정리하면 다음과 같다.</p>
<ol>
<li>어떤 비동기 액션이 dispatch 되면, Reducer에 먼저 도달한다. 정확하게는 액션이 Reducer로 지나가는 것을 본 후, Redux-Saga에 액션을 처리한다. Reducer는 순수 함수라는 규칙이 있기 때문에, 비동기 액션을 처리하지 못한다.</li>
</ol>
<ol start="2">
<li>이 비동기 액션을 Redux-Saga에 있는 watcher saga가 보고 있다가, watcher saga에 등록되어 있는 task를 수행한다. 이 watcher saga의 역할은 어떤 비동기 액션이 dispatch 되면, 어떤 task를 수행하도록 등록하는 것이다. 이때, takeEvery라는 헬퍼 이펙트를 사용하는데, 이 이펙트는 여러개의 task를 동시에 시작할 수 있다. 즉, 1개 혹은 아직 종료되지 않은 task가 있더라도 새로운 task를 시작할 수 있다.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// INCREMENT_ASYNC 액션이 Dispatch 되면 `incrementAsync`를 수행하도록 등록한다.</span><br><span class="line">export function* watchIncrementAsync() &#123;</span><br><span class="line">  yield takeEvery(INCREMENT_ASYNC, incrementAsync)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><code>incrementAsync</code>를 수행하는데, 만약 task가 2초 마다 +1씩 증가하는 함수라고 한다면, 다음과 같이 작성한다.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function* incrementAsync(action) &#123;</span><br><span class="line">  yield delay(2000)                 // 2초를 기다리고</span><br><span class="line">  yield put(&#123; type: INCREMENT &#125;)    // INCREMENT 액션을 Dispatch한다.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>위 task가 수행될 때, 먼저 첫번째 줄에 있는 delay(2000)이 yield 된다. delay는 설정된 시간 이후에 resolve를 하는 Promise 객체를 리턴하는 함수이다. 이 Promise가 미들웨어에 yield 될때, 미들웨어는 Promise가 끝날때까지 Saga를 일시정지 시킨다.(generator 함수의 특징) 즉, 이 부분은 동기적으로 동작한다.</li>
</ol>
<ol start="5">
<li>2초후, Promise가 한번 resolve 되면, 미들웨어는 saga(task)를 다시 작동시키면서, 다음 yield까지 코드를 실행한다. 이런 방식으로 saga(task)에서 1개씩 yield되고, 그 yield 된 것이 미들웨어에 의해 동작이 완료되면, 그때 그 다음줄에 있는 객체가 yield된다.</li>
</ol>
<ol start="6">
<li>어떤 객체를 yield할때, 앞에 오는 것들(put, call 등)을 이펙트라고 한다. 이펙트란, 미들웨어에 의해 수행되는 명령을 담고있는 간단한 자바스크립트 객체를 말한다. 미들웨어가 saga에 의해 yield 된 이펙트를 받을때, saga는 이펙트가 수행될때까지 정지되어 있다.</li>
</ol>
<ol start="7">
<li>saga에서 put을 통해 객체를 dispatch하면, 이 객체는 reducer로 가게된다.</li>
</ol>
<ol start="8">
<li>두 saga를 모두 한번에 실행하게 해주기 위해, rootSaga를 이용해 사용한다.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 모든 Saga들을 한번에 시작하기 위한 단일 entry point 이다.</span><br><span class="line">export default function* rootSaga() &#123;</span><br><span class="line">  yield all([</span><br><span class="line">    incrementAsync(),</span><br><span class="line">    watchIncrementAsync()</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="Redux-Saga-사용방법"><a href="#Redux-Saga-사용방법" class="headerlink" title="Redux-Saga 사용방법"></a>Redux-Saga 사용방법</h1><hr>
<p>Redux-Saga를 사용하는 방법은 다음과 같다.</p>
<ul>
<li>saga 미들웨어 작성(sagas.js)<ul>
<li>비동기 처리를 위한 task 작성(제너레이터 함수) - worker saga</li>
<li>각각의 어떤 비동기 액션을 처리하기 위해 watch 함수를 작성하고, 그 안에 takeEvery 이펙트 펠어 함수를 사용 - watcher saga</li>
<li>모든 saga들을 한번에 실행하기 entry point 작성 - rootSaga 작성<ul>
<li>rootSaga에 들어있는 두 saga가 호출된 결과의 배열을 yield 한다. 이것은 생성된 두 제너레이터가 병렬로 시작된다는 것을 의미.</li>
</ul>
</li>
</ul>
</li>
<li>Saga 미들웨어를 Redux 스토어에 연결(main.js)<ul>
<li>applyMiddleware</li>
<li>sagaMiddleware.run 등 작성</li>
</ul>
</li>
<li>비동기 호출을 위한 이벤트 등록(Counter.js)</li>
</ul>
<p>saga 미들웨어 작성(sagas.js)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// sagas.js</span><br><span class="line"></span><br><span class="line">import &#123; delay &#125; from &apos;redux-saga&apos;</span><br><span class="line">import &#123; put, takeEvery &#125; from &apos;redux-saga/effects&apos;</span><br><span class="line"></span><br><span class="line">// watcher saga</span><br><span class="line">export function* watchIncrementAsync() &#123;</span><br><span class="line">  yield takeEvery(INCREMENT_ASYNC, incrementAsync)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// worker saga</span><br><span class="line">function* incrementAsync(action) &#123;</span><br><span class="line">  yield delay(2000)</span><br><span class="line">  yield put(&#123; type: INCREMENT &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// rootSaga</span><br><span class="line">export default function* rootSaga() &#123;</span><br><span class="line">  yield all([</span><br><span class="line">    incrementAsync(),</span><br><span class="line">    watchIncrementAsync()</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Saga 미들웨어를 Redux 스토어에 연결(main.js)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line">import &#123; createStore, applyMiddleware &#125; from &apos;redux&apos;</span><br><span class="line">import createSagaMiddleware from &apos;redux-saga&apos;</span><br><span class="line"></span><br><span class="line">import rootSaga from &apos;./sagas&apos;</span><br><span class="line"></span><br><span class="line">const sagaMiddleware = createSagaMiddleware()</span><br><span class="line">const store = ...</span><br><span class="line">sagaMiddleware.run(rootSaga)</span><br></pre></td></tr></table></figure>
<p>비동기 호출을 위한 이벤트 등록(Counter.js)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Counter.js</span><br><span class="line">const Counter = (&#123; value, onIncrementAsync &#125;) =&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button onClick=&#123;onIncrementAsync&#125;&gt;</span><br><span class="line">      Increment after 2 second</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">    &lt;hr /&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      Counter: &#123;value&#125; times</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>비동기 호출을 처리하기 위해 Redux와 연결해주는 컨테이너 컴포넌트(CounterContainer.js)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function render() &#123;</span><br><span class="line">  ReactDOM.render(</span><br><span class="line">    &lt;Counter</span><br><span class="line">      value=&#123;store.getState()&#125;</span><br><span class="line">      onIncrementAsync=&#123;() =&gt; action(&apos;INCREMENT_ASYNC&apos;)&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/React/">React</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redux-Saga/">Redux-Saga</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-what-is-redux"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/03/16/what-is-redux/">Redux</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/03/16/what-is-redux/" class="article-date">
	  <time datetime="2019-03-16T09:16:43.000Z" itemprop="datePublished">March 16, 2019</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/React/">React</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Redux란-무엇인가"><a href="#Redux란-무엇인가" class="headerlink" title="Redux란 무엇인가?"></a>Redux란 무엇인가?</h1><hr>
<p><strong>Redux란, 상태관리에 대한 라이브러리로써, 애플리케이션의 모든 컴포넌트에 대한 중앙집중식 저장소 역할을 하며, 단순히 하나의 컴포넌트가 아닌 여러 개의 컴포넌트에 적용하는 상태들을 관리하는 곳이다.</strong></p>
<p><br></p>
<h1 id="Redux를-왜-사용하는가"><a href="#Redux를-왜-사용하는가" class="headerlink" title="Redux를 왜 사용하는가?"></a>Redux를 왜 사용하는가?</h1><hr>
<p>리액트에서 기본적으로 부모 컴포넌트에서 상태를 관리하고, 자식으로 상태를 전달한다. 그러나, 앱 규모가 커지면, 데이터가 많고, 유지보수가 힘들다. Redux를 사용하면, 상태값을 컴포넌트에 종속시키지 않고, 상태 관리를 컴포넌트 바깥에서 관리가 가능하다.</p>
<p><br></p>
<h1 id="Redux-필수-개념"><a href="#Redux-필수-개념" class="headerlink" title="Redux 필수 개념"></a>Redux 필수 개념</h1><hr>
<ul>
<li><p><strong>Action</strong></p>
<ul>
<li><strong>Action이란, 상태에 변화를 일으킬 때 참조할 수 있는 객체이다.</strong></li>
<li>Action 객체는 필수적으로 type 이라는 값을 가지고 있어야 한다.</li>
<li>예로, { type: ‘INCREMENT’ } 라는 객체를 전달 받으면, Redux Store는 ‘상태에 값을 더해줘야 하구나’라고 생각하고 Action을 참조하게 된다.</li>
<li>type은 필수이고, 그 다음 값(예로 diff 등)은 option이다.</li>
</ul>
</li>
<li><p><strong>Reducer</strong></p>
<ul>
<li><strong>Reducer란, 액션 객체를 받으면 액션의 타입에 따라 어떻게 상태를 업데이트 하는지, 업데이트 로직을 정의하는 함수이다.</strong></li>
<li>Redux Store에는 Reducer가 있다.</li>
<li>Reducer에는 2개의 parameter가 존재한다.<ul>
<li>State: 현재 상태</li>
<li>Action: 액션 객체</li>
</ul>
</li>
<li>상태가 변하면, 구독하고 있던 컴포넌트에게 알려서, 새로운 상태로 리렌더링함.</li>
</ul>
</li>
</ul>
<p><br></p>
<h1 id="Redux-3가지-규칙"><a href="#Redux-3가지-규칙" class="headerlink" title="Redux 3가지 규칙"></a>Redux 3가지 규칙</h1><hr>
<ul>
<li><p><strong>각 애플리케이션에서는 단 1개의 Store를 사용한다.</strong></p>
</li>
<li><p><strong>상태는 읽기전용이다.</strong></p>
<ul>
<li>기존의 상태는 건들이지 않고, 새로운 상태를 생성하여 업데이트 해주는 방식으로 하면, 나중에 개발자 도구를 통해서 뒤로 돌릴 수도 있고, 다시 앞으로 돌릴 수도 있다.</li>
<li>immutable.js를 사용하여 불변성을 유지하며 상태를 관리한다.</li>
</ul>
</li>
<li><p><strong>변화를 일으키는 함수, 즉, Reducer는 순수한 함수이다.</strong></p>
<ul>
<li>순수한 함수란, 동일한 인풋이라면 언제나 동일한 아웃풋이 나오는 함수이다. 즉, 똑같은 파라미터로 호출된 리듀서 함수는 언제나 똑같은 결과값을 반환해야 한다.</li>
<li>이전 상태는 안 건들이고, 변화를 일으킨 새로운 상태 객체를 만들어서 반환한다.</li>
<li>순수 하지 않은 것, 즉 실행 할 때마다 다른 결과값이 나오는 것들은 Reducer 함수가 아닌 바깥에서 처리해야 한다.<ul>
<li>실행할 때마다 다른 결과값이 나오는 것들<ul>
<li>New Date()</li>
<li>랜덤 숫자 생성</li>
<li>네트워크에 요청</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><br></p>
<h1 id="Redux-파일-구조"><a href="#Redux-파일-구조" class="headerlink" title="Redux 파일 구조"></a>Redux 파일 구조</h1><hr>
<ul>
<li><strong>Root.js</strong> - React 앱에 Redux 적용(최상위 컴포넌트)</li>
<li><strong>컨테이너 컴포넌트(Store)</strong><ul>
<li>CounterContainer.js - Redux와 연동하는 컴포넌트</li>
</ul>
</li>
<li><strong>프레젠테이셔널 컴포넌트(View)</strong><ul>
<li>Counter.js - Counter 기능을 보여주는 View</li>
</ul>
</li>
<li><strong>Store</strong><ul>
<li><strong>modules</strong> - 기능별로 액션 및 리듀서를 각 1개 파일에 작성(하나의 파일에 모두 작성하는 것을 Ducks 구조라고 한다.)<ul>
<li>counter.js - counter 기능과 관련된 액션 및 리듀서</li>
<li>index.js - 리듀서 합치는 파일</li>
</ul>
</li>
<li><strong>configure.js</strong> - Redux 스토어를 생성하는 함수를 모듈화하여 내보내는 파일</li>
<li><strong>index.js</strong> - store를 생성하여 모듈화하여 내보내는 파일<ul>
<li>이렇게 모듈화된 스토어는 브라우저 에서만 사용되는 스토어</li>
<li>서버사이드 렌더링을 하면, configure를 통하여 그때그때 만든다.</li>
<li>이렇게 모듈화된 스토어는 리액트 app을 초기설정할 때 사용</li>
</ul>
</li>
<li><strong>actionCreators.js</strong><ul>
<li>스토어를 불러오고, 각 모듈들에서 선언했던 액션 생성함수들을 불러와서 스토어의 dispatch와 미리 바인딩 작업을 한다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><br></p>
<h1 id="Redux-Flow"><a href="#Redux-Flow" class="headerlink" title="Redux Flow"></a>Redux Flow</h1><hr>
<p><img src="/images/redux-flow2.jpg" alt="Redux Flow"><br>출처: <a href="http://slides.com/douglasnomizo/redux-saga#/2" target="_blank" rel="noopener">Redux Flow</a></p>
<p><br></p>
<h1 id="Redux-사용법"><a href="#Redux-사용법" class="headerlink" title="Redux 사용법"></a>Redux 사용법</h1><hr>
<ul>
<li><strong>Redux install: npm install redux react-redux</strong></li>
<li><strong>리액트 앱에 Redux 적용하기(Root.js)</strong><ul>
<li>리액트 앱에 Redux를 적용할 때는, react-redux에 있는 Provider를 사용</li>
</ul>
</li>
<li><strong>기능을 보여줄 화면 구성(Counter.js)</strong><ul>
<li>Counter 숫자화면<ul>
<li>증가/감소 버튼</li>
</ul>
</li>
</ul>
</li>
<li><strong>기능과 관련된 action과 reducer 작성(modules/counter.js)</strong><ul>
<li>액션 타입 정의</li>
<li>액션 생성 함수(ActionCreator) -&gt; createAction 사용</li>
<li>모듈의 초기 상태 정의</li>
<li>Reducer 정의: switch문 -&gt; handleActions 사용</li>
</ul>
</li>
<li><strong>여러 reducer가 있을 경우, 하나로 합치기(modules/index.js)</strong></li>
<li><strong>store를 만드는 함수 configure 만들어서 내보내기(store/configure.js)</strong><ul>
<li>Const store = createStore(modules)</li>
</ul>
</li>
<li><strong>위에서 만든 configure 함수를 사용하여 스토어를 만들고 내보내기(store/index.js)</strong></li>
<li><strong>Redux와 연동할 컨테이너 컴포넌트 만들고, 그 안에 프레젠테이셔널 컴포넌트인 counter.js를 리턴해서 화면에 보여주기(containers/CounterContainer.js)</strong></li>
<li><strong>이 컴포넌트를 App에 불러와 화면에 보여주기(components/App.js)</strong></li>
<li><strong>컨테이너 컴포넌트를 Redux에 연결하기(containers/CounterContainer.js)</strong><ul>
<li>mapStateToProps: props 값으로 넣어 줄 상태를 정의<ul>
<li>컴포넌트에 state로 넣어줄 props를 반환</li>
<li>컴포넌트에 넣어줄 액션 함수들을 반환</li>
</ul>
</li>
<li>mapDispatchToProps: props 값으로 넣어 줄 액션 함수들을 정의</li>
<li>Connect(): 컴포넌트를 Redux와 연동 할 때 사용</li>
</ul>
</li>
</ul>
<p><br></p>
<h1 id="Redux-Architecture"><a href="#Redux-Architecture" class="headerlink" title="Redux Architecture"></a>Redux Architecture</h1><hr>
<p><img src="/images/redux-flow.png" alt="Redux Architecture"><br>출처: <a href="https://mysullys.com/redux-flow-chart/react-redux-architecture-overview-mofed-medium-2/" target="_blank" rel="noopener">Redux Architecture</a></p>
<p><br></p>
<h3 id="실제-코드를-작성할-때-위-그림을-연상하면서-코드를-짜면-좀-더-쉬울-것이다"><a href="#실제-코드를-작성할-때-위-그림을-연상하면서-코드를-짜면-좀-더-쉬울-것이다" class="headerlink" title="실제 코드를 작성할 때, 위 그림을 연상하면서 코드를 짜면 좀 더 쉬울 것이다."></a>실제 코드를 작성할 때, 위 그림을 연상하면서 코드를 짜면 좀 더 쉬울 것이다.</h3><p><br></p>
<h1 id="Redux-코드-예제"><a href="#Redux-코드-예제" class="headerlink" title="Redux 코드 예제"></a>Redux 코드 예제</h1><hr>
<p><strong>[1] npm으로 redux를 설치한다.</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install redux react-redux</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>[2] 리액트 앱에 Redux를 적용한다.<strong></strong></strong></p>
<p>이때, react-redux에 있는 Provider를 사용한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">index.js</span><br><span class="line"></span><br><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;;</span><br><span class="line">import &#123; store &#125; from &apos;redux/store/store&apos;;</span><br><span class="line">import &#123; Provider &#125; from &apos;react-redux&apos;;</span><br><span class="line">import App from &apos;app/App.js&apos;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;/Provider&gt;</span><br><span class="line">  , document.getElementById(&apos;root&apos;));</span><br><span class="line"></span><br><span class="line">//registerServiceWorker();</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<p><strong>[3] 보여줄 화면 UI를 만든다.<strong></strong></strong></p>
<p>“KR” 또는 “EN”을 클릭하면, 각 언어에 맞게 화면이 바뀌는 화면 컴포넌트다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">Header.js</span><br><span class="line"></span><br><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import &#123;</span><br><span class="line">  routeConstants as ROUTE</span><br><span class="line">&#125; from &apos;constants/index.js&apos;;</span><br><span class="line">import &#123; Link, withRouter &#125; from &apos;react-router-dom&apos;;</span><br><span class="line">import withLanguageProps from &apos;HOC/withLanguageProps&apos;;</span><br><span class="line">import &#123; isEmpty &#125; from &apos;utils&apos;;</span><br><span class="line"></span><br><span class="line">const INIT_STATE = &#123;</span><br><span class="line">  showInfo: false,</span><br><span class="line">  toggleLanguageList: false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@withRouter</span><br><span class="line">@withLanguageProps</span><br><span class="line">class Header extends Component &#123;</span><br><span class="line"></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = INIT_STATE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123; setLanguage, language, location, I18n &#125; = this.props;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;header-wrap&quot; onClick=&#123;this.onHeaderClick&#125;&gt;</span><br><span class="line">        &lt;div className=&quot;wrap-holder&quot;&gt;</span><br><span class="line">          &#123;showHeaderItem &amp;&amp; (</span><br><span class="line">            &lt;Link to=&#123;ROUTE[&apos;home&apos;]&#125;&gt;&lt;p className=&quot;logo&quot;&gt;&lt;span className=&quot;_img&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;/Link&gt;</span><br><span class="line">          )&#125;</span><br><span class="line"></span><br><span class="line">          // &quot;KR&quot; &amp; &quot;EN&quot; 클릭 View</span><br><span class="line">          &lt;div className=&quot;language-holder&quot;&gt;</span><br><span class="line">            &lt;span onClick=&#123;() =&gt; setLanguage(&apos;kr&apos;)&#125; className=&#123;language === &apos;kr&apos; ? &apos;on&apos; : &apos;&apos;&#125;&gt;KR&lt;/span&gt;</span><br><span class="line">            &lt;span className=&quot;dot&quot;&gt;·&lt;/span&gt;</span><br><span class="line">            &lt;span onClick=&#123;() =&gt; setLanguage(&apos;en&apos;)&#125; className=&#123;language === &apos;en&apos; ? &apos;on&apos; : &apos;&apos;&#125;&gt;EN&lt;/span&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Header;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<p><strong>[4] 액션타입과 액션생성자 함수를 만든다.<strong></strong></strong></p>
<p>액션타입은 다음과 같다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">actionTypes.js</span><br><span class="line"></span><br><span class="line">const actionTypes = &#123;</span><br><span class="line"></span><br><span class="line">// globalActions</span><br><span class="line">  setLanguage: &apos;SET_LANGUAGE&apos;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default actionTypes;</span><br></pre></td></tr></table></figure></p>
<p>액션생성자 함수는 다음과 같다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import actionTypes from &apos;redux/actionTypes/actionTypes&apos;;</span><br><span class="line"></span><br><span class="line">export function setLanguage(lan) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    type: actionTypes.setLanguage,</span><br><span class="line">    payload: lan</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<p><strong>[5] Reducer 함수를 만든다.<strong></strong></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">globalReducer.js</span><br><span class="line"></span><br><span class="line">import actionTypes from &apos;redux/actionTypes/actionTypes&apos;;</span><br><span class="line"></span><br><span class="line">const initialState = &#123;</span><br><span class="line">  language: &apos;en&apos;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function globalReducer(state = initialState, action) &#123;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case actionTypes.setLanguage:</span><br><span class="line">      return Object.assign(&#123;&#125;, state, &#123;</span><br><span class="line">        language: action.payload</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    default:</span><br><span class="line">      return state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>[6] store를 만드는 함수를 만들고, 내보낸다.<strong></strong></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">store.js</span><br><span class="line"></span><br><span class="line">import &#123; createStore, applyMiddleware, compose &#125; from &apos;redux&apos;;</span><br><span class="line">import createSagaMiddleware from &apos;redux-saga&apos;;</span><br><span class="line">import rootReducer from &apos;redux/reducers/rootReducer&apos;;</span><br><span class="line">import rootSaga from &apos;redux/sagas/rootSaga&apos;;</span><br><span class="line">import persistState from &apos;redux-localstorage&apos;;</span><br><span class="line">import &#123; composeWithDevTools &#125; from &apos;remote-redux-devtools&apos;;</span><br><span class="line"></span><br><span class="line">const generateStore = (port) =&gt; &#123;</span><br><span class="line">  const sagaMiddleware = createSagaMiddleware();</span><br><span class="line">  const composeEnhancers = composeWithDevTools(&#123; realtime: true, hostname: &apos;localhost&apos;, port: port &#125;);</span><br><span class="line">  const composeFunc = process.env.NODE_ENV === &apos;production&apos; ? compose : composeEnhancers;</span><br><span class="line">  const store = createStore(rootReducer, &#123;&#125;, composeFunc(</span><br><span class="line">    applyMiddleware(sagaMiddleware),</span><br><span class="line">    persistState(null, &#123;</span><br><span class="line">      slicer: (paths) =&gt; (state) =&gt; &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          global: state[&apos;global&apos;],</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">  )</span><br><span class="line">  );</span><br><span class="line">  sagaMiddleware.run(rootSaga);</span><br><span class="line">  return store</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const store = generateStore(8000);</span><br><span class="line"></span><br><span class="line">export &#123;</span><br><span class="line">  store</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>[7] rootReducer를 만든다.<strong></strong></strong></p>
<p>rootReducer는 모든 Reducer들을 한번에 모아놓은 파일이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import &#123; combineReducers &#125; from &apos;redux&apos;;</span><br><span class="line">import &#123; globalReducer &#125; from &apos;redux/reducers/globalReducer&apos;</span><br><span class="line">import &#123; signupReducer &#125; from &apos;redux/reducers/signupReducer&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const rootReducer = combineReducers(&#123;</span><br><span class="line">  global: globalReducer,</span><br><span class="line">  signup: signupReducer,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export default rootReducer;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>[8] store.js에서 store 생성후, index.js의 Provider에 제공한다.<strong></strong></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">index.js</span><br><span class="line"></span><br><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;;</span><br><span class="line">import &#123; store &#125; from &apos;redux/store/store&apos;;</span><br><span class="line">import &#123; Provider &#125; from &apos;react-redux&apos;;</span><br><span class="line">import App from &apos;app/App.js&apos;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;/Provider&gt;</span><br><span class="line">  , document.getElementById(&apos;root&apos;));</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>[9] Container 컴포넌트를 Redux와 연결한다.<strong></strong></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">HeaderContainer.js</span><br><span class="line"></span><br><span class="line">import &#123; connect &#125; from &apos;react-redux&apos;;</span><br><span class="line">import &#123; Header &#125; from &apos;app/components/&apos;;</span><br><span class="line">import &#123; setLanguage &#125; from &apos;redux/actions/globalActions&apos;;</span><br><span class="line">import &#123; withRouter &#125; from &apos;react-router-dom&apos;;</span><br><span class="line"></span><br><span class="line">// props 값으로 넣어 줄 상태를 정의</span><br><span class="line">function mapStateToProps(state) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    wallets: state.wallet.wallets,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// props 값으로 넣어 줄 액션함수들을 정의</span><br><span class="line">function mapDispatchToProps(dispatch) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    setLanguage: (lan) =&gt; dispatch(setLanguage(lan))</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 컴포넌트와 Redux를 연동할 때 connect() 사용</span><br><span class="line">const HeaderContainer = connect(mapStateToProps, mapDispatchToProps)(Header);</span><br><span class="line"></span><br><span class="line">export default withRouter(HeaderContainer);</span><br></pre></td></tr></table></figure>
<p><br></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/React/">React</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redux/">Redux</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-webworker"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/03/10/webworker/">Web Worker</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/03/10/webworker/" class="article-date">
	  <time datetime="2019-03-10T13:08:23.000Z" itemprop="datePublished">March 10, 2019</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/API/">API</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Web-Worker란-무엇인가"><a href="#Web-Worker란-무엇인가" class="headerlink" title="Web Worker란 무엇인가?"></a>Web Worker란 무엇인가?</h1><hr>
<p><strong>Web Worker란, script 실행을 main thread(UI thread)가 아니라 background thread에서 실행할 수 있도록 해주는 API이다.</strong></p>
<p>*thread란, 어떤 프로그램 내에서 실행되는 흐름의 단위로, 보통 한 프로그램이 하나의 thread를 가지고 있다. 하나의 thread를 갖는다는 의미는, 어떤 이벤트(행위)가 발생했을 때, 그 하나의 이벤트를 처리할 때까지 다른 일은 못하게 된다는 뜻이다. 즉, 한번에 하나씩 처리한다는 뜻이다.</p>
<p>둘 이상의 thread를 동시에 실행하는 방식을 multi thread라고 한다. 웹 브라우저상의 javascript는 싱글 thread이기 때문에, 한번에 하나의 일 밖에 처리를 못한다. 그래서, 웹페이지에서 script가 실행되면, 해당 웹 페이지는 실행 중인 script가 종료될 때까지 응답 불가 상태, 즉 다른 일을 처리할 수가 없다.</p>
<p>이때, Web Worker를 사용하면, 시간이 오래 걸리는 javascript 작업 등을 background에서 처리하게 하여, 사용자의 UI를 방해하지 않고, 작업을 수행할 수 있다. 즉, script의 multi thread가 가능하게 된다.</p>
<p><br></p>
<h1 id="Web-Worker를-왜-사용하는가"><a href="#Web-Worker를-왜-사용하는가" class="headerlink" title="Web Worker를 왜 사용하는가?"></a>Web Worker를 왜 사용하는가?</h1><hr>
<p>Web Worker를 사용하는 이유는, script 작업이 복잡하여 시간이 오래 걸리는 경우에도, 사용자의 다른 UI 작업에 방해를 주지 않기 위한 multi thread가 가능하기 때문이다.</p>
<p><strong>Web Worker의 활용</strong></p>
<ul>
<li>사용자의 UI 작업(UI thread)에 방해 없이 계속 수행해야하는 작업이 있을 경우</li>
<li>background에서 오랜시간 동안 작업해야 하는 경우</li>
<li>원격에 있는 리소스에 대한 액세스 작업(localstorage를 액세스 하는 경우)이 있을 경우</li>
<li>복잡한 수학적 계산 작업이 있을 경우</li>
</ul>
<p>Web Worker를 사용하기 예전 상황</p>
<ul>
<li>스크립트가 수행을 하는데 오랜 시간이 걸릴 때, 브라우저는 무반응 스크립트에 대한 경고를 보여줌</li>
<li>webworker를 이용한 이후에는 이 문제 해결</li>
</ul>
<p><br></p>
<h1 id="Web-Worker를-어떻게-사용하는가"><a href="#Web-Worker를-어떻게-사용하는가" class="headerlink" title="Web Worker를 어떻게 사용하는가?"></a>Web Worker를 어떻게 사용하는가?</h1><hr>
<ul>
<li>How Web Worker works</li>
<li>기본적인 사용방법</li>
</ul>
<p><br></p>
<h2 id="How-Web-Worker-Works"><a href="#How-Web-Worker-Works" class="headerlink" title="How Web Worker Works"></a>How Web Worker Works</h2><hr>
<p><img src="/images/how_webworker_works.png" alt="How Web Worker Works"><br>출처: <a href="https://medium.com/@siobhanpmahoney/a-brief-introduction-to-web-workers-e5d6e39d9d28" target="_blank" rel="noopener">How Web Worker Works</a></p>
<p>Main script가 실행되는 HTML 파일(웹페이지)과 background script가 실행되는 Worker가 있다. HTML 파일(웹페이지)과 Worker간의 데이터를 서로 주고 받으면서, script가 실행되는 방식이다.</p>
<p>이때, 데이터를 송신할 때는 postMessage 메서드를 사용하고, 데이터를 수신할 때는 onmessage 이벤트 핸들러를 사용한다. HTML 파일(웹페이지)에서 데이터를 송신하거나 수신할 수 있고, Worker에서도 데이터를 송신하거나 수신할 수 있다.</p>
<p>postMessage는 다수의 window 창간의 정보교환을 목적으로 사용한다. workers는 DOM에 대한 접근 권한이 없어서 직접 웹페이지를 조작이 불가능하다.</p>
<p><br></p>
<h2 id="Web-Worker의-기본적인-사용방법"><a href="#Web-Worker의-기본적인-사용방법" class="headerlink" title="Web Worker의 기본적인 사용방법"></a>Web Worker의 기본적인 사용방법</h2><hr>
<p>코드상으로 Web Worker를 사용하기 위해서는 다음과 같이 해야한다.</p>
<ul>
<li>Worker 실행 파일(worker.js) 작성</li>
<li>Worker를 호출할 HTML 파일(웹페이지)에서 Worker를 호출</li>
<li>Worker 종료</li>
</ul>
<p><br></p>
<h3 id="Worker-실행-파일-worker-js-작성"><a href="#Worker-실행-파일-worker-js-작성" class="headerlink" title="Worker 실행 파일(worker.js) 작성"></a>Worker 실행 파일(worker.js) 작성</h3><hr>
<p>Worker가 실행할 script, 즉 javascript(worker.js) 파일을 만들고 작성한다. 이때, on message 이벤트 핸들러와 postMessage 메서드를 같이 작성한다. 왜냐하면, HTML 페이지로부터 전달 받을 데이터를 onmessage 이벤트 핸들러로 수신받아 처리한 후, postMessage 메서드로 다시 HTML 페이지에 전달해줘야 하기 때문이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// worker.js</span><br><span class="line"></span><br><span class="line">//웹페이지로부터 메세지를 수신하여 시간이 오래 걸리는 작업 등을 처리</span><br><span class="line">onmessage = function(e)&#123;</span><br><span class="line">  var receiveData = e.data;</span><br><span class="line"></span><br><span class="line">  //워커를 호출한 곳(웹페이지)으로 결과 메시지를 전송</span><br><span class="line">  if(receiveData) &#123;</span><br><span class="line">    var sendData = &quot;I&apos;m working for you&quot;</span><br><span class="line">    postMessage(sendData)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="Worker를-호출할-HTML-파일-웹페이지-에서-Worker를-호출"><a href="#Worker를-호출할-HTML-파일-웹페이지-에서-Worker를-호출" class="headerlink" title="Worker를 호출할 HTML 파일(웹페이지)에서 Worker를 호출"></a>Worker를 호출할 HTML 파일(웹페이지)에서 Worker를 호출</h3><hr>
<p>New 연산자와 Worker 생성자 함수를 이용해 worker 인스턴스를 생성한다. 생성한 worker 인스턴스를 사용해서, Worker(worker.js)에 보낼 데이터를 postMessage 메서드를 이용해 작성하고, 후에, Worker(worker.js)에서 처리된 후 받을 데이터를 on message 이벤트 핸들러를 이용해 작성한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">      var worker;</span><br><span class="line">      function callWorker()&#123;</span><br><span class="line">        if(!!window.Worker)&#123; //브라우저가 웹 워커를 지원하는지 확인</span><br><span class="line"></span><br><span class="line">          if(worker) worker.terminate();      //워커가 이미 존재하면 종료시킴</span><br><span class="line">          worker = new Worker(&quot;worker.js&quot;);  //새로운 워커(객체)를 생성</span><br><span class="line"></span><br><span class="line">          //워커로부터 전달되는 메시지를 받음</span><br><span class="line">          worker.onmessage = function(e)&#123;</span><br><span class="line">            alert(e.data);</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">          //워커에게 메시지를 전달</span><br><span class="line">          worker.postMessage(&quot;What does Worker do?&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">          alert(&quot;The current browser does not support web worker api&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      function stopWorker()&#123;</span><br><span class="line">        if(worker)&#123;</span><br><span class="line">          worker.terminate();</span><br><span class="line">          alert(&quot;web worker has terminated&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;button onclick=&quot;callWorker()&quot;&gt;Call web worker&lt;/button&gt;</span><br><span class="line">    &lt;button onclick=&quot;stopWorker()&quot;&gt;Stop web worker&lt;/button&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot;&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="Worker-종료"><a href="#Worker-종료" class="headerlink" title="Worker 종료"></a>Worker 종료</h3><hr>
<p>Worker 인스턴스는 생성되고 종료될 때까지 계속해서 데이터를 받을 준비를 한다. 그래서, 브라우저나 컴퓨터의 자원을 돌려주기 위해 terminate() 메서드를 사용하여, worker를 반드시 종료해야 한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker.terminate();</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/API/">API</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web-Worker/">Web Worker</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-ethereum-keystore"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/03/10/ethereum-keystore/">Ethereum Wallet 및 Keystore 파일 생성 및 암호화 원리</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/03/10/ethereum-keystore/" class="article-date">
	  <time datetime="2019-03-09T16:03:55.000Z" itemprop="datePublished">March 10, 2019</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Ethereum/">Ethereum</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="지갑이-생성되는-과정-그리고-Keystore-파일"><a href="#지갑이-생성되는-과정-그리고-Keystore-파일" class="headerlink" title="지갑이 생성되는 과정, 그리고 Keystore 파일"></a>지갑이 생성되는 과정, 그리고 Keystore 파일</h1><hr>
<p><strong>지갑을 생성하게 되면, 지갑의 비밀번호(pw), private key(pk), 그리고 지갑을 백업할 수 있는 keystore 파일을 받게된다.</strong></p>
<p>지갑을 import 하는 등 지갑에 대한 본인 인증을 할 때는 2가지 방법 중 하나로 한다.</p>
<ul>
<li><p><strong>pk를 이용하여 지갑에 대한 본인 인증을 한다.</strong></p>
<ul>
<li>문제는 pk(64 hex 문자열)를 기억하기 쉽지 않고, 관리 이슈도 있다.</li>
</ul>
</li>
<li><p><strong>Keystore 파일과 pw를 이용하여 지갑에 대한 본인 인증을 한다.</strong></p>
<ul>
<li>Keystore 파일은 pk의 암호화된 버전이다.</li>
<li>pk를 pw와 암호화 알고리즘을 이용해 암호화하여 keystore 파일로 만드는 것이다.</li>
</ul>
</li>
</ul>
<p>이 방법이 더 좋은 2가지 이유가 있다.</p>
<ul>
<li><strong>안전성:</strong><ul>
<li>만약 사용자가 pk만 사용할 경우, 해커는 그 pk만 알아내면 사용자의 지갑은 해킹당하게 된다.</li>
<li>그런데, keystore 파일을 사용하면 해커는 추가로 pw까지 알아야 하므로 더 안전하다.</li>
</ul>
</li>
<li><strong>사용성:</strong><ul>
<li>복잡한 pk 대신 사용자들에게 익숙한 pw와 파일로 쉽게 지갑을 사용할 수 있다.</li>
</ul>
</li>
</ul>
<p><br></p>
<h1 id="keystore-파일-데이터-구조"><a href="#keystore-파일-데이터-구조" class="headerlink" title="keystore 파일 데이터 구조"></a>keystore 파일 데이터 구조</h1><hr>
<p>keystore 파일의 데이터 구조는 다음과 같다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;: 3,</span><br><span class="line">    &quot;id&quot;: &quot;4c07993f-ded2-405a-b83d-3b627eebe5cd&quot;,</span><br><span class="line">    &quot;address&quot;: &quot;e449efddf8c9b174bbd40a0e0e1902d6eee72068&quot;,</span><br><span class="line">    &quot;Crypto&quot;: &#123;</span><br><span class="line">        &quot;cipher&quot;: &quot;aes-128-ctr&quot;,</span><br><span class="line">        &quot;cipherparams&quot;: &#123;</span><br><span class="line">          &quot;iv&quot;: &quot;7d416faf14c88bb124486f6cd851fa88&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ciphertext&quot;:&quot;e99f6d0e37f33124ee3020fad01363d9d7500efce</span><br><span class="line">                      913aede8a8119229b7a5f2e&quot;,</span><br><span class="line">        &quot;kdf&quot;: &quot;scrypt&quot;,</span><br><span class="line">        &quot;kdfparams&quot;: &#123;</span><br><span class="line">            &quot;dklen&quot;: 32,</span><br><span class="line">            &quot;salt&quot;: &quot;c47f395c9031233453168f01b5a9999a06ec97c829</span><br><span class="line">                     a395ecd16e1ad37102ec7f&quot;,</span><br><span class="line">            &quot;n&quot;: 8192,</span><br><span class="line">            &quot;r&quot;: 8,</span><br><span class="line">            &quot;p&quot;: 1</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;mac&quot;: &quot;82078437ee94331c69125eef4001ff4b78b481e909a6</span><br><span class="line">                2a9ac25aa916237b70be&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위 구조 중, Crypto 객체가 keystore 파일 암호화에 대한 정보이다.</p>
<p><br></p>
<h1 id="pw를-이용해-pk를-암호화-복호화하여-keystore-파일을-생성하는-원리"><a href="#pw를-이용해-pk를-암호화-복호화하여-keystore-파일을-생성하는-원리" class="headerlink" title="pw를 이용해 pk를 암호화/복호화하여 keystore 파일을 생성하는 원리"></a>pw를 이용해 pk를 암호화/복호화하여 keystore 파일을 생성하는 원리</h1><hr>
<h2 id="pw-암호화"><a href="#pw-암호화" class="headerlink" title="pw 암호화"></a>pw 암호화</h2><hr>
<p><img src="/images/pw_encrypt.png" alt="pw 암호화 과정"><br>출처: <a href="https://medium.com/hexlant/%EC%9D%B4%EB%8D%94%EB%A6%AC%EC%9B%80-keystore-%ED%8C%8C%EC%9D%BC-utc-%EC%83%9D%EC%84%B1-%EB%B0%8F-%EC%95%94%ED%98%B8%ED%99%94-%EB%B3%B5%ED%98%B8%ED%99%94-%EC%9B%90%EB%A6%AC-1-2-d417cb605bf" target="_blank" rel="noopener">pw 암호화 과정</a></p>
<p>Pk를 암호화하기 위해 pw를 사용하는데, 이 pw를 직접 암호화키로 사용하지 않고, 이 pw를 암호화하여 암호화한 값을 암호화 키로 사용해서 pk를 암호화한다. 이때, pw를 암호화하는 알고리즘은 Scrypt인데, 비밀번호는 특성상 복호화할 필요가 없기 때문에 단반향 알고리즘 중 하나인 Scrypt를 사용한다.</p>
<p>Keystore 파일에 들어갈 때는, kdf: ‘Scrypt’ 이런식으로 들어가는데, kdf는 암호화 알고리즘 이름을 말하고, Scrypt 알고리즘을 사용한다는 뜻이다.</p>
<p>참고로, kdfparams 들어가는 것 중, n은 CPU/memory 비용을 말한다. 즉, 값이 클수록 암호화 파워가 증가한다.</p>
<p><br></p>
<h2 id="pk-암호화"><a href="#pk-암호화" class="headerlink" title="pk 암호화"></a>pk 암호화</h2><hr>
<p><img src="/images/pk_encrypt.png" alt="pk 암호화 과정"><br>출처: <a href="https://medium.com/hexlant/%EC%9D%B4%EB%8D%94%EB%A6%AC%EC%9B%80-keystore-%ED%8C%8C%EC%9D%BC-utc-%EC%83%9D%EC%84%B1-%EB%B0%8F-%EC%95%94%ED%98%B8%ED%99%94-%EB%B3%B5%ED%98%B8%ED%99%94-%EC%9B%90%EB%A6%AC-1-2-d417cb605bf" target="_blank" rel="noopener">pk 암호화 과정</a></p>
<p>Pk를 암호화하기 위해서는 좀 전에 pw를 암호화한 값을 암호화키로 사용하고, AES 알고리즘을 사용해서 pk를 암호화한다. pk는 복호화할 필요가 있으므로(pk는 거래를 할 때, 사용되므로) 양방향 알고리즘인 AES를 사용한다.</p>
<p>Keystore 파일에 들어갈 때는, cipher: ‘aes-128-ctr’ 이런식으로 들어가는데, cipher는 암호화 알고리즘의 이름이고 aes-128-ctr 알고리즘을 사용한다는 뜻이다.</p>
<p><br></p>
<h2 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h2><hr>
<p>Mac은 keystone 파일을 사용할 때, 사용자가 입력한 pw의 일치여부를 확인하고, pk를 복호화해도 되는지 확인 용도로 사용한다.</p>
<p>*참고로, 이더리움 wallet 만들어지는 순서</p>
<ul>
<li>Pk로 public key 생성</li>
<li>Public key로 address 생성</li>
</ul>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Ethereum/">Ethereum</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ethereum/">Ethereum</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Keystore/">Keystore</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-react-lifecycle-api"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/03/08/react-lifecycle-api/">Lifecycle API</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/03/08/react-lifecycle-api/" class="article-date">
	  <time datetime="2019-03-08T14:49:53.000Z" itemprop="datePublished">March 8, 2019</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/React/">React</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Lifecycle-API란-무엇인가"><a href="#Lifecycle-API란-무엇인가" class="headerlink" title="Lifecycle API란 무엇인가?"></a>Lifecycle API란 무엇인가?</h1><hr>
<p><strong>Lifecycle API란, 컴포넌트가 브라우저에서 생성될 때/업데이트 될 때/제거될 때, 호출되는 API이다.</strong></p>
<p>React 컴포넌트의 lifecycle은 다음과 같다.</p>
<p><img src="/images/lifecycle.png" alt="React 컴포넌트의 lifecycle"><br>출처: <a href="https://velopert.com/1130" target="_blank" rel="noopener">React 컴포넌트의 lifecycle</a></p>
<p><br></p>
<h1 id="React-lifecycle-API-3단계"><a href="#React-lifecycle-API-3단계" class="headerlink" title="React lifecycle API 3단계"></a>React lifecycle API 3단계</h1><hr>
<p><strong>Mounting: React 컴포넌트의 인스턴스가 생성되고, DOM에 삽입되는 과정의 lifecycle</strong><br>(Mount: 컴포넌트가 DOM에 삽입되는 것)</p>
<ul>
<li>constructor</li>
<li>componentWillMount</li>
<li>render</li>
<li>componentDidMount</li>
</ul>
<p><strong>Updating: prop 또는 state의 변경으로 해당 컴포넌트가 re-rendering 되는 경우의 lifecycle</strong></p>
<ul>
<li>componentWillReceiveProps(props가 변경될 때만)</li>
<li>shouldComponentUpdate</li>
<li>componentWillUpdate</li>
<li>render</li>
<li>componentDidUpdate</li>
</ul>
<p><strong>Unmounting: 컴포넌트가 제거되는 과정의 lifecycle</strong><br>(Unmount: 페이지 이동으로 인한 그 전 페이지에서의 컴포넌트는 DOM에서 분리되는 것)</p>
<ul>
<li>componentWillUnmount</li>
</ul>
<p><br></p>
<h1 id="React-v16-3-이전의-Lifecycle-API"><a href="#React-v16-3-이전의-Lifecycle-API" class="headerlink" title="React v16.3 이전의 Lifecycle API"></a>React v16.3 이전의 Lifecycle API</h1><hr>
<p><img src="/images/lifecycle-pre.png" alt="React v16.3 이전의 Lifecycle API"><br>출처: <a href="https://velog.io/@kyusung/%EB%A6%AC%EC%95%A1%ED%8A%B8-%EA%B5%90%EA%B3%BC%EC%84%9C-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%99%80-%EB%9D%BC%EC%9D%B4%ED%94%84%EC%82%AC%EC%9D%B4%ED%81%B4-%EC%9D%B4%EB%B2%A4%ED%8A%B8" target="_blank" rel="noopener">React v16.3 이전의 Lifecycle API</a></p>
<p><br></p>
<h1 id="Mounting"><a href="#Mounting" class="headerlink" title="Mounting"></a>Mounting</h1><hr>
<p><strong>React 컴포넌트의 인스턴스가 생성되고, DOM에 삽입되는 과정의 lifecycle</strong></p>
<p><br></p>
<h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><hr>
<p><strong>우선, lifecycle API 전에 컴포넌트가 새로 만들어질 때마다 제일 먼저 호출되는 것이 바로, constructor(컴포넌트 생성자 함수)이다.</strong></p>
<p>참고로, 컴포넌트에서 state를 정의할 때는 2가지 방법 중 하나를 사용하면 된다.</p>
<ul>
<li>Class fields 문법</li>
<li>Constructor 사용</li>
</ul>
<h3 id="Class-fields-문법"><a href="#Class-fields-문법" class="headerlink" title="Class fields 문법"></a>Class fields 문법</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class InvestContainer extends Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    number: 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="Constructor-사용"><a href="#Constructor-사용" class="headerlink" title="Constructor 사용"></a>Constructor 사용</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class InvestContainer extends Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      number: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>super(props)를 호출한 이유:</strong></p>
<p>ES6 class의 constructor에서 super 메소드를 사용하는 이유는, 자식 클래스에서 super 메소드를 사용함으로써 자식 class의 constructor 내부에서 부모 클래스의 constructor를 호출한다. 즉, 부모 클래스의 인스턴스를 생성해서, this를 사용할 수 있게 된다. 만약 super 키워드를 사용하지 않으면, this에 대한 참조 에러가 발생한다. 다시 말하면, super 메소드를 호출하기 이전에는 this를 참조할 수 없다는 것을 의미한다.</p>
<p>리액트에서 컴포넌트를 class형으로 만들때는, 모두 기본적으로 리액트에 있는 ‘Component’라는 부모 클래스로부터 상속받아 자식 클래스로 시작하게 된다. 그래서 자식 클래스에서는 super 메소드를 사용해서 , 부모 클래스(Component)의 constructor를 호출, 즉 Component 클래스의 인스턴스를 생성해서 this를 사용할 수 있게 되는 것이다. 그 다음에, this를 이용해 프로퍼티를 초기화할 수 있다.</p>
<p>정리하면, constructor를 사용한다면, 반드시 super()를 불러와야 한다. super()를 사용하지 않으면, this가 초기화되지 않는다.</p>
<p><br><br><strong>그러면, super()에 props를 사용해야 하는가?</strong></p>
<p>constructor 안에서 this.props에 접근하고 싶다면, super(props)를 사용한다.<br>만약, super() 이렇게만 사용하면 다음과 같이 나온다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class MyApp extends React.Component&#123;</span><br><span class="line">  constructor(props)&#123;</span><br><span class="line">    super();</span><br><span class="line">    console.log(this.props); // this.props is undefined</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>위 코드에서 super(props)라고 사용해야 this.props에 접근할 수 있다.</p>
<p>그러나, constructor가 아닌 다른 곳에서 this.props를 사용하고 싶으면, constructor 안에 props를 넘겨줄 필요가 없다. 왜냐하면, React에서 자동으로 세팅해주기 때문이다.</p>
<p>이 방법이 더 복잡하므로, class fields 문법으로 주로 사용하는 것이 더 편리!</p>
<p><br></p>
<h2 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount"></a>componentWillMount</h2><hr>
<p><strong>컴포넌트가 DOM에 삽입되기 전(Mount 되기 전)에 호출되는 API이다. 즉, render가 되기 전이기 때문에, 컴포넌트가 브라우저에 나타나기 전(화면에 나가기 전)에 호출되는 API이다.</strong></p>
<p>사용 이유</p>
<ul>
<li>mount 직전에 하고 싶은 것들(i.e. 방문자가 어떤 페이지를 방문했는지 Google Anlaytics에 신호할 때)이 있을 경우 사용</li>
<li>루트 컴포넌트에서 APP과 관련된 외부 API를 설정할 때 사용</li>
</ul>
<p>React v16.3 이후부터는 해당 API가 deprecated 되어서, 사용하면 안된다.<br>기존에 이 API에서 하던 것들을 constructor와 componentDidMount에서 처리 가능하다.</p>
<p><br></p>
<h2 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h2><hr>
<p><strong>컴포넌트가 DOM과 삽입(Mount)되고, render가 된 이후에 호출되는 API이다.</strong></p>
<p>이 API는 페이지가 첫 렌더링 될 때, 호출되는 API이다. 즉, 이 컴포넌트가 사용된 페이지가 처음 로드 될때, 또는 refresh로 다시 이 페이지가 불러올 때 등으로 인해 처음으로 렌더링 될 때, 호출되는 API이다.</p>
<p>사용 이유</p>
<ul>
<li>DOM에 대한 접근이 필요한 모든 설정을 수행할 때 사용(DOM의 속성을 읽거나 직접 변경하는 작업 등)</li>
<li>해당 컴포넌트에서 필요로하는 데이터를 요청하기 위해 사용(axios, fetch 등을 통한 ajax 요청)</li>
<li>외부 라이브러리 연동</li>
<li>addEventListener 적용</li>
</ul>
<p>예를 들면, 액션을 발생시켜 서버로부터 데이터를 받아올 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  this.props.getEachProject(this.props.projectId);</span><br><span class="line">  this.props.getContractList(&#123; projectId: this.props.projectId &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>또는, addEventListener를 적용할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">    window.addEventListener(&quot;ICONEX_RELAY_RESPONSE&quot;, this.eventHandler, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="Updating"><a href="#Updating" class="headerlink" title="Updating"></a>Updating</h1><hr>
<p><strong>컴포넌트의 업데이트는 props 또는 state의 변화에 따라 결정된다.</strong></p>
<p><br></p>
<h2 id="componentWillReceiveProps"><a href="#componentWillReceiveProps" class="headerlink" title="componentWillReceiveProps"></a>componentWillReceiveProps</h2><hr>
<p><strong>컴포넌트가 새로운 props를 받게됐을 때 호출되는 API이다. 즉, 새로운 props로 어떠한 작업을 수행하기 전에, 이 새로운 props를 인자로하여 이 API가 호출된다. 새로 받게될 props는 nextProps로 조회 가능하고, this.props는 현재의 props를 말한다.</strong></p>
<p>사용 이유</p>
<ul>
<li>props를 받아서 state를 변경해야 하는 경우 유용하다.</li>
</ul>
<p>다음과 같이 작성할 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">  if (this.props.percent !== nextProps.percent) &#123;</span><br><span class="line">    this.setUpPercent(nextProps.percent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>또는,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">		if (nextProps.message === &quot;&quot;) &#123;</span><br><span class="line">			this.setState(&#123;</span><br><span class="line">				hide: true</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			this.setState(&#123;</span><br><span class="line">				hide: false</span><br><span class="line">			&#125;);</span><br><span class="line">			setTimeout(() =&gt; &#123;</span><br><span class="line">				this.setState(&#123;</span><br><span class="line">					hide: true</span><br><span class="line">				&#125;);</span><br><span class="line">				this.props.handleToast(&quot;&quot;);</span><br><span class="line">			&#125;, 2500);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>이 API는 초기 렌더링시에는 호출되지 않는다.</p>
<p><br></p>
<h2 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h2><hr>
<p><strong>컴포넌트 업데이트 직전에 호출되는 API이다.</strong></p>
<p>사용 이유</p>
<ul>
<li>컴포넌트를 최적화하는 작업에 사용<ul>
<li>즉, 해당 컴포넌트의 re-rendering를 제어할 때 사용</li>
</ul>
</li>
</ul>
<p>이 API는 항상 boolean(true 또는 false)을 반환한다. 즉, 해당 컴포넌트를 re-rending할지 말지를 결정하는 API이다.</p>
<p>컴포넌트를 최적화하기 위해서는, 필요없는 re-rending을 막아야 하고, 그러기 위해서는 props 또는 state가 변경되었을 때만, re-rendering 하게끔 이 API안에서 코드를 작성하면 된다.</p>
<p>예를 들어, 다음과 같이 작성하면 된다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">  return this.props.engagement !== nextProps.engagement</span><br><span class="line">    || nextState.input !== this.state.input;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="componentWillUpdate"><a href="#componentWillUpdate" class="headerlink" title="componentWillUpdate"></a>componentWillUpdate</h2><hr>
<p><strong>이 API는 update가 발생하기 전 어떤 작업이 필요한 경우 사용하는 API로써, shouldComponentUpdate에서 true를 반환했을 때만, 호출되는 API이다.</strong> shouldComponentUpdate가 이미 사용되고 있는 컴포넌트에서 componentWillReceiveProps를 대신 사용한다. 이 API가 호출되고 난 다음에는 render() 함수가 호출된다.</p>
<p>사용 이유</p>
<ul>
<li>애니메이션 효과를 초기화할 때 사용</li>
<li>이벤트 리스너를 없앨 때 사용</li>
</ul>
<p>이 API에서는 this.setState()를 사용하면 무한 루프가 일어나게 되므로 사용하면 안된다.</p>
<p>예를 들어, props가 업데이트 되기 전에 어떤 element를 fade out 애니메이션 효과를 주고 싶은 경우에는 다음과 같이 사용한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">componentWillUpdate (nextProps, nextState)&#123;</span><br><span class="line">    if(!nextState.show)&#123;</span><br><span class="line">        $(ReactDOM.findDOMNode(this.refs.elem)).css(&#123;&apos;opacity&apos;:&apos;1&apos;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">      $(ReactDOM.findDOMNode(this.refs.elem)).css(&#123;&apos;opacity&apos;:&apos;0&apos;&#125;);;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a>componentDidUpdate</h2><hr>
<p><strong>componentWillUpdate 이후, render() 함수가 호출된 뒤에 호출되는 API이다.</strong><br>이 시점에서는 this.props와 this.state가 새로 변경되었고, 대신에 이전 값들인 prevProps와 prevState를 조회할 수 있다.</p>
<p>사용 이유</p>
<ul>
<li>props 또는 state에 따라서 DOM을 업데이트 할 때 사용</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">componentDidUpdate(prevProps, prevState) &#123;</span><br><span class="line">    if (this.props.location.query.pagename !== prevProps.location.query.pagename) &#123;</span><br><span class="line">      LayerPopup.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="Unmounting"><a href="#Unmounting" class="headerlink" title="Unmounting"></a>Unmounting</h1><hr>
<p><br></p>
<h2 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h2><hr>
<p><strong>컴포넌트가 DOM에서 삭제된(분리된)(=== unmount) 후 호출되는 API이다.</strong></p>
<p>A 페이지에서 로그인 컴포넌트를 사용하고, B 페이지에서는 장바구니 컴포넌트를 사용한다고 하자. 그러면, A 페이지가 로드가 되면, 로그인 컴포넌트가 마운트가 된다. 그러다가, B 페이지로 이동하게 되면, 로그인 컴포넌트는 언마운트 되고, 장바구니 컴포넌트가 마운트가 된다. 즉, 페이지 이동으로 인한 기존 페이지에서의 컴포넌트가 그 페이지의 DOM에서 분리되는 것을 Unmount 라고 한다.</p>
<p>만약 componentDidMount에서 addEventListner를 사용했는데, 다른 페이지에서는 이 addEventListner를 사용하고 싶지 않다면, componentWillUnmount에서 이 컴포넌트가 Unmount 되기 전에, 이 addEventListner를 제거해야 한다.(removeEventListener)</p>
<p>왜냐하면, addEventListner는 window.addEventListner 이렇게 사용하기 때문에(window 객체의 메소드), 전역으로 다른 페이지에도 영향이 간다. 그래서, 이 페이지에만 사용할 것이라면, 이 페이지의 컴포넌트가 Unmount 될 때, addEventListner를 제거해야 한다.</p>
<p>사용 이유</p>
<ul>
<li>removeEventListener로 이벤트 제거</li>
<li>등록했었던 이벤트 제거</li>
<li>컴포넌트 내부에서 타이머나 비동기 API를 사용하고 있을 때, 이를 제거하기에 유용하다.</li>
<li>setTimeout 함수를 사용했다면, clearTimeout을 통하여 제거</li>
</ul>
<p>예를 들어, removeEventListener로 이벤트 제거 할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">componentWillUnmount() &#123;</span><br><span class="line">    window.removeEventListener(&quot;ICONEX_RELAY_RESPONSE&quot;, this.eventHandler, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="React-v16-3-이후의-Lifecycle-API"><a href="#React-v16-3-이후의-Lifecycle-API" class="headerlink" title="React v16.3 이후의 Lifecycle API"></a>React v16.3 이후의 Lifecycle API</h1><hr>
<p>React v17 부터 depreciated 될 API</p>
<ul>
<li>componentWillMount</li>
<li>componentWillReceiveProps(v17: getDerivedStateFromProps)</li>
<li>componentWillUpdate(v17: getSnapshotBeforeUpdate)</li>
</ul>
<p>React v17 부터 추가될 API</p>
<ul>
<li>componentDIdCatch: 컴포넌트 에러 핸들링 API</li>
</ul>
<p><img src="/images/lifecycle-new.png" alt="React v16.3 이후의 Lifecycle API"><br>출처: <a href="https://velog.io/@kyusung/%EB%A6%AC%EC%95%A1%ED%8A%B8-%EA%B5%90%EA%B3%BC%EC%84%9C-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%99%80-%EB%9D%BC%EC%9D%B4%ED%94%84%EC%82%AC%EC%9D%B4%ED%81%B4-%EC%9D%B4%EB%B2%A4%ED%8A%B8" target="_blank" rel="noopener">React v16.3 이후의 Lifecycle API</a></p>
<p><br></p>
<h1 id="React-v16-3-이후에-변경된-부분"><a href="#React-v16-3-이후에-변경된-부분" class="headerlink" title="React v16.3 이후에 변경된 부분"></a>React v16.3 이후에 변경된 부분</h1><hr>
<p>몇개 lifecycle API가 변경된 부분이 있다. 아래의 링크에서 확인해보자.</p>
<p>출처: <a href="https://velog.io/@kyusung/%EB%A6%AC%EC%95%A1%ED%8A%B8-%EA%B5%90%EA%B3%BC%EC%84%9C-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%99%80-%EB%9D%BC%EC%9D%B4%ED%94%84%EC%82%AC%EC%9D%B4%ED%81%B4-%EC%9D%B4%EB%B2%A4%ED%8A%B8" target="_blank" rel="noopener">React v16.3 이후의 lifecycle</a></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/React/">React</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Lifecycle-API/">Lifecycle API</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/">React</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-modules"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/01/02/modules/">Modules</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/01/02/modules/" class="article-date">
	  <time datetime="2019-01-01T15:05:11.000Z" itemprop="datePublished">January 2, 2019</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/ES6/">ES6</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Module이란-무엇인가"><a href="#Module이란-무엇인가" class="headerlink" title="Module이란 무엇인가?"></a>Module이란 무엇인가?</h1><hr>
<p>모듈이란, 애플리케이션을 구성하는 개별적 요소로서, 재사용이 가능한 코드 조각을 말한다.</p>
<p>모듈은 세부 사항을 캡슐화하고, 공개가 필요한 API만을 외부에 노출한다. 일반적으로, 각 모듈은 파일 단위로 분리되어 있고, 애플리케이션은 필요에 따라 모듈을 로드하여 재사용한다. 즉, 모듈은 애플리케이션에 분리되어 개별적으로 존재하다가 애플리케이션의 로드에 의해 비로소 애플리케이션의 로드에 의해 비로소 애플리케이션의 일원이 된다.</p>
<p>모듈은 기능별로 분리되어 작성되므로, 코드의 단위를 명확히 분리하여 애플리케이션을 구성할 수 있고, 재사용에 좋기 때문에, 개발을 효율적으로 할 수 있고, 유지보수 또한 좋다.</p>
<p>ES6에서 모듈을 사용할 때, export와 import 두 개의 키워드를 사용한다.</p>
<p><br></p>
<h1 id="Module-사용의-이점"><a href="#Module-사용의-이점" class="headerlink" title="Module 사용의 이점"></a>Module 사용의 이점</h1><hr>
<ul>
<li>Javascript 애플리케이션을 여러 개의 파일로 분할하여 작성할 수 있다.</li>
<li>재사용이 가능한 코드를 작성하기 때문에, 개발 효율과 유지보수에 좋다.</li>
</ul>
<p><br></p>
<h1 id="Export"><a href="#Export" class="headerlink" title="Export"></a>Export</h1><hr>
<p>모듈은 기본적으로 독립적인 스코프를 가지고 있어서, 모듈안에 선언된 모든 것들은 해당 모듈 내에서만 참조 할 수 있다.</p>
<p>어떤 모듈안에서 선언한 항목(변수/함수/클래스 등)을 외부에 공개하여 다른 모듈들이 사용할 수 있게 하려면, export를 해야한다. 이때, 선언된 변수, 함수, 그리고 클래스 모두를 export 할 수 있고, 키워드는 export를 사용한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// module.js</span><br><span class="line">// 변수의 공개</span><br><span class="line">export const num = 10;</span><br><span class="line"></span><br><span class="line">// 함수의 공개</span><br><span class="line">export function square(x) &#123;</span><br><span class="line">  return x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 클래스의 공개</span><br><span class="line">export class Person &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>각 선언문(변수/함수/클래스) 앞에 export를 붙이는 대신, export 대상을 하나의 객체로 구성하여, 한번에 export를 할 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// module.js</span><br><span class="line">const num = 10;</span><br><span class="line"></span><br><span class="line">function square(x) &#123;</span><br><span class="line">  return x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 변수, 함수 클래스를 하나의 객체로 구성하여 공개</span><br><span class="line">export &#123; num, square, Person &#125;;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h1 id="Import"><a href="#Import" class="headerlink" title="Import"></a>Import</h1><hr>
<p>다른 모듈에서 어떤 export된 모듈을 가져와 사용하려면, 키워드 import를 사용해 로드하여 사용할 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line">// 같은 폴더 내의 module.js 모듈을 로드. 확장자 js는 생략 가능.</span><br><span class="line">import &#123; num, square, Person &#125; from &apos;./module&apos;;</span><br><span class="line"></span><br><span class="line">console.log(num);         // 10</span><br><span class="line">console.log(square(10)); // 100</span><br><span class="line">console.log(new Person(&apos;Lee&apos;)); // Person &#123; name: &apos;Lee&apos; &#125;</span><br></pre></td></tr></table></figure></p>
<p>각각의 이름을 지정하지 않고 하나의 이름으로 한꺼번에 import할 수도 있다. 이때 import되는 항목은 as 뒤에 지정한 이름의 변수에 할당된다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line">// lib라는 이름으로 임포트</span><br><span class="line">import * as lib from &apos;./module&apos;;</span><br><span class="line"></span><br><span class="line">console.log(module.num);         // 10</span><br><span class="line">console.log(module.square(10)); // 100</span><br><span class="line">console.log(new module.Person(&apos;Lee&apos;)); // Person &#123; name: &apos;Lee&apos; &#125;</span><br></pre></td></tr></table></figure></p>
<p>이름을 변경하여 import할 수도 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line">import &#123; num as n, square as sq, Person as P &#125; from &apos;./module&apos;;</span><br><span class="line"></span><br><span class="line">console.log(n);    // 10</span><br><span class="line">console.log(sq(2)); // 4</span><br><span class="line">console.log(new P(&apos;Kim&apos;)); // Person &#123; name: &apos;Kim&apos; &#125;</span><br></pre></td></tr></table></figure></p>
<p>모듈에서 하나만을 export할 때는 default 키워드를 사용할 수 있다. 다만, default를 사용하는 경우, var, let, const는 사용할 수 없다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// lib.js</span><br><span class="line">function (x) &#123;</span><br><span class="line">  return x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default;</span><br></pre></td></tr></table></figure></p>
<p>위 코드를 아래와 같이 축약 표현할 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// module.js</span><br><span class="line">export default function (x) &#123;</span><br><span class="line">  return x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>default 키워드와 함께 export한 모듈은 {} 없이 임의의 이름으로 import한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line">import square from &apos;./module&apos;;</span><br><span class="line"></span><br><span class="line">console.log(square(3)); // 9</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h1 id="Vue에서의-Modules-사용하는-방법"><a href="#Vue에서의-Modules-사용하는-방법" class="headerlink" title="Vue에서의 Modules 사용하는 방법"></a>Vue에서의 Modules 사용하는 방법</h1><hr>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/ES6/">ES6</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Modules/">Modules</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-arrow-function"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/01/01/arrow-function/">Arrow Function</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/01/01/arrow-function/" class="article-date">
	  <time datetime="2019-01-01T13:41:36.000Z" itemprop="datePublished">January 1, 2019</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/ES6/">ES6</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="화살표-함수-Arrow-Function-란-무엇인가"><a href="#화살표-함수-Arrow-Function-란-무엇인가" class="headerlink" title="화살표 함수(Arrow Function)란 무엇인가?"></a>화살표 함수(Arrow Function)란 무엇인가?</h1><hr>
<p>화살표 함수는 기존의 function 키워드 대신 화살표(=&gt;)를 사용하여, 보다 간단히 함수를 선언하는 방식이다. 문법은 다음과 같다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 매개변수 지정 방법</span><br><span class="line">    () =&gt; &#123; ... &#125; // 매개변수가 없을 경우</span><br><span class="line">     x =&gt; &#123; ... &#125; // 매개변수가 한 개인 경우, 소괄호를 생략할 수 있다.</span><br><span class="line">(x, y) =&gt; &#123; ... &#125; // 매개변수가 여러 개인 경우, 소괄호를 생략할 수 없다.</span><br><span class="line"></span><br><span class="line">// 함수 몸체 지정 방법</span><br><span class="line">x =&gt; &#123; return x * x &#125;  // single line block</span><br><span class="line">x =&gt; x * x             // 함수 몸체가 한줄의 구문이라면 중괄호를 생략할 수 있으며 암묵적으로 return된다. 위 표현과 동일하다.</span><br><span class="line"></span><br><span class="line">() =&gt; &#123; return &#123; a: 100 &#125;; &#125;</span><br><span class="line">() =&gt; (&#123; a: 100 &#125;)  // 위 표현과 동일하다. 객체는 반환할 때, 소괄호를 사용한다.</span><br><span class="line"></span><br><span class="line">() =&gt; &#123;           // multi line block.</span><br><span class="line">  const x = 100;</span><br><span class="line">  return x * x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h1 id="화살표-함수의-호출"><a href="#화살표-함수의-호출" class="headerlink" title="화살표 함수의 호출"></a>화살표 함수의 호출</h1><hr>
<p><strong>화살표 함수는 익명 함수로만 사용할 수 있기 때문에, 화살표 함수를 호출하기 위해서는 함수 표현식을 사용해야 한다.</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// ES5</span><br><span class="line">var pow = function (x) &#123; return x * x; &#125;;</span><br><span class="line">console.log(pow(5)); // 25</span><br><span class="line"></span><br><span class="line">// ES6</span><br><span class="line">const pow = x =&gt; x * x;</span><br><span class="line">console.log(pow(5)); // 25</span><br></pre></td></tr></table></figure></p>
<p>콜백함수에서도 화살표 함수를 사용할 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// ES5</span><br><span class="line">var arr = [2, 4, 6];</span><br><span class="line">var pow = arr.map(function (x) &#123; // x는 요소값</span><br><span class="line">  return x * x;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(pow); // [ 4, 16, 36 ]</span><br><span class="line"></span><br><span class="line">// ES6</span><br><span class="line">const arr = [2, 4, 6];</span><br><span class="line">const pow = arr.map(x =&gt; x * x);</span><br><span class="line"></span><br><span class="line">console.log(pow); // [ 4, 16, 36 ]</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h1 id="화살표-함수와-function으로-생성한-함수의-차이점"><a href="#화살표-함수와-function으로-생성한-함수의-차이점" class="headerlink" title="화살표 함수와 function으로 생성한 함수의 차이점"></a>화살표 함수와 function으로 생성한 함수의 차이점</h1><hr>
<p><strong>두 방식의 가장 큰 차이점은 this 이다.</strong></p>
<ul>
<li><strong>function 함수</strong>: 생성자 함수와 객체의 메소드를 제외한 모든 함수(내부 함수, 콜백 함수 포함) 내부의 this는 전역 객체를 가리킨다.</li>
<li><strong>화살표 함수</strong>: 언제나 상위 스코프의 this를 가리킨다.</li>
</ul>
<p><br></p>
<h2 id="function-키워드로-생성한-함수의-this"><a href="#function-키워드로-생성한-함수의-this" class="headerlink" title="function 키워드로 생성한 함수의 this"></a>function 키워드로 생성한 함수의 this</h2><hr>
<p>Javascirpt에서의 this는 함수를 호출할 때 함수가 어떻게 호출되었는지에 따라 this에 바인딩할 객체가 동적으로 결정된다. <a href="https://cheonmro.github.io/2018/11/01/what-is-this/">Javascript에서의 this</a>를 참고한다.</p>
<p><strong>생성자 함수와 객체의 메소드를 제외한 모든 함수(내부 함수, 콜백 함수 포함) 내부의 this는 전역 객체를 가리키기 때문이다. 즉, 콜백 함수 내부의 this는 전역 객체 window를 가리킨다.</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Prefixer(prefix) &#123;</span><br><span class="line">  this.prefix = prefix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Prefixer.prototype.prefixArray = function (arr) &#123;</span><br><span class="line">  // (1)</span><br><span class="line">  return arr.map(function (x) &#123;</span><br><span class="line">    return this.prefix + &apos; &apos; + x; // (2)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var pre = new Prefixer(&apos;Hi&apos;);</span><br><span class="line">console.log(pre.prefixArray([&apos;Ro&apos;, &apos;Park&apos;]));</span><br></pre></td></tr></table></figure></p>
<p>위치에 따라 this의 값은 달라진다.</p>
<ul>
<li>(1): 여기서, this는 생성자 함수 Prefixer가 생성한 객체, 즉 생성자 함수의 인스턴스(위 예제의 경우 pre)이다.</li>
<li>(2): 여기서, this는 전역 객체 window를 가리킨다.</li>
</ul>
<p>콜백 함수 내부의 this가 메소드를 호출한 객체(생성자 함수의 인스턴스)를 가리키게 하는 3가지 방법이 있다.</p>
<ol>
<li>that = this</li>
<li>map(func, this)</li>
<li>bind(this)</li>
</ol>
<ol>
<li><p>that = this</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Prefixer(prefix) &#123;</span><br><span class="line">  this.prefix = prefix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Prefixer.prototype.prefixArray = function (arr) &#123;</span><br><span class="line">  var that = this;  // this: Prefixer 생성자 함수의 인스턴스</span><br><span class="line">  return arr.map(function (x) &#123;</span><br><span class="line">    return that.prefix + &apos; &apos; + x;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var pre = new Prefixer(&apos;Hi&apos;);</span><br><span class="line">console.log(pre.prefixArray([&apos;Lee&apos;, &apos;Kim&apos;]));</span><br></pre></td></tr></table></figure>
</li>
<li><p>map(func, this)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Prefixer(prefix) &#123;</span><br><span class="line">  this.prefix = prefix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Prefixer.prototype.prefixArray = function (arr) &#123;</span><br><span class="line">  return arr.map(function (x) &#123;</span><br><span class="line">    return this.prefix + &apos; &apos; + x;</span><br><span class="line">  &#125;, this); // this: Prefixer 생성자 함수의 인스턴스</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var pre = new Prefixer(&apos;Hi&apos;);</span><br><span class="line">console.log(pre.prefixArray([&apos;Lee&apos;, &apos;Kim&apos;]));</span><br></pre></td></tr></table></figure>
</li>
<li><p>bind(this)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Prefixer(prefix) &#123;</span><br><span class="line">  this.prefix = prefix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Prefixer.prototype.prefixArray = function (arr) &#123;</span><br><span class="line">  return arr.map(function (x) &#123;</span><br><span class="line">    return this.prefix + &apos; &apos; + x;</span><br><span class="line">  &#125;.bind(this)); // this: Prefixer 생성자 함수의 인스턴스</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var pre = new Prefixer(&apos;Hi&apos;);</span><br><span class="line">console.log(pre.prefixArray([&apos;Ro&apos;, &apos;Park&apos;]));</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><br></p>
<h2 id="화살표-함수의-this"><a href="#화살표-함수의-this" class="headerlink" title="화살표 함수의 this"></a>화살표 함수의 this</h2><hr>
<p><strong>화살표 함수의 this는 언제나 상위 스코프의 this를 가리킨다.</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Prefixer(prefix) &#123;</span><br><span class="line">  this.prefix = prefix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Prefixer.prototype.prefixArray = function (arr) &#123;</span><br><span class="line">  // this는 상위 스코프인 prefixArray 메소드 내의 this를 가리킨다.</span><br><span class="line">  return arr.map(x =&gt; `$&#123;this.prefix&#125;  $&#123;x&#125;`);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const pre = new Prefixer(&apos;Hi&apos;);</span><br><span class="line">console.log(pre.prefixArray([&apos;Ro&apos;, &apos;Park&apos;]));</span><br></pre></td></tr></table></figure></p>
<p>화살표 함수는 call, applay, bind 메소드를 사용하여 this를 변경할 수 없다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">window.x = 1;</span><br><span class="line">const normal = function () &#123; return this.x; &#125;;</span><br><span class="line">const arrow = () =&gt; this.x;</span><br><span class="line"></span><br><span class="line">console.log(normal.call(&#123; x: 10 &#125;)); // 10</span><br><span class="line">console.log(arrow.call(&#123; x: 10 &#125;));  // 1</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h1 id="화살표-함수를-사용하면-안되는-경우"><a href="#화살표-함수를-사용하면-안되는-경우" class="headerlink" title="화살표 함수를 사용하면 안되는 경우"></a>화살표 함수를 사용하면 안되는 경우</h1><hr>
<p>화살표 함수는 Lexical this를 지원하므로 콜백 함수로 사용하기 편리하지만, 화살표 함수를 사용하지 말아야 하는 경우도 있다.</p>
<h2 id="메소드"><a href="#메소드" class="headerlink" title=" 메소드"></a><1> 메소드</1></h2><hr>
<p>메소드를 정의할 때는, 화살표 함수를 사용하면 안된다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">  name: &apos;Ro&apos;,</span><br><span class="line">  sayHi: () =&gt; console.log(`Hi $&#123;this.name&#125;`)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.sayHi(); // Hi undefined</span><br></pre></td></tr></table></figure></p>
<p>위와 같이, sayHi라는 메소드를 정의할 때 화살표 함수를 사용하게 되면, 화살표 함수 내부의 this는 상위 컨택스트인 전역 객체 window를 가리킨다.</p>
<p>ES6의 축약 메소드 표현을 사용하면, 다음과 같이 작성할 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">  name: &apos;Ro&apos;,</span><br><span class="line">  sayHi() &#123; // === sayHi: function() &#123;</span><br><span class="line">    console.log(`Hi $&#123;this.name&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.sayHi(); // Hi Ro</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="prototype"><a href="#prototype" class="headerlink" title=" prototype"></a><2> prototype</2></h2><hr>
<p>prototype에 할당하기 위한 메소드를 정의할 때는, 화살표 함수를 사용하면 안된다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">  name: &apos;Ro&apos;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.prototype.sayHi = () =&gt; console.log(`Hi $&#123;this.name&#125;`);</span><br><span class="line"></span><br><span class="line">person.sayHi(); // Hi undefined</span><br></pre></td></tr></table></figure></p>
<p>prototype에 메소드를 할당하는 경우, 일반 함수를 사용해야 한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">  name: &apos;Ro&apos;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.prototype.sayHi = function() &#123;</span><br><span class="line">  console.log(`Hi $&#123;this.name&#125;`);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.sayHi(); // Hi Ro</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="생성자-함수"><a href="#생성자-함수" class="headerlink" title=" 생성자 함수"></a><3> 생성자 함수</3></h2><hr>
<p>생성자 함수를 사용할 때는, 화살표 함수를 사용하면 안된다. 생성자 함수는 prototype 프로퍼티를 가지며 prototype 프로퍼티가 가리키는 프로토타입 객체의 constructor를 사용한다. 그러나, 화살표 함수는 prototype 프로퍼티를 가지고 있지 않다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const Foo = () =&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// 화살표 함수는 prototype 프로퍼티가 없다</span><br><span class="line">console.log(Foo.hasOwnProperty(&apos;prototype&apos;)); // false</span><br><span class="line"></span><br><span class="line">const foo = new Foo(); // TypeError: Foo is not a constructor</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="addEventListener-함수의-콜백-함수"><a href="#addEventListener-함수의-콜백-함수" class="headerlink" title=" addEventListener 함수의 콜백 함수"></a><4> addEventListener 함수의 콜백 함수</4></h2><hr>
<p>addEventListener 함수의 콜백 함수를 사용할 때는, 화살표 함수를 사용하면 안된다.</p>
<p>만약, addEventListener 함수의 콜백 함수를 화살표 함수로 정의하면, 화살표 함수 내의 this는 상위 컨택스트인 전역 객체 window를 가리킨다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var button = document.getElementById(&apos;myButton&apos;);</span><br><span class="line"></span><br><span class="line">button.addEventListener(&apos;click&apos;, () =&gt; &#123;</span><br><span class="line">  console.log(this === window); // =&gt; true</span><br><span class="line">  this.innerHTML = &apos;Clicked button&apos;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>그래서, addEventListener 함수의 콜백 함수를 사용할 때는, 일반 함수인 function 키워드를 사용해야 한다. 일반 함수로 정의된 addEventListener 함수의 콜백 함수 내부의 this는 이벤트 리스너에 바인딩된 요소(currentTarget)를 가리킨다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var button = document.getElementById(&apos;myButton&apos;);</span><br><span class="line"></span><br><span class="line">button.addEventListener(&apos;click&apos;, function() &#123;</span><br><span class="line">  console.log(this === button); // =&gt; true</span><br><span class="line">  this.innerHTML = &apos;Clicked button&apos;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h1 id="Vue에서-화살표-함수-사용방법"><a href="#Vue에서-화살표-함수-사용방법" class="headerlink" title="Vue에서 화살표 함수 사용방법"></a>Vue에서 화살표 함수 사용방법</h1><hr>
<p>Vue에서 화살표 함수는 기본적으로 ES6에서의 화살표 함수와 동일하다.</p>
<p>화살표 함수의 사용 여부에 대한 대표적인 경우는 2가지이다.</p>
<ul>
<li>메소드를 정의할 때</li>
<li>콜백함수를 정의할 때</li>
</ul>
<p><br></p>
<h2 id="Vue에서-메소드를-정의할-때"><a href="#Vue에서-메소드를-정의할-때" class="headerlink" title="Vue에서 메소드를 정의할 때"></a>Vue에서 메소드를 정의할 때</h2><hr>
<p>Vue에서 메소드를 정의할 때는, 화살표 함수를 사용하면 안된다. 즉, function 키워드를 사용하는 일반 함수로 정의해야 한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot; v-model=&quot;newTodo&quot;&gt;</span><br><span class="line">      &lt;button v-on:click=&quot;addTodo&quot;&gt;add&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data: () =&gt; (&#123;</span><br><span class="line">        newTodo: &apos;&apos;</span><br><span class="line">    &#125;),</span><br><span class="line">    methods: &#123;</span><br><span class="line">        addTodo: function () &#123;</span><br><span class="line">            console.log(this.newTodo); // input에서 입력한 값을 가져옴</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>methods에서 <code>addTodo</code>를 정의할 때, function 키워드를 사용하면, 이 함수내의 this는 Vue 인스턴스를 가리킨다. 그래서, <code>this.newTodo</code>의 값을 가져올 수 있다.</p>
<p>만약, 화살표 함수로 <code>addTodo</code>를 정의하면 어떻게 될까?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot; v-model=&quot;newTodo&quot;&gt;</span><br><span class="line">      &lt;button v-on:click=&quot;addTodo&quot;&gt;add&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data: () =&gt; (&#123;</span><br><span class="line">        newTodo: &apos;&apos;</span><br><span class="line">    &#125;),</span><br><span class="line">    methods: &#123;</span><br><span class="line">        addTodo: () =&gt; &#123;</span><br><span class="line">            console.log(this.newTodo); // undefined</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>화살표 함수로 <code>addTodo</code>를 정의하면, 이 함수내의 this는 전역객체 window를 가리킨다. 그래서 값이 <code>undefined</code>가 된다.</p>
<p>대신, ES6의 축약 메소드 표현을 사용하면, 다음과 같이 작성할 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    addTodo () &#123;</span><br><span class="line">        console.log(this.newTodoItem) // input에서 입력한 값을 가져옴</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="Vue에서-콜백-함수를-정의할-때"><a href="#Vue에서-콜백-함수를-정의할-때" class="headerlink" title="Vue에서 콜백 함수를 정의할 때"></a>Vue에서 콜백 함수를 정의할 때</h2><hr>
<p>Vue에서 콜백 함수를 정의할 때, 화살표 함수를 사용하면, 정의된 콜백 함수내의 this는 Vue의 인스턴스를 가리킨다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line"></span><br><span class="line">  data: &#123;</span><br><span class="line">    size: &apos;small&apos;,</span><br><span class="line">    items: [ &#123; size: &apos;small&apos; &#125;, &#123; size: &apos;large&apos; &#125; ]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  computed: &#123;</span><br><span class="line">    filterBySize() &#123;</span><br><span class="line">      return this.items.filter((item) =&gt; &#123;</span><br><span class="line">        return item.size === this.size; // this는 Vue의 인스턴스를 가리킴</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>만약, 콜백 함수를 정의할 때, function 키워드를 사용하면, 정의된 콜백 함수내의 this는 상위 컨택스트, 즉 전역 객체 window를 가리킨다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line"></span><br><span class="line">  data: &#123;</span><br><span class="line">    size: &apos;small&apos;,</span><br><span class="line">    items: [ &#123; size: &apos;small&apos; &#125;, &#123; size: &apos;large&apos; &#125; ]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  computed: &#123;</span><br><span class="line">    filterBySize() &#123;</span><br><span class="line">      let size = this.size // 여기서 this는 Vue 인스턴스를 가리키기 때문에, 미리 size라는 변수에 위 data의 size의 값을 할당</span><br><span class="line">      return this.items.filter(function(item) &#123;</span><br><span class="line">        return item.size === size;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h1 id="결론-Vue에서의-화살표-함수-및-일반-함수-사용-방법"><a href="#결론-Vue에서의-화살표-함수-및-일반-함수-사용-방법" class="headerlink" title="결론: Vue에서의 화살표 함수 및 일반 함수 사용 방법"></a>결론: Vue에서의 화살표 함수 및 일반 함수 사용 방법</h1><hr>
<ul>
<li><strong>메소드를 정의할 때는, 일반 함수를 사용한다.</strong> 이때, funtion 키워드르 안쓰고 싶다면, ES6의 축약 메소드 표현을 사용해서, 간단히 작성하면 된다.</li>
<li><strong>콜백 함수를 정의할 때는, 화살표 함수를 사용한다.</strong> 이때, 정의된 콜백 함수내의 this는 해당 컨택스트, 즉 정의된 콜백 함수를 가지고 있는 Vue 인스턴스를 가리킨다.</li>
</ul>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/ES6/">ES6</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Arrow-Function/">Arrow Function</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-computed-methods"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/01/01/computed-methods/">Computed vs. Methods vs. Watch</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/01/01/computed-methods/" class="article-date">
	  <time datetime="2019-01-01T11:26:03.000Z" itemprop="datePublished">January 1, 2019</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Vue/">Vue</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Computed-vs-Methods"><a href="#Computed-vs-Methods" class="headerlink" title="Computed vs. Methods"></a>Computed vs. Methods</h1><hr>
<p><strong>핵심은 캐싱(값의 저장)이 있냐 없냐에 차이다.</strong></p>
<p><strong>공통점</strong>: <strong>둘 다 인스턴내에서 함수를 정의하는 부분이고, 데이터가 변동됨에 따라 안에 있는 함수를 재호출하게 된다.</strong><br><strong>차이점</strong>: <strong>데이터가 변동되지 않는다고 가정했을 때이다.</strong></p>
<ul>
<li><strong>Computed: 종속 대상의 값이 저장(캐싱) 되어, 이미 계산되어진 값을 가져온다.</strong><ul>
<li>종속된 대상이 변경될 때만, 함수를 실행하고, 종속 대상이 변경되지 않으면, computed를 여러번 요청해도 계산을 다시 하지 않고, 계산되어 있는(computed) 결과를 즉시 반환한다.</li>
<li>데이터 변동이 없는 상태에서, 이전의 계산된 값을 캐시해 두었다가 함수 호출시 재사용한다.</li>
</ul>
</li>
<li><strong>methods: 렌더링을 다시 할때마다, 항상 함수를 실행하여 함수의 로직에 결과물을 반환한다.</strong><ul>
<li>사용할때마다, 함수의 계산을 다시 한다.</li>
</ul>
</li>
</ul>
<p><br></p>
<h2 id="캐싱이-왜-필요할까"><a href="#캐싱이-왜-필요할까" class="headerlink" title="캐싱이 왜 필요할까?"></a>캐싱이 왜 필요할까?</h2><hr>
<p>computed의 속성이 계산이 많이 걸리는 함수라고 하자. 만약, 캐싱을 하지 않으면, computed의 속성의 getter 함수를 꼭 필요한 것보다 더 많이 실행하게 된다. 그래서, 캐싱을 원하지 않으면, methods를 사용한다.</p>
<p><br></p>
<h1 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h1><hr>
<ul>
<li><strong>데이터가 자주 변동되지 않으면, 비용적인 면에서는 computed가 좋다.</strong></li>
<li><strong>데이터가 수시로 없데이트 되면, 계속해서 캐시를 저장하는 computed보다 methods가 더 좋다.</strong></li>
</ul>
<p>그래서, html에서는 computed는 변수처럼 쓰이고, methods는 함수처럼 쓰인다.<br>예) parse 함수</p>
<ul>
<li>Computed: parse를 그대로 사용한다.</li>
<li>Methods: parse() 이런식으로 사용한다.</li>
</ul>
<p><br></p>
<h1 id="Computed-vs-Watch"><a href="#Computed-vs-Watch" class="headerlink" title="Computed vs. Watch"></a>Computed vs. Watch</h1><hr>
<ul>
<li>Watch: 감시할 데이터를 지정하고 그 데이터가 바뀌면 이런 함수를 실행하라는 방식으로 소프트웨어 공학에서 이야기하는 ‘명령형 프로그래밍’ 방식</li>
<li>Computed: 계산해야 하는 목표 데이터를 정의하는 방식으로 소프트웨어 공학에서 이야기하는 ‘선언형 프로그래밍’ 방식</li>
</ul>
<p><br></p>
<h1 id="Computed-Watch는-언제-왜-사용해야-할까"><a href="#Computed-Watch는-언제-왜-사용해야-할까" class="headerlink" title="Computed/Watch는 언제, 왜 사용해야 할까?"></a>Computed/Watch는 언제, 왜 사용해야 할까?</h1><hr>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Vue/">Vue</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Computed/">Computed</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Methods/">Methods</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue/">Vue</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-vue-routing"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/01/01/vue-routing/">Vue에서 Routing 사용하는 방법</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/01/01/vue-routing/" class="article-date">
	  <time datetime="2019-01-01T10:37:12.000Z" itemprop="datePublished">January 1, 2019</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Vue/">Vue</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Routing-라우팅-이란-무엇인가"><a href="#Routing-라우팅-이란-무엇인가" class="headerlink" title="Routing(라우팅)이란 무엇인가?"></a>Routing(라우팅)이란 무엇인가?</h1><hr>
<p><strong>라우팅</strong>이란, <strong>웹 페이지간의 이동 방법을 말하며, 웹 앱의 형식 중 하나인 SPA에서 주로 사용한다.</strong></p>
<p>라우팅의 장점은 화면 간의 전환이 매끄러워, UX를 향상 시킬 수 있다.</p>
<p>일반적인 웹(MPA)에서는 특정 행동(링크 클릭, 또는 특정 이벤트)를 한 후, 페이지를 이동하게 되면, 흰색의 빈 페이지가 깜박거린 후, 이동된 화면이 나타나게 된다. 이런 부분들을 라우팅으로 처리하면 깜빡러미 없이 매끄럽게 화면이 전환될 수 있다.</p>
<p><br></p>
<h1 id="Vue에서의-라우팅"><a href="#Vue에서의-라우팅" class="headerlink" title="Vue에서의 라우팅"></a>Vue에서의 라우팅</h1><hr>
<p>Vue 라우터는 Vue에서 라우팅을 할 수 있도록 지원하는 공식 라이브러리이다.</p>
<p><br></p>
<h2 id="Vue에서-라우팅-설치-및-등록"><a href="#Vue에서-라우팅-설치-및-등록" class="headerlink" title="Vue에서 라우팅 설치 및 등록"></a>Vue에서 라우팅 설치 및 등록</h2><hr>
<p>&lt;설치&gt;</p>
<p><code>Npm install vue-router</code></p>
<p>&lt;등록&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Import VueRouter from ‘vue-router’</span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter)</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="기본적인-Vue-Routing-사용법"><a href="#기본적인-Vue-Routing-사용법" class="headerlink" title="기본적인 Vue Routing 사용법"></a>기본적인 Vue Routing 사용법</h2><hr>
<p>Vue 라우터 라이브러리를 사용하면, 2개의 tag를 사용한다.</p>
<ul>
<li><code>&lt;router-link to=“url&quot;&gt;</code>: 페이지 이동 태그로, 화면에서는 <code>&lt;a&gt;</code>로 표시되며 클릭하게되면, to속성에 입력한 URL로 이동</li>
<li><code>&lt;router-view&gt;</code>: 페이지 표시 태그로, 변경되는 URL에 따라 해당 컴포넌트를 출력해주는 영역</li>
</ul>
<p>기본적인 라우팅을 만들어보자. 위에 버튼 두개가 있는데, 왼쪽은 todo 페이지로 이동, 오른쪽은 user 페이지로 이동하는 라우팅을 만들어 보자.</p>
<p><strong>(1) vue-router를 설치하고, router.js를 만들어 다음과 같이 작성한다.</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// router.js</span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import VueRouter from &apos;vue-router&apos;</span><br><span class="line">import Todo from &apos;./components/Todo.vue&apos;</span><br><span class="line">import User from &apos;./components/User.vue&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">    mode: &apos;history&apos;,</span><br><span class="line">    routes: [</span><br><span class="line">      &#123; path: &apos;/&apos;, component: Todo &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path: &apos;/user&apos;,</span><br><span class="line">            component: User,</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>Todo와 User 컴포넌트를 만들고, import 한뒤, router 인스턴스를 생성하고, path와 path에 맞는 컴포넌트를 맵핑한다.</p>
<p>‘History’ mode는 기본적으로 url에 #이 들어가 있는데, 이를 제거해 준다.</p>
<p><strong>(2) main.js에 등록하여, 전역에서 사용할 수 있게 한다.</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import App from &apos;./App.vue&apos;</span><br><span class="line">import store from &apos;./store&apos;</span><br><span class="line">import router from &apos;./router&apos;</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = false</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  store,</span><br><span class="line">  router,</span><br><span class="line">  render: h =&gt; h(App),</span><br><span class="line">&#125;).$mount(&apos;#app&apos;)</span><br></pre></td></tr></table></figure></p>
<p><strong>(3) App.vue에 라우터 링크를 추가한다.</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// App.vue</span><br><span class="line">&lt;section&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;router-link to=&quot;/&quot;&gt;&lt;button&gt;Go to Todo page&lt;/button&gt;&lt;/router-link&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;router-link to=&quot;/user&quot;&gt;&lt;button&gt;Go to User page&lt;/button&gt;&lt;/router-link&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/section&gt;</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure></p>
<p>이렇게 되면, 각 버튼을 클릭하면, 각 버튼에 해당하는 path로 이동하여, path에 맵핑된 컴포넌트를 화면에 뿌려준다.</p>
<p><br></p>
<h2 id="Nested-라우팅"><a href="#Nested-라우팅" class="headerlink" title="Nested 라우팅"></a>Nested 라우팅</h2><hr>
<p><strong>Nested(중첩된) 라우터는 라우터로 페이지를 이동할 때, 최소 2개 이상의 컴포넌트를 화면에 나타내는 것을 말한다.<br>상위 컴포넌트 1개와 하위 컴포넌트 N개로 구성할 수 있다.</strong></p>
<p>예를 들어, User 페이지에서 url에 따라, User의 Profile과 User의 Post를 각각 보여주는 라우터를 만들어보자.</p>
<p><strong>(1) 두 개의 컴포넌트 UserProfile과 UserPost를 만들고, 상위 컴포넌트인 User에 그 하위 컴포넌트로 UserProfile과 UserPost를 라우팅으로 등록한다.</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// router.js</span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import VueRouter from &apos;vue-router&apos;</span><br><span class="line">import Todo from &apos;./components/Todo.vue&apos;</span><br><span class="line">import User from &apos;./components/User.vue&apos;</span><br><span class="line">import UserProfile from &apos;./components/UserProfile.vue&apos;</span><br><span class="line">import UserPost from &apos;./components/UserPost.vue&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">    mode: &apos;history&apos;,</span><br><span class="line">    routes: [</span><br><span class="line">      &#123; path: &apos;/&apos;, component: Todo &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path: &apos;/user&apos;,</span><br><span class="line">            component: User,</span><br><span class="line">            children: [</span><br><span class="line">                &#123;</span><br><span class="line">                    path: &apos;userProfile&apos;,</span><br><span class="line">                    component: UserProfile</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    path: &apos;userPost&apos;,</span><br><span class="line">                    component: UserPost</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><strong>(2) 상위 컴포넌트인 User.vue에 다음과 같이 링크를 추가한다. 이때, 상위 컴포넌트에 <code>&lt;router-view&gt;&lt;/router-view&gt;</code>를 추가하여, 상위 컴포넌트내에서 그 하위 컴포넌트들이 화면에 보이게 한다.</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// User.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;user&quot;&gt;</span><br><span class="line">        &lt;p&gt;This is User page.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">        &lt;br&gt;</span><br><span class="line"></span><br><span class="line">        &lt;router-link to=&quot;/user/userProfile&quot;&gt;UserProfile 컴포넌트로 이동&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">        &lt;br&gt;</span><br><span class="line"></span><br><span class="line">        &lt;router-link to=&quot;/user/UserPost&quot;&gt;UserPost 컴포넌트로 이동&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">        &lt;br&gt;</span><br><span class="line"></span><br><span class="line">        &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="동적-라우팅"><a href="#동적-라우팅" class="headerlink" title="동적 라우팅"></a>동적 라우팅</h2><hr>
<p><strong>동적 라우팅</strong>이란, <strong>일정한 패턴의 URI 경로를 하나의 컴포넌트에 연결하는 방법이다. 일정한 패턴의 URI란, 예를 들어, projects 페이지에서 각 페이지별로 상세하게 보고 싶은데, 이때 URI를 projects/1, projects/2 이런식으로 각 프로젝트를 id로 구별하는 것을 말한다. 이를 하나의 컴포넌트(Projects.vue)로 연결하여 사용한다.</strong></p>
<p>하나의 메인 페이지에서 어떤 링크(버튼 등)를 클릭하면, projects 페이지가 나오고, 그 projects 페이지에는 여러개의 프로젝트들이 보여진다. 그리고, 각 프로젝트를 클릭하면, 각 프로젝트에 대한 상세 정보가 나오게 한다. 이때, 클릭 시 라우팅의 URI는 projects/1 이런식으로 지정하여 만든다.</p>
<p><strong>(1) 우선, store.js에서 dummy 데이터를 만들자.</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// store.js</span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import Vuex from &apos;vuex&apos;</span><br><span class="line">import axios from &apos;axios&apos;</span><br><span class="line">import VueAxios from &apos;vue-axios&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex);</span><br><span class="line">Vue.use(VueAxios, axios);</span><br><span class="line"></span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        projects: [</span><br><span class="line">            &#123;</span><br><span class="line">                id: 1,</span><br><span class="line">                text: &apos;vue&apos;,</span><br><span class="line">                completed: false</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                id: 2,</span><br><span class="line">                text: &apos;react&apos;,</span><br><span class="line">                completed: false</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    actions: &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><strong>(2) router.js에서 Projects에 대한 path를 등록하고, 이에 대한 children으로써, Project에 대한 path를 등록한다. 이때, path는 ‘:id’로 등록한다.</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// router.js</span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import VueRouter from &apos;vue-router&apos;</span><br><span class="line">import Projects from &apos;./components/Projects.vue&apos;</span><br><span class="line">import Project from &apos;./components/Project.vue&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">    mode: &apos;history&apos;,</span><br><span class="line">    routes: [</span><br><span class="line">        &#123;</span><br><span class="line">            path: &apos;/projects&apos;,</span><br><span class="line">            component: Projects,</span><br><span class="line">            children: [</span><br><span class="line">                &#123;</span><br><span class="line">                    name: &apos;project&apos;,</span><br><span class="line">                    path: &apos;:id&apos;,</span><br><span class="line">                    component: Project</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export default router</span><br></pre></td></tr></table></figure></p>
<p><strong>(3) App.vue에서 Projects 페이지로 이동하는 라우터 링크를 작성한다. 그리고, 링크 클릭 시, Projects 페이지의 정보를 보여주기 위해, router-view를 아래에 작성한다.</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// App.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;p&gt;This is main page&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">        &lt;router-link to=&quot;/projects&quot;&gt;&lt;button&gt;Go to Project page&lt;/button&gt;&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">      &lt;br&gt;</span><br><span class="line"></span><br><span class="line">      &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>(4) Projects 페이지는 프로젝트가 나열되어 나오게 한다. 그리고, 각 프로젝트에 라우터 링크를 걸어, 그 링크를 클릭시, 클릭한 프로젝트에 대한 상세 정보가 나오는 Project 페이지가 나오게 한다. 이때, router-link에는 name과 params를 같이 넣어 주는데, 이는 router.js에서 등록한 그대로 작성하면 된다.</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// Projects.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;Projects page&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div v-for=&quot;project in projects&quot; :key=&quot;project.id&quot;&gt;</span><br><span class="line">            &lt;router-link :to=&quot;&#123; name: &apos;project&apos;, params: &#123; id: project.id &#125; &#125;&quot;&gt;</span><br><span class="line">                [ID: &#123;&#123;project.id&#125;&#125;] &#123;&#123;project.text&#125;&#125;</span><br><span class="line">            &lt;/router-link&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;br&gt;</span><br><span class="line"></span><br><span class="line">        &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    computed: &#123;</span><br><span class="line">        projects () &#123;</span><br><span class="line">            return this.$store.state.projects</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>(5) 위에서 어떤 하나의 프로젝트를 클릭하면, 그 프로젝트 컴포넌트에서 작성한 화면을 보여준다.(Project.vue). 이때, this.$route.params.id로 id에 접근할 수 있다.</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Project.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;p&gt;Project each view: &#123;&#123; this.$route.params.id &#125;&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export defualt &#123;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="Named-라우팅"><a href="#Named-라우팅" class="headerlink" title="Named 라우팅"></a>Named 라우팅</h2><hr>
<p><strong>Named 라우팅</strong>이란, <strong>각 화면의 영역을 각각 용도, 모듈별로 구분할 수 있는데, 이때, 이름으로 구분하는 것을 말한다.</strong> 일반적인 웹 앱에서는 header, footer, body로 나누어 화면을 구성한다.</p>
<p><strong>(1) App.vue에서 각 화면별로 이름을 지정하여 화면의 영역을 나눈다.</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// App.vue</span><br><span class="line">&lt;router-view name=&quot;header&quot;&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;router-view&gt;&lt;/router-view&gt;&lt;!-- name을 지정하지 않으면, default --&gt;</span><br><span class="line">&lt;router-view name=&quot;footer&quot;&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>(2) 각 화면에 대한 컴포넌트로 만든 뒤, router.js로 import 한다. 그리고, routes에 다음과 같이 지정한다.</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// router.js</span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import VueRouter from &apos;vue-router&apos;</span><br><span class="line">import Body from &apos;./components/Body.vue&apos;</span><br><span class="line">import Header from &apos;./components/Header.vue&apos;</span><br><span class="line">import Footer from &apos;./components/Footer.vue&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">    mode: &apos;history&apos;,</span><br><span class="line">    routes: [</span><br><span class="line">        &#123;</span><br><span class="line">            path: &apos;/&apos;,</span><br><span class="line">            components: &#123;</span><br><span class="line">                default: Body,</span><br><span class="line">                header: Header,</span><br><span class="line">                footer: Footer</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>‘Components’ 속성에 Key(router-view 이름)-Value(컴포넌트)로 등록하면, 컴포넌트에서 <code>&lt;router-view&gt;</code>에 각 컴포넌트의 화면이 보여진다.</p>
<p>이런 컴포넌트 구조는(Header-Body(default)-Footer) 모든 페이지의 기본형식이기 때문에, path를 ‘/‘로 사용하여, 기본페이지로 사용할 수 있다.</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Vue/">Vue</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Routing/">Routing</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue/">Vue</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-axios-and-vue"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/12/27/axios-and-vue/">Vue에서 Axios 사용하는 방법</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/12/27/axios-and-vue/" class="article-date">
	  <time datetime="2018-12-27T12:39:31.000Z" itemprop="datePublished">December 27, 2018</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Vue/">Vue</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Axios란-무엇인가"><a href="#Axios란-무엇인가" class="headerlink" title="Axios란 무엇인가?"></a>Axios란 무엇인가?</h1><hr>
<p><strong>axios란, Pormise 기반의 http 통신을 위한 클라이언트 라이브러리이다.</strong></p>
<p>vue에는 vue-resource라는 것이 있으나, 2016년 9월 이후 업데이트가 되어있지않고, Evan You(Vue 만든사람) 또한, 공식적으로 추천하지 않고, axios 쓰는 것을 추천한다.</p>
<p><br></p>
<h1 id="Axios-설치하기"><a href="#Axios-설치하기" class="headerlink" title="Axios 설치하기"></a>Axios 설치하기</h1><hr>
<p>npm으로 axios를 설치한다.</p>
<p><code>npm install axios vue-axios</code></p>
<p><br></p>
<h1 id="Axios-등록하기"><a href="#Axios-등록하기" class="headerlink" title="Axios 등록하기"></a>Axios 등록하기</h1><hr>
<p><strong>Vue 애플리케이션을 개발할 때, Vuex(store.js)의 actions에서 axios를 사용하므로, store.js에 axios를 등록한다.</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// store.js</span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import Vuex from &apos;vuex&apos;</span><br><span class="line"></span><br><span class="line">// axios &amp; vue-axios를 import</span><br><span class="line">import axios from &apos;axios&apos;</span><br><span class="line">import VueAxios from &apos;vue-axios&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex);</span><br><span class="line">// axios &amp; vue-axios를 등록</span><br><span class="line">Vue.use(VueAxios, axios);</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h1 id="Axios-사용하기"><a href="#Axios-사용하기" class="headerlink" title="Axios 사용하기"></a>Axios 사용하기</h1><hr>
<h2 id="1-JSON-server-만들기"><a href="#1-JSON-server-만들기" class="headerlink" title="1. JSON server 만들기"></a>1. JSON server 만들기</h2><hr>
<p><strong>가상의 서버에서 데이터를 만들어 사용하기 위해, 프론트엔드 개발자가 직접 JSON server를 구축하여, axios 통신을 테스트할 수 있다.</strong></p>
<p><code>npm install -g json-server</code></p>
<p><br></p>
<h2 id="2-JSON-server-만들기"><a href="#2-JSON-server-만들기" class="headerlink" title="2. JSON server 만들기"></a>2. JSON server 만들기</h2><hr>
<p><strong>JSON server에 가상 데이터를 만들기 위해, db.json 파일을 src 폴더 아래에 만들고, 다음과 같이 데이터를 추가한다.</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// db.json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;todos&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;id&quot;: &quot;1&quot;,</span><br><span class="line">         &quot;text&quot;: &quot;vue&quot;,</span><br><span class="line">         &quot;completed&quot;: false</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">          &quot;id&quot;: &quot;2&quot;,</span><br><span class="line">          &quot;text&quot;: &quot;react&quot;,</span><br><span class="line">          &quot;completed&quot;: false</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">          &quot;id&quot;: &quot;3&quot;,</span><br><span class="line">          &quot;text&quot;: &quot;angular&quot;,</span><br><span class="line">          &quot;completed&quot;: true</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">          &quot;id&quot;: &quot;4&quot;,</span><br><span class="line">          &quot;text&quot;: &quot;python&quot;,</span><br><span class="line">          &quot;completed&quot;: false</span><br><span class="line">      &#125;</span><br><span class="line">       ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="3-JSON-server-띄우기-Running"><a href="#3-JSON-server-띄우기-Running" class="headerlink" title="3. JSON server 띄우기(Running)"></a>3. JSON server 띄우기(Running)</h2><hr>
<p><code>json-server --watch src/db.json --port 4000</code></p>
<p><br></p>
<h2 id="4-Vuex-store-js-의-actions에-메소드-등록하기"><a href="#4-Vuex-store-js-의-actions에-메소드-등록하기" class="headerlink" title="4. Vuex(store.js)의 actions에 메소드 등록하기"></a>4. Vuex(store.js)의 actions에 메소드 등록하기</h2><hr>
<p>actions에 등록하고, 등록할 때, mutations를 commit하여 변경된 상태를 추적가능하게 하면 된다.</p>
<p>서버와 통신을 할 때, CRUD라는 것이 있는데, todo 앱과 비교하면 다음과 같다.</p>
<ul>
<li><strong>Create</strong>: addTodo</li>
<li><strong>Read</strong>: getTodo</li>
<li><strong>Update</strong>: changeTodo(toggle)</li>
<li><strong>Delete</strong>: deleteTodo</li>
</ul>
<p>Vuex(store.js)의 actions에 메소드 등록할 때, 위에 4가지로 나눠서 코드를 작성해보자.</p>
<p><br></p>
<h3 id="Create-addTodo"><a href="#Create-addTodo" class="headerlink" title=". Create: addTodo"></a><1>. Create: addTodo</1></h3><hr>
<p><strong>Create는 클라이언트단에서 데이터를 새로 생성하여, 서버에 추가하는 것이다. todo 앱에서는 addTodo가 된다.</strong></p>
<p>Vuex(store.js)의 actions에 메소드 등록할 때, <strong>axios의 post<strong>를 사용한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// store.js</span><br><span class="line">actions: &#123;</span><br><span class="line">  addTodo: function(context, payload) &#123;</span><br><span class="line">    // post를 사용할 때는, 요청할 uri에 보낼 데이터를 같이 요청한다.</span><br><span class="line">    axios.post(&apos;http://localhost:4000/todos&apos;, &#123;</span><br><span class="line">        id: 4,</span><br><span class="line">        text: payload,</span><br><span class="line">        completed: false</span><br><span class="line">    &#125;)</span><br><span class="line">        // 요청이 성공하면, mutations에 commit을 하여, 원래 데이터에 요청한 데이터를 추가한다.</span><br><span class="line">        .then((res) =&gt; &#123;</span><br><span class="line">            console.log(res);</span><br><span class="line">            context.commit(&apos;addTodo&apos;, res.data)</span><br><span class="line">        &#125;)</span><br><span class="line">        // 요청이 실패하면, 에러에 대한 조치를 취한다.</span><br><span class="line">        .catch((err) =&gt; &#123;</span><br><span class="line">            console.log(err);</span><br><span class="line">        &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></strong></strong></p>
<p>actions에서 commit한 mutations에 로직을 작성한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  addTodo (state, todo) &#123;</span><br><span class="line">    state.todoList = [...state.todoList, todo]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="Read-getTodo"><a href="#Read-getTodo" class="headerlink" title=". Read: getTodo"></a><2>. Read: getTodo</2></h3><hr>
<p><strong>Read는 클라이언트단에서 데이터를 서버에 요청하여, 데이터를 받는 것이다. todo 앱에서는 getTodo가 된다.</strong></p>
<p>Vuex(store.js)의 actions에 메소드 등록할 때, <strong>axios의 get</strong>을 사용한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// store.js</span><br><span class="line">actions: &#123;</span><br><span class="line">  getTodo: function(context) &#123;</span><br><span class="line">    // get을 사용할 때는, 요청할 uri를 작성한다.</span><br><span class="line">    axios.get(&apos;http://localhost:4000/todos&apos;)</span><br><span class="line">        // 요청이 성공하면, mutations에 commit을 하여, 원래 데이터에 요청받은 데이터를 할당한다.</span><br><span class="line">        .then((res) =&gt; &#123;</span><br><span class="line">            console.log(res);</span><br><span class="line">            context.commit(&apos;getTodo&apos;, res.data)</span><br><span class="line">        &#125;)</span><br><span class="line">        // 요청이 실패하면, 에러에 대한 조치를 취한다.</span><br><span class="line">        .catch((err) =&gt; &#123;</span><br><span class="line">            console.log(err);</span><br><span class="line">        &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>actions에서 commit한 mutations에 로직을 작성한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  getTodo (state, data) &#123;</span><br><span class="line">    state.todoList = data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="Update-changeTodo-toggle"><a href="#Update-changeTodo-toggle" class="headerlink" title=". Update: changeTodo(toggle)"></a><3>. Update: changeTodo(toggle)</3></h3><hr>
<p><strong>Update는 클라이언트단에서 기존에 있던 데이터를 서버에 요청하여, 데이터를 변경하는 것이다. todo 앱에서는 toggle이 된다.</strong></p>
<p>Vuex(store.js)의 actions에 메소드 등록할 때, <strong>axios의 patch</strong>를 사용한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// store.js</span><br><span class="line">actions: &#123;</span><br><span class="line">  toggle: function(context, payload) &#123;</span><br><span class="line">    // patch를 사용할 때는, 요청할 uri에 변경할 데이터의 uri를 붙여서 보낸다. 예를 들어, /todos/id가 올 수 있다.</span><br><span class="line">    axios.patch(`http://localhost:4000/todos/$&#123;payload&#125;`)</span><br><span class="line">        // 요청이 성공하면, mutations에 commit을 하여, 특정 데이터가 변경된 상태로 데이터가 변경된다.</span><br><span class="line">        .then((res) =&gt; &#123;</span><br><span class="line">            console.log(res);</span><br><span class="line">            context.commit(&apos;toggle&apos;, payload)</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch((err) =&gt; &#123;</span><br><span class="line">            console.log(err);</span><br><span class="line">        &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>actions에서 commit한 mutations에 로직을 작성한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  toggle (state, id) &#123;</span><br><span class="line">    const index = state.todolist.findIndex((item)=&gt;item.id === id);</span><br><span class="line">    state.todolist[index].completed = !this.todolist[index].completed;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="Delete-deleteTodo"><a href="#Delete-deleteTodo" class="headerlink" title=". Delete: deleteTodo"></a><4>. Delete: deleteTodo</4></h3><hr>
<p><strong>Update는 클라이언트단에서 기존에 있던 데이터를 서버에 요청하여, 데이터를 변경하는 것이다. todo 앱에서는 toggle이 된다.</strong></p>
<p>Vuex(store.js)의 actions에 메소드 등록할 때, <strong>axios의 patch</strong>를 사용한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// store.js</span><br><span class="line">actions: &#123;</span><br><span class="line">  deleteTodo: function(context, payload) &#123;</span><br><span class="line">    // delete를 사용할 때는, 요청할 uri에 제거할 데이터의 uri를 붙여서 보낸다. 예를 들어, /todos/id가 올 수 있다.</span><br><span class="line">    axios.delete(`http://localhost:4000/todos/$&#123;payload&#125;`)</span><br><span class="line">        // 요청이 성공하면, mutations에 commit을 하여, 특정 데이터가 지워진 상태로 데이터가 변경된다.</span><br><span class="line">        .then((res =&gt; &#123;</span><br><span class="line">            console.log(res);</span><br><span class="line">            context.commit(&apos;deleteTodo&apos;, payload)</span><br><span class="line">        &#125;))</span><br><span class="line">        .catch((err) =&gt; &#123;</span><br><span class="line">            console.log(err);</span><br><span class="line">        &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>actions에서 commit한 mutations에 로직을 작성한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  deleteTodo (state, id) &#123;</span><br><span class="line">    state.todoList = state.todoList.filter((t) =&gt; &#123;</span><br><span class="line">        return t.id !== id</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Vue/">Vue</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Axios/">Axios</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue/">Vue</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/4/">Next</a>
  </nav>

</section>
          <aside id="sidebar">
  
    <div style="margin: 20px 0;">
	<div id="search-form-wrap">

    <form class="search-form">
        <label style="width: 72%;">
            <span class="screen-reader-text">Search for:</span>
            <input type="search" class="search-field" style="height: 36px; width: 100%;" placeholder=" Search…" value="" name="s" title="Search for:">
        </label>
        <input type="submit" class="search-form-submit" value="Search">
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
</div>
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Connect With Us</h3>
    <div class="widget widget_athemes_social_icons">

    	<ul class="clearfix widget-social-icons">   
    	
   			<li><a href="https://github.com/cheonmro" title="Github"><i class="fa fa-github" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Weibo"><i class="fa fa-weibo" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Twitter"><i class="fa fa-twitter" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Facebook"><i class="fa fa-facebook" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Google-plus"><i class="fa fa-google-plus" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Instagram"><i class="fa fa-instagram" aria-hidden="true"></i></a></li> 

   		
   		</ul>


   		<!--
   		<ul class="clearfix widget-social-icons">   		
   		<li class="widget-si-twitter"><a href="http://twitter.com" title="Twitter"><i class="ico-twitter"></i></a></li> 
		<li class="widget-si-facebook"><a href="http://facebook.com" title="Facebook"><i class="ico-facebook"></i></a></li>
			<li class="widget-si-gplus"><a href="http://plus.google.com" title="Google+"><i class="ico-gplus"></i></a></li>
			<li class="widget-si-pinterest"><a href="http://pinterest.com" title="Pinterest"><i class="ico-pinterest"></i></a></li>
			<li class="widget-si-flickr"><a href="http://flickr.com" title="Flickr"><i class="ico-flickr"></i></a></li>
			<li class="widget-si-instagram"><a href="http://instagram.com" title="Instagram"><i class="ico-instagram"></i></a></li>
		</ul> -->

    </div>
  </div>


  
    
  <div class="widget_athemes_tabs">
    <ul id="widget-tab" class="clearfix widget-tab-nav">
      <li class="active"><a>Recent Posts</a></li>
    </ul>
    <div class="widget">
      <ul>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2019/11/13/position/">Position을 활용한 CSS 레이아웃</a></h6>
              <span>November 13, 2019</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2019/11/13/float/">Float를 활용한 CSS 레이아웃</a></h6>
              <span>November 13, 2019</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2019/11/12/aligns/">HTML 요소를 수평/수직 방향으로 정렬하는 방법</a></h6>
              <span>November 12, 2019</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2019/11/12/display-property/">display를 활용한 CSS 레이아웃</a></h6>
              <span>November 12, 2019</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2019/11/12/box-model/">CSS Box Model</a></h6>
              <span>November 12, 2019</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2019/11/11/reset-css/">Reset CSS 사용방법</a></h6>
              <span>November 11, 2019</span>
            </div>

          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/API/">API</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithms/">Algorithms</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Blockchain-Market/">Blockchain(Market)</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Blockchain-Tech/">Blockchain(Tech)</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/CSS/">CSS</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Computer-Science/">Computer Science</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ES6/">ES6</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Ethereum/">Ethereum</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ICON/">ICON</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Javascript/">Javascript</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Network/">Network</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node-js/">Node.js</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/UI/">UI</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/">Vue</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/typescript/">typescript</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>


  
</aside>
        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/about" class="mobile-nav-link">Me &amp; Projects</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2019 Hexo All Rights Reserved.
        
            <span id="busuanzi_container_site_uv">
              本站访客数<span id="busuanzi_value_site_uv"></span>人次  
              本站总访问量<span id="busuanzi_value_site_pv"></span>次
            </span>
          
      </div>
      <div class="site-credit">
        Theme by <a href="https://github.com/iTimeTraveler/hexo-theme-hipaper" target="_blank">hipaper</a>
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
    
</script>
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>


<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-125478847-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->






  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
</body>
</html>
