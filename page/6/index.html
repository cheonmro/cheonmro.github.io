<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Page 6 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://cheonmro.github.io/page/6/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >
  <link rel="stylesheet" href="/css/fashion.css" >
  <link rel="stylesheet" href="/css/glyphs.css" >

</head>



  <body>


  


<header id="allheader" class="site-header" role="banner"
   >
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" rel="home" >
                <img style="margin-bottom: 10px;"  width="124px" height="124px" alt="Hike News" src="https://hexo.io/logo.svg">
              </a>
            
          </h1>

          

          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>

            <div class="clearfix sf-menu">
              <ul id="main-nav" class="menu sf-js-enabled sf-arrows"  style="touch-action: pan-y;">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/">Home</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/categories">Categories</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/about">me &amp; projects</a> </li>
                    
              </ul>
            </div>
          </nav>

      </div>
  </div>
</header>


  <div id="container">
    <div id="wrap">

      <div id="content" class="outer">
        
          <section id="main">
  
    <article id="post-what-is-prototype"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/11/01/what-is-prototype/">Prototype이란 무엇인가?</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/11/01/what-is-prototype/" class="article-date">
	  <time datetime="2018-10-31T15:59:03.000Z" itemprop="datePublished">November 1, 2018</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Javascript/">Javascript</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Prototype과-Prototype-Architecture"><a href="#Prototype과-Prototype-Architecture" class="headerlink" title="Prototype과 Prototype Architecture"></a>Prototype과 Prototype Architecture</h1><hr>
<p>Prototype(객체)이란, 새로 생성된 인스턴스(객체)의 부모의 역할을 하는 객체를 말한다. 여기서 부모의 역할이란, 새로 생성된 인스턴스(객체)가 부모 객체의 프로퍼티 또는 메소드를 상속받아 사용할 수 있다는 뜻이다. Prototype 객체는 생성자 함수에 의해 생성된 각각의 객체에 공유 프로퍼티를 제공하기 위해 사용한다.</p>
<p>Java, C++과 같은 클래스 기반 객체지향 프로그래밍 언어와 달리 자바스크립트는 프로토타입 기반 객체지향 프로그래밍 언어이다.</p>
<p>클래스 기반 객체지향 프로그래밍 언어는 객체 생성 이전에 클래스를 정의하고 이를 통해 객체(인스턴스)를 생성한다. 하지만 프로토타입 기반 객체지향 프로그래밍 언어는 클래스 없이(Class-less)도 객체 리터럴 방식 또는 생성자 함수를 이용해서 객체를 생성할 수 있다. (ECMAScript 6에서 클래스가 추가되었다)</p>
<p><br></p>
<p>기본적으로 Prototype과 관련된 개념은 다음과 같다.</p>
<p><img src="/images/prototype.png" alt="Prototype Architecture"><br>출처: <a href="https://poiemaweb.com/js-prototype" target="_blank" rel="noopener">Prototype Architecture</a></p>
<p>어떤 생성자 함수(Person 생성자 함수)에 의해 인스턴스(foo 객체)가 생성되면, 그 인스턴스의 부모 역할을 하는 프로토타입 객체(Person.prototype)가 결정된다. 위 그림에서, 생성된 인스턴스는 name, gender 프로퍼티와, sayHello 메소드를 가지고 있다.</p>
<p>ECMAScript spec에서는 자바스크립트의 모든 객체는 자신의 프로토타입을 가리키는 [[Prototype]]이라는 숨겨진 프로퍼티를 가진다 라고 되어있다. 크롬, 파이어폭스 등에서는 숨겨진 <code>[[Prototype]]</code> 프로퍼티가 <code>__proto__</code> 프로퍼티로 구현되어 있다. 즉, <code>__proto__</code>과 <code>[[Prototype]]</code>은 같은 개념이다.</p>
<p>foo 객체는 <code>__proto__</code> 프로퍼티로 자신의 부모 객체(프로토타입 객체)인 Person.prototype을 가리키고 있다.</p>
<p>객체를 생성할 때 프로토타입은 결정된다. 결정된 프로토타입 객체는 다른 임의의 객체로 변경할 수 있다. 이것은 부모 객체인 프로토타입을 동적으로 변경할 수 있다는 것을 의미한다. 이러한 특징을 활용하여 객체의 상속을 구현할 수 있다.</p>
<!-- # Javascript 동작원리
---

# [[Prototype]] 프로퍼티 v. prototype 프로퍼티
--- -->
<p><br></p>
<h1 id="constructor-프로퍼티"><a href="#constructor-프로퍼티" class="headerlink" title="constructor 프로퍼티"></a>constructor 프로퍼티</h1><hr>
<p>프로토타입 객체는 constructor 프로퍼티를 갖는다. 이 constructor 프로퍼티는 객체의 입장에서 자신을 생성한 객체를 가리킨다.</p>
<p>예를 들어 Person() 생성자 함수에 의해 생성된 객체를 foo라 하자. 이 foo 객체를 생성한 객체는 Person() 생성자 함수이다. 이때 foo 객체 입장에서 자신을 생성한 객체는 Person() 생성자 함수이며, foo 객체의 프로토타입 객체는 Person.prototype이다. 따라서 프로토타입 객체 Person.prototype의 constructor 프로퍼티는 Person() 생성자 함수를 가리킨다.</p>
<p><br></p>
<h1 id="Prototype-Chain"><a href="#Prototype-Chain" class="headerlink" title="Prototype Chain"></a>Prototype Chain</h1><hr>
<p>자바스크립트는 특정 객체의 프로퍼티나 메소드에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티 또는 메소드가 없다면 [[Prototype]] 프로퍼티가 가리키는 링크를 따라 자신의 부모 역할을 하는 프로토타입 객체의 프로퍼티나 메소드를 차례대로 검색한다. 이것을 프로토타입 체인이라 한다.</p>
<p><br></p>
<h1 id="프로토타입-체인-동작-조건"><a href="#프로토타입-체인-동작-조건" class="headerlink" title="프로토타입 체인 동작 조건"></a>프로토타입 체인 동작 조건</h1><hr>
<p>객체의 프로퍼티를 참조하는 경우, 해당 객체에 프로퍼티가 없는 경우, 프로토타입 체인이 동작한다.</p>
<p>객체의 프로퍼티에 값을 할당하는 경우, 프로토타입 체인이 동작하지 않는다. 이는 객체에 해당 프로퍼티가 있는 경우, 값을 재할당하고 해당 프로퍼티가 없는 경우는 해당 객체에 프로퍼티를 동적으로 추가하기 때문이다.</p>
<p><br></p>
<p><img src="/images/condition_prototype_chaining.png" alt="프로토타입 체인 동작 조건"><br>출처: <a href="https://poiemaweb.com/js-prototype" target="_blank" rel="noopener">프로토타입 체인 동작 조건</a></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Javascript/">Javascript</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Prototype/">Prototype</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-what-is-closures"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/10/31/what-is-closures/">Closure란 무엇인가?</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/10/31/what-is-closures/" class="article-date">
	  <time datetime="2018-10-31T14:52:06.000Z" itemprop="datePublished">October 31, 2018</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Javascript/">Javascript</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="클로저-Closure"><a href="#클로저-Closure" class="headerlink" title="클로저(Closure)"></a>클로저(Closure)</h1><hr>
<p><strong>클로저</strong>란, 외부함수와 내부함수가 있을 때, 외부함수에 의해 내부함수가 반환된 이후에도, 내부함수에서 외부함수에 있는 변수를 참조할 수 있는 것을 말한다.</p>
<p>조건 3가지</p>
<ul>
<li>외부함수와 내부함수가 존재</li>
<li>내부함수가 외부함수에 있는 변수를 참조해야 한다.</li>
<li>외부함수가 내부함수를 return(라이프사이클과 관련) 해야한다.</li>
</ul>
<p>내부함수가 외부함수보다 더 긴 라이프 사이클을 가지고 있을때,<br>외부함수에 있는 변수를 내부함수가 참조하는데, 그 변수의 값은 유지되어있다.</p>
<p>실행 컨텍스트의 관점에서 이해해보자.</p>
<p>기본적으로 실행 컨텍스트는 함수가 종료되면, 실행 컨텍스트 스택에서 제거된다. 그래서 외부함수에서 내부함수를 반환하고, 모두 실행이 되면, 외부함수의 실행 컨텍스트는 제거된다. 그럼에도 불구하고, 내부함수에서 외부함수의 실행 컨텍스트 내에 있는 활성 객체는 유효하기 때문에, 내부함수에서 외부함수의 변수를 참조할 수 있다. (이때, 이 변수를 자유변수라고 한다.) 이는 내부함수가 스코프 체인을 통해 참조하려는 변수를 먼저 내부함수에서 찾고(내부함수 안에 있는 스코프체인의 ‘0’이 가리키는 활성객체에 참조하려는 변수가 있는지 확인한다.), 없으면, 상위지역인 외부함수에서 찾는다.(내부함수 안에 있는 스코프체인의 ‘1’이 가리키는 활성객체, 즉 외부함수의 활성객체에 들어있는 변수를 말한다.) 이때 내부함수가 외부함수에 있는 변수의 복사본이 아니라, 실제 변수에 접근하는 것이다.</p>
<p>위 내용을 예제와 함께 요약하면 다음과 같다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function outerFunc() &#123;</span><br><span class="line">  var x = 10;</span><br><span class="line">  var innerFunc = function () &#123; console.log(x); &#125;;</span><br><span class="line">  return innerFunc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var inner = outerFunc();</span><br><span class="line">inner(); // 10</span><br></pre></td></tr></table></figure></p>
<p>순서</p>
<ul>
<li>외부함수(outerFunc)가 내부함수(innerFunc)를 반환하고, 외부함수는 종료된다.(이때, 외부함수의 실행 컨텍스트는 실행 컨텍스트 스택에서 제거된다.)</li>
<li>내부함수에서 변수 x를 참조하려 할 때, 먼저 내부함수(자기자신) 내에서 그 변수를 찾는다.(내부함수의 스코프체인의 ‘0’이 가리키는 활성객체내에 변수 x를 찾는다.)</li>
<li>내부함수내에 없으면, 그 내부함수를 포함하고 있는 외부함수 내에서 그 변수를 찾는다.(내부함수의 스코프체인의 ‘1’이 가리키는 활성객체내에 변수 x를 찾아 참조한다.)</li>
<li>이때 내부함수가 외부함수에 있는 변수의 복사본이 아니라, 실제 변수에 접근한다.!</li>
</ul>
<p><br></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Javascript/">Javascript</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Closures/">Closures</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-what-is-execution-context"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/10/31/what-is-execution-context/">실행 컨텍스트란 무엇인가?</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/10/31/what-is-execution-context/" class="article-date">
	  <time datetime="2018-10-31T14:42:23.000Z" itemprop="datePublished">October 31, 2018</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Javascript/">Javascript</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="실행-컨텍스트-Execution-Context"><a href="#실행-컨텍스트-Execution-Context" class="headerlink" title="실행 컨텍스트(Execution Context)"></a>실행 컨텍스트(Execution Context)</h1><hr>
<p><strong>실행 컨텍스트</strong>란, 실행 가능한 코드가 실행되기 위해 필요한 환경을 의미하는데, 이 환경은 코드가 실행되기 전에 설정이 된다. 이때, 실행 가능한 코드는 총 3개(전역코드/함수코드/Eval코드)가 있는데, 일반적으로 전역코드/함수코드를 말한다. 여기서 환경이 설정된다는 것은 실행에 필요한 여러가지 정보를 담는다는 뜻이다.</p>
<p>코드가 전역변수와 외부함수 그리고 그 안에 내부함수 있다고 해보자.</p>
<p>코드가 실행되기 전, 전역에 실행 컨텍스트가 생성이 되는데, 이것을 전역 실행 컨텍스트라고 한다. 전역 실행 컨텍스트가 생성이 되면, 실행 컨텍스트 스택(콜 스택)에 추가된다. 그리고, 외부함수가 호출이 되면, 외부함수가 실행되기 전에 외부함수에 대한 실행 컨텍스트가 생성이 되는데, 이것을 함수 실행 컨텍스트라고 한다. 이 외부함수 실행 컨텍스트 또한 실행 컨텍스트 스택에 그 전에 추가된 전역 실행 컨텍스트 위에 쌓이게 된다. 내부함수 또한 호출되면, 내부함수 실행되기 전에 내부함수 실행 컨텍스트가 생성되고, 실행 컨텍스트 스택에 있는 외부함수 실행 컨텍스트 위에 쌓이게 된다.</p>
<p>전체적인 과정에서 봤을때, 코드의 종류(전역코드/함수코드)에 따라 실행 컨텍스트가 생성되고, 실행 컨텍스트 스택에 쌓이는 구조이다.</p>
<p>실행 컨텍스트가 생성되고 코드가 실행되기 전에, 실행 컨텍스트는 3가지 프로퍼티를 가지게 된다.</p>
<ul>
<li>Scope Chain</li>
<li>VO(변수객체)</li>
<li>thisvalue</li>
</ul>
<p>실행 컨텍스트가 생성이 되면, 먼저 Scope Chain이라는 전역 객체 또는 활성 객체를 가리키는 리스트가 생성되고 초기화 된다. 리스트는 배열처럼 ‘0’: {}, ‘1’: {}, 이런 방식으로 생성되는데, ‘0’은 자기자신(위치)를 가리키고, 1은 자기 위치의 상위 지역을 가리킨다. 예를 들어, 외부함수의 Scope Chain의 ‘0’은 자기 자신인 외부함수를 가리키고, ‘1’은 외부함수의 상위지역인 전역코드를 가리킨다. 좀 더 구체적으로 말하면, ‘0’은 자기자신(외부함수)가 가지고 있는 활성객체(A0)를 가리키고, ‘1’은 상위지역인 전역코드가 가지고 있는 전역객체(GO)를 가리킨다. 그리고, 변수 객체(VO)가 생성되어, 각 코드(전역코드/함수코드)가 가지고 있는 객체를 담는다. 전역코드의 경우, 전역함수와 전역변수를 가지고 있고, 함수코드의 경우, arguments, 내부함수, 지역변수 등을 가지고 있다.</p>
<p>this의 값은 문맥에 따라 결정이 되는데, 예외사항이 아니면 전역객체를 가리킨다.</p>
<p>위 내용을 요약하면 다음과 같다.</p>
<p>순서</p>
<ul>
<li>브라우저안에 기본적으로 전역객체(window)가 존재</li>
<li>(브라우저에서) 코드가 실행되기전, 전역 실행 컨텍스트가 생성</li>
<li>전역 실행 컨텍스트가 생성되면서, Scope Chain의 리스트 생성 및 초기화(이때, Scope Chain의 리스트 ‘0’은 전역객체를 가리킨다)</li>
<li>변수객체의 생성후, 변수객체에 전역변수 및 전역함수를 추가</li>
<li>전역함수를 추가할 때, 전역 함수 객체는 <code>[[Scopes]]</code> 프로퍼티를 가짐(이 프로퍼티는 함수 객체만이 소유하는 내부 프로퍼티로, 함수 객체가 실행되는 환경을 가리킨다.)</li>
<li>this 값이 결정되기 이전에 this는 전역 객체를 가리키다가, 함수 호출 패턴에 의해 this에 할당되는 값이 결정됨</li>
<li>전역코드가 실행(예를 들어, 전역변수에 값이 할당되고, 전역함수가 호출됨)</li>
<li>외부함수가 호출되면, 외부함수에 대한 실행 컨텍스트 생성</li>
<li>외부함수도 전역 실행 컨텍스트와 같은 방식으로 진행</li>
<li>이때, 외부함수의 변수객체에는 arguments, 내부함수, 지역변수 등이 포함됨</li>
<li>외부함수 실행</li>
<li>내부함수도 위와 동일</li>
<li>위에서 생성된 각 실행 컨텍스트가 순서대로 실행 컨텍스트 스택에 하나씩 쌓이고, 함수 실행이 끝나면, 해당 함수의 실행 컨텍스트가 제거된다. 전역 실행 컨텍스트는 애플리케이션이 종료될 때까지 유지된다.!!</li>
</ul>
<p><br></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Javascript/">Javascript</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Execution-Context/">Execution Context</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-let-and-const"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/10/31/let-and-const/">let &amp; const &amp; var</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/10/31/let-and-const/" class="article-date">
	  <time datetime="2018-10-31T13:45:37.000Z" itemprop="datePublished">October 31, 2018</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/ES6/">ES6</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="var와-let-const의-차이점"><a href="#var와-let-const의-차이점" class="headerlink" title="var와 let/const의 차이점"></a>var와 let/const의 차이점</h1><hr>
<p>ES5까지는 var를 사용했으나, var가 가지고 있는 단점들을 보완하기 위해 ES6에서는 let 과 const를 사용할 수 있다.</p>
<ol>
<li>var는 중복선언이 가능했으나, let과 const는 불가능하다.</li>
</ol>
<p>var a = 3; 이렇게 선언을 했어도, 다시 var a = 10; 이런식으로 중복 선언이 가능하다. 이는 의도치 않게 변수값을 변경하는 문제가 발생하게 된다. 하지만, let과 const로 선언을 할 경우, 중복선언을 하려고 하면, 에러가 발생하게 된다. 이렇게, let과 const를 사용하게 되면 중복선언을 미리 막을 수 있다.</p>
<ol start="2">
<li>유효범위가 다르다.</li>
</ol>
<p>var를 이용한 변수 선언은 유효범위가 함수레벨이다. 즉, 함수내에서는 지역변수이고, 함수 밖에서는 전역변수이다.<br>let과 const를 이용한 변수 선언은 유효범위가 블록레벨이다. 즉, 블록내에서는 지역변수이고, 블록 밖에서는 전역변수이다.</p>
<!-- 테이블: 특징별 비교

// 유효범위 레벨 + 중복 선언 + 호이스팅 + 전역객체
var: 함수레벨
let 과 const: 블록레벨

| 특징비교        | var           | let  |    const   |
| ------------- |:-------------:| -----:| -----:|
| 유효범위 레벨      | right-aligned | $1600 |       |
| 중복선언     | centered      |   $12 |       |
| 호이스팅 | are neat      |    $1 |       |
| 전역객체 | are neat      |    $1 |       |
| 재할당 | are neat      |    $1 |       | -->
<!-- # 각 특징비교를 코드로 설명 -->
<p><br></p>
<h1 id="let-과-const-차이점"><a href="#let-과-const-차이점" class="headerlink" title="let 과 const 차이점"></a>let 과 const 차이점</h1><hr>
<ol>
<li>const는 상수(변하지 않는 값)를 위해 사용한다.(그렇다고 꼭 상수만을 위한 것은 아니다.)</li>
<li>let은 재할당이 가능하고, const는 불가능하다.</li>
<li>const는 반드시 선언과 동시에 할당이 이루어져야 한다. 그렇지 않으면, 문법에러가 발생한다.</li>
<li>const 변수의 객체인 경우도 재할당이 불가능하다. 즉, 객체에 대한 참조를 변경하지 못한다는 것을 의미한다. 그러나, 할당된 객체의 프로퍼티 및 값은 변경할 수 있다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const user = &#123; name: &apos;Kim&apos; &#125;;</span><br><span class="line">user = &#123;&#125;; // TypeError: Assignment to constant variable.</span><br><span class="line"></span><br><span class="line">// 객체의 내용은 변경할 수 있다.</span><br><span class="line">user.name = &apos;Ro&apos;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><br></p>
<h1 id="var-와-let-과-const-활용"><a href="#var-와-let-과-const-활용" class="headerlink" title="var 와 let 과 const 활용"></a>var 와 let 과 const 활용</h1><hr>
<p>let: 재할당이 필요한 변수에 사용한다.<br>const: 재할당이 필요없는 변수에 사용한다.<br>var: ES6에서는 사용하지 않는다.</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/ES6/">ES6</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/const/">const</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/let/">let</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/var/">var</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-how-browser-works"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/10/31/how-browser-works/">브라우저 동작원리</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/10/31/how-browser-works/" class="article-date">
	  <time datetime="2018-10-31T12:59:40.000Z" itemprop="datePublished">October 31, 2018</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Network/">Network</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="브라우저-동작원리-How-Browser-Works"><a href="#브라우저-동작원리-How-Browser-Works" class="headerlink" title="브라우저 동작원리(How Browser Works)"></a>브라우저 동작원리(How Browser Works)</h1><hr>
<p>브라우저와 서버와의 통신은 다음과 같이 진행된다.</p>
<p><img src="/images/how_browser_works.png" alt="How Browser Works"><br>출처: <a href="https://poiemaweb.com/js-browser" target="_blank" rel="noopener">How Browser Works</a></p>
<p>브라우저의 핵심 기능은 사용자가 브라우저에서 URL 입력창에 어떤 사이트를 입력하게 될 때, 그 사이트의 서버에 요청(Request)을 하고, 서버로부터 응답(Response)을 받아 브라우저에 그 사이트의 웹페이지를 표시하는 것이다. 이때, 브라우저는 서버로부터 HTML, CSS, Javascript, 그리고 이미지 파일 등을 받는데, 그 과정은 다음과 같다.</p>
<ul>
<li>브라우저가 서버에 첫 요청을 하고, 서버는 먼저 index.html을 응답으로 브라우저에 보낸다.</li>
<li>브라우저의 렌더링 엔진에 있는 HTML 파서에 의해 파싱(해독)되어, DOM 트리를 생성한다.</li>
<li>HTML 파서가 html 파일을 파싱할 때, css 태그를 만나면 다시 서버에 요청하고, 서버는 css 파일을 응답으로 브라우저에 보내준다.</li>
<li>그러면, 브라우저의 렌더링 엔진에 있는 CSS 파서에 의해 파싱되어, CSSOM 트리를 생성한다.</li>
<li>또한, HTML 파서는 script 태그를 만나게 되면, 자바스크립트 코드를 실행하기 위해, DOM 생성 프로세스를 중지하고, 자바스크립트 엔진으로 제어 권한을 넘긴다.</li>
<li>그리고, 다시 서버에 요청해, 응답으로 자바스크립트 파일을 응답받아, 자바스크립트 엔진은 자바스크립트 파일을 파싱하여 실행한다.</li>
<li>자바스크립트의 실행이 완료되면, 다시 HTML 파서로 제어 권한을 넘겨서 브라우저가 중지했던 시점부터 DOM 생성을 재개한다.</li>
<li>DOM 생성이 완료되면, DOM과 CSSOM 트리는 최종적으로 렌더 트리로 결합하게 된다.</li>
<li>이 렌더 트리를 기반으로 브라우저는 웹페이지를 화면에 표시하게 된다.</li>
</ul>
<p><br></p>
<p>이처럼, 브라우저는 동기적으로 HTML/CSS/Javascript를 처리한다. 이는 script 태그의 위치에 따라 블로킹이 발생하여, DOM 생성이 지연될 수 있다는 것을 의미한다. 즉, script 태그의 위치는 중요하다.</p>
<p>그래서, body 요소의 가장 아래에 자바스크립트 태그를 위치시키는 것이 좋다. 그 이유는 다음과 같다.</p>
<ul>
<li>HTML 요소들이 자바스크립트 로딩 지연으로 인해 렌더링에 지장 받는 일이 발생하지 않기 때문에, 웹페이지 로딩 시간이 단축되기 때문이다.</li>
<li>DOM이 완성되지 않은 상태에서 자바스크립트가 DOM을 조작하게 된다면, 에러가 발생할 수 있기 때문이다.</li>
</ul>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Network/">Network</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Browser/">Browser</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-sort-algorithms"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/10/31/sort-algorithms/">정렬(sort) 알고리즘</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/10/31/sort-algorithms/" class="article-date">
	  <time datetime="2018-10-31T06:54:39.000Z" itemprop="datePublished">October 31, 2018</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Computer-Science/">Computer Science</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="정렬-알고리즘"><a href="#정렬-알고리즘" class="headerlink" title="정렬 알고리즘"></a>정렬 알고리즘</h1><hr>
<p><strong>정렬 알고리즘</strong>이란, 원소들을 번호순이나 사전 순서와 같이 일정한 순서대로 열거하는 알고리즘이다.</p>
<p>정렬 알고리즘은 명함을 어떤 순서로 정리할까?와 같은 문제이다.<br>1만장의 명함이 있고, 가나다 순으로 정리되어 있는데, 어느 날 새로운 명함을 받았다면, 그 명함을 가나다 순에 맞춰 끼워 넣어야 한다면 그 뒤에 명함들은 한 칸씩 뒤로 밀어야 하는 번거로움이 있다. 밀리는 명함이 1장일 수도 있고, 수천장일 수도 있다. 즉, 가나다 순으로 명함을 정리해두는 것이 머릿속에서는 편리하다고 생각되더라도 실제 관리하기에는 여간 불편한 것이 아니다.</p>
<p>정렬 알고리즘에서 중요한 점은 2가지다.</p>
<ul>
<li>어떤 데이터를 사용하는가?</li>
<li>어떤 정렬 조건을 사용하는가?</li>
</ul>
<p>데이터를 정렬할 때, 무조건 하나의 정렬 알고리즘을 사용하는 것은 바람직하지 않다. 데이터를 정렬할 여러 가지 조건(데이터의 개수, 사용할 수 있는 메모리의 양 등)을 분석해서 가장 합당한 정렬 알고리즘을 선택하는 지혜가 필요하다.</p>
<p><br></p>
<h1 id="정렬-알고리즘-종류"><a href="#정렬-알고리즘-종류" class="headerlink" title="정렬 알고리즘 종류"></a>정렬 알고리즘 종류</h1><hr>
<ul>
<li>퀵 정렬 알고리즘(Quick Sort)</li>
<li>병합 정렬 알고리즘(Merge Sort)</li>
<li>버블 정렬 알고리즘(Bubble Sort)</li>
<li>선택 정렬 알고리즘(Selection Sort)</li>
</ul>
<p><br></p>
<h2 id="퀵-정렬-알고리즘-Quick-Sort"><a href="#퀵-정렬-알고리즘-Quick-Sort" class="headerlink" title="퀵 정렬 알고리즘(Quick Sort)"></a>퀵 정렬 알고리즘(Quick Sort)</h2><hr>
<p><strong>퀵 정렬 알고리즘</strong>: 리스트의 한 요소를 피벗(Pivot: 기준값)으로 선정한 다음, 피벗보다 작은 요소를 하위(왼쪽) 리스트로, 피벗보다 큰 요소를 상위(오른쪽) 리스트로 이동시키는 알고리즘이다.</p>
<p>예를 들어, 배열 [3, 9, 4, 7, 5, 0, 1, 6, 8, 2] 있다고 해보자. 여기서 피벗을 5라고 정하고, 5보다 작은 요소를 왼쪽으로, 큰 요소를 오른쪽으로 보내는 작동 방식에 대해 알아보자.</p>
<ul>
<li>왼쪽 맨끝을 s(시작 포인트), 오른쪽 맨끝을 e(끝 포인트)라고 하자.</li>
<li>s부터 피벗과 비교해서, s가 피벗보다 작으면 s는 오른쪽으로 한칸 이동후, 피벗과 비교한다.</li>
<li>만약, s가 피벗보다 크면 잠깐 멈춰있고, e를 피벗과 비교하기 시작한다.</li>
<li>e가 피벗보다 크면 e는 왼쪽으로 한칸 이동후, 피벗과 다시 비교한다.</li>
<li>만약, e가 피벗보다 작으면 잠깐 멈춘후, 아까 멈춘 s의 값과 서로 바꾼다.(swap)</li>
<li>위 배열에서 s는 9가 되고, e는 2가 된다. 이 두 개의 숫자를 서로 바꾼다.</li>
<li>그럼, [3, 2, 4, 7, 5, 0, 1, 6, 8, 9] 배열이 된다.</li>
<li>그리고, 다시 s를 한칸 오른쪽으로 이동후, 피벗과 비교한다.</li>
<li>만약, s의 값이 피벗보다 클 경우, 잠깐 멈춰있고, e도 피벗과 비교하기 시작한다.</li>
<li>이런식으로 1바퀴를 돌게 되면 배열은 다음과 같다. [3, 2, 4, 1, 0, 5, 7, 6, 8, 9]</li>
<li>s와 e가 서로 정한 범위를 벗어나게 되면, 이 루프가 끝나게 된다.</li>
<li>그러면 총 2개의 partition(smaller/bigger)이 만들어진다.</li>
<li>그 다음에는, 양쪽 배열(partition)을 가지고 반복적으로 퀵 정렬 함수를 재귀적으로 호출하면, partition의 값이 1개가 될 때까지 계속적으로 반복해서 작은 값과 큰값의 위치를 바꾸게 된다.</li>
<li>이때, partition이 왼쪽/오른쪽에 1개면 더이상 재귀호출을 하지 않는다.</li>
</ul>
<p>퀵 정렬 알고리즘은 큰 데이터 집합을 가장 빨리 정렬할 수 있는 알고리즘이다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function qSort(arr) &#123;</span><br><span class="line">    if (arr.length == 0) &#123;</span><br><span class="line">        return [];</span><br><span class="line">    &#125;</span><br><span class="line">    let left = [];</span><br><span class="line">    let right = [];</span><br><span class="line">    const pivot = arr[0];</span><br><span class="line">    for (let i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (arr[i] &lt; pivot) &#123;</span><br><span class="line">           left.push(arr[i]);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">           right.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return qSort(left).concat(pivot, qSort(right));</span><br><span class="line">&#125;</span><br><span class="line">console.log(qSort([3, 9, 4, 7, 0, 1, 5, 8, 6, 2])); // [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// random input array for test</span><br><span class="line">var a = [];</span><br><span class="line">for (var i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">   a[i] = Math.floor((Math.random()*100)+1);</span><br><span class="line">&#125;</span><br><span class="line">console.log(a);</span><br><span class="line">console.log(qSort(a));</span><br></pre></td></tr></table></figure></p>
<p>위 코드의 시간복잡도를 계산하면 T(n) = nlogn 이다. 이것을 Big-O 표기법으로 나타내면 O(nlogn)이다. partion을 나누는 수가 n번인데, 이는 partion을 계속 나누다 보면, 결국 낱개가 될 때까지 나누기 때문이다. 그런데 1번 나누면, 2번째 나눌 때는 전체에서 2개로 나눈 결과를 가지고 또 나누는 것이기 때문에, 검색해야하는 데이터의 양이 줄어들었다. 마치, 이진 탐색 알고리즘과 같다. 그래서 logn번 검색하게 된다. 즉, n * logn = nlogn인 시간복잡도가 된다.</p>
<p>그러나, 예외도 있다. partion을 나누기 위한 pivot(기준값)이 전체 배열에서 최소값/최대값일 경우, 시간복잡도는 O(n^2)이 된다. 예를 들어, pivot(기준값)이 전체 배열에서 최소값일 경우, 제일 왼쪽으로 들어가고, 나머지 데이터에서 pivot(기준값)이 또 최소값이어서 이런식으로 된다면, 결국 모든 데이터를 모두 돌게 되어, 시간복잡도가 O(n^2)dl 된다. 하지만, 확률적으로 이런 경우는 거의 없기 때문에, 보통의 시간복잡도는 O(n^2)이 된다.</p>
<p><br></p>
<h2 id="병합-정렬-알고리즘-Merge-Sort"><a href="#병합-정렬-알고리즘-Merge-Sort" class="headerlink" title="병합 정렬 알고리즘(Merge Sort)"></a>병합 정렬 알고리즘(Merge Sort)</h2><hr>
<p><strong>병합 정렬 알고리즘</strong>: 함수가 호출 될때마다, 절반씩 잘라서 재귀적으로 함수를 호출하고 맨끝에 제일 작은 조각부터 두 개씩 병합해서 정렬된 배열을 병합해나가는 방식이 병합 정렬 알고리즘이다. 이미 정렬되어 있는 데이터들을 하나로 합해서 정렬하는 방법. 이러한 정렬 방법은 데이터들을 정렬하는 경우에도 사용되지만 파일에 정렬되어 있는 데이터들을 하나로 합쳐서 정렬하는 경우에도 종종 사용된다. 이미 정렬되어 있는 데이터 그룹들 혹은 묶음들을 하나로 합할 때 사용할 수 있다.</p>
<p>병합 정렬 알고리즘을 사용하는 경우 배열 하나에 저장된, 정렬되지 않은 데이터들을 어떤 방식으로 정렬하는 지 알아보자.</p>
<p>예)<br>정렬되지 않은 데이터가 있다고 해보자. 하나의 데이터 배열을 여러 개로 나누어서, 나중에 병합 하기 위해 묶는데, 이 묶은 데이터 그룹을 런(Run)이라고 한다. 2-way 방식은 2개씩 그룹으로 묶는다. 일단 2개씩 묶으면, 각 그룹별로 정렬을 한다. 예를 들어, 6과 1이 하나의 그룹으로 묶였다면, 1이 왼쪽에 오고, 6이 오른쪽에 오는 식으로 정렬을 한다. 그 다음으로는 2개의 런을 묶어서 하나의 런으로 합하도록 정렬한다. 만약 2, 3 런과 5, 7 런이 하나의 런으로 합쳐진 다음, 2, 3, 5, 7 사이에서 정렬이 된다. 이렇게 런(그룹)을 계속 합쳐나가면서 하나의 런으로 모두 합쳐 정렬하는 방식을 병합 정렬 알고리즘이라고 한다.</p>
<p>병합 정렬의 핵심은 1부터 하나의 런에 들어가는 데이터의 수를 2의 배수 기준으로 늘려서 병합하는 과정을 반복하는 것이다. 이와 같이 반복해서 병합하게 되면 결국 전체 데이터를 모두 정렬하게 되는 결과를 얻을 수 있다.</p>
<p>병합 정렬 알고리즘의 성능은 수치적으로만 보면 퀵 정렬 알고리즘과 비슷하다. 퀵 정렬 알고리즘이나 병합 정렬 알고리즘이나 데이터를 나눈 후에 재귀 호출을 사용하기 때문이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 퀵정렬과 마찬가지로 분할 정복 알고리즘중 하나이다.</span><br><span class="line">function MergeSort(arr) &#123;</span><br><span class="line">  const len = arr.length;</span><br><span class="line">  if(len == 1) &#123;</span><br><span class="line">    return arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const middle = Math.floor(len / 2);</span><br><span class="line">  const left = arr.slice(0, middle);</span><br><span class="line">  const right = arr.slice(middle, len);</span><br><span class="line"></span><br><span class="line">  function merge(left, right) &#123;</span><br><span class="line">    let result = [];</span><br><span class="line">    while(left.length &amp;&amp; right.length) &#123;</span><br><span class="line">      if( left[0] &lt;= right[0] ) &#123;</span><br><span class="line">        result.push(left.shift());</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        result.push(right.shift());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while(left.length) &#123;</span><br><span class="line">      result.push(left.shift());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while(right.length) &#123;</span><br><span class="line">      result.push(right.shift());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return merge(MergeSort(left), MergeSort(right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위 코드의 시간복잡도를 계산하면 T(n) = nlogn 이다. 이것을 Big-O 표기법으로 나타내면 O(nlogn)이다. n개 만큼씩 logn번 돌기 때문에, 병합 정렬 알고리즘의 시간복잡도는 O(nlogn)이 된다. partition이 낱개가 될 때까지 쪼개지니까 n번 호출에, 1번 호출당 검색해야하는 데이터의 양이 절반씩 줄어드니까 logn이다. 따라서 n * logn = nlogn 시간복잡도가 된다. nlogn 시간복잡도는 이진 탐색 알고리즘에서 한 번 돌 때마다 검색 영역에 절반씩 떨어지는 것과 같은 원리이다.</p>
<p>병합 정렬 알고리즘은 물리적으로 배열의 가운데 값으로 partition을 나누기 때문에 최악의 경우에도 시간복잡도는 O(nlogn)이다. 퀵 정렬 알고리즘으로 따지면, pivot(기준값)을 잘 골랐을 때랑 비슷하다. 퀵 정렬 알고리즘도 최악의 경우가 아니라면, 병합 정렬 알고리즘과 같은 시간복잡도는 O(nlogn)이다.</p>
<p>하지만, 병합 정렬 알고리즘은 실행시에 별도의 저장공간을 필요로 하기 때문에, 공간을 사용할 수 없는 경우에는 퀵 정렬 알고리즘을 사용해야 한다.</p>
<p><br></p>
<h2 id="버블-정렬-알고리즘-Bubble-Sort"><a href="#버블-정렬-알고리즘-Bubble-Sort" class="headerlink" title="버블 정렬 알고리즘(Bubble Sort)"></a>버블 정렬 알고리즘(Bubble Sort)</h2><hr>
<p><strong>버블 정렬 알고리즘</strong>: 순차적으로 바로 옆에 있는 데이터와 비교해서 옆의 데이터가 크면 자신과 위치를 바꾼다. 즉, 첫 번째 데이터가 가장 크다면 계속 옆에 있는 데이터와 자리를 바꾸면서 해당 데이터는 결국 맨 끝으로 이동하게 된다. 그리고 두 번째 위치에 있는 데이터를 또다시 옆에 있는 데이터와 비교한다. 이와 같은 과정을 마지막 데이터의 바로 전 데이터까지 반복해서 실행한다. 이 형태가 마치 버블이 부글부글 올라가는 것과 같다고 하여 버블 정렬 알고리즘이라고 한다.</p>
<p>예를 들어, [3, 5, 4, 2, 1] 배열이 있으면, 먼저 3과 5를 비교해서 3이 5보다 크면 둘을 바꾼다. 그런데 여기서는 5가 크므로 그대로 둔다. 그 다음은 5와 4를 비교한다. 이때, 5가 4보다 크므로 그 둘을 바꾼다. 그럼 [3, 4, 5, 2, 1] 배열이 이렇게 바뀐다. 이런식으로 비교하면 결국 5가 제일 마지막으로 이동하게 된다. 즉, [3, 4, 2, 1, 5] 배열이 된다. 그럼 가장 큰 수인 5가 배열에 제일 오른쪽으로 이동하게 되고, 다시 맨 처음부터 이웃 숫자끼리 비교한다. 이런식으로 가장 큰 수를 오른쪽으로 이동시켜 정렬하는 방식을 버블 정렬 알고리즘이라고 한다.</p>
<p>성능이 좋은 편이 아니라, 자주 사용되지는 않는다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 스왑 헬퍼 =&gt; 배열의 위치를 바꾼다.</span><br><span class="line">function swap(arr, index1, index2) &#123;</span><br><span class="line">  let temp = arr[index1];</span><br><span class="line">  arr[index1] = arr[index2];</span><br><span class="line">  arr[index2] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 버블 정렬은 서로 이웃한 데이터들을 비교하며 가장 큰 데이터를 가장 뒤로 보내며 정렬하는 방식</span><br><span class="line">function BubbleSort(arr) &#123;</span><br><span class="line">  let len = arr.length;</span><br><span class="line">  for(let outer = len; outer &gt; 1; outer--) &#123;</span><br><span class="line">    for(let inner = 0; inner &lt; outer; inner++) &#123;</span><br><span class="line">      if( arr[inner] &gt; arr[inner + 1]) &#123;</span><br><span class="line">        swap(arr, inner, inner+1);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return arr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>위 코드의 시간복잡도를 계산하면 T(n) = n^2 이다. 이것을 Big-O 표기법으로 나타내면 O(n^2)이다. 앞에서부터 한 개씩 뒤로 가면서 전체 배열 데이터를 돌기 때문에 n^2 만큼 시간이 걸린다.</p>
<p><br></p>
<h2 id="선택-정렬-알고리즘-Selection-Sort"><a href="#선택-정렬-알고리즘-Selection-Sort" class="headerlink" title="선택 정렬 알고리즘(Selection Sort)"></a>선택 정렬 알고리즘(Selection Sort)</h2><hr>
<p><strong>선택 정렬 알고리즘</strong>: 데이터의 처음부터 끝까지 쭉 훑어가면서 가장 작은 값을 찾아 그 값을 첫 번째 데이터와 자리를 바꾸고, 두 번째로 작은 데이터를 찾아 두 번째의 데이터와 자리를 바꾸는 방법으로 구현하는 정렬 알고리즘이다.</p>
<p>예를 들어, [3, 5, 4, 2, 1] 배열이 있으면, 변수 min = 3으로 할당하고, 그 다음 데이터인 5부터 하나씩 비교해 나간다. 이때, 가장 작은 값이 1 이므로 맨 앞에 있는 3과 1을 바꾼다. 그리고, 다시 두번째 요소인 5부터 오른쪽으로 하나씩 비교하면서 가장 작은 값을 찾아 5와 바꾼다. 이런식으로 정렬하는 방식이 선택 정렬 알고리즘이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 스왑 헬퍼 =&gt; 배열의 위치를 바꾼다.</span><br><span class="line">function swap(arr, index1, index2) &#123;</span><br><span class="line">  let temp = arr[index1];</span><br><span class="line">  arr[index1] = arr[index2];</span><br><span class="line">  arr[index2] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 선택 정렬은 정렬되지 않은 데이터들에 대해 가장 작은 데이터를 찾아 가장 앞의 데이터와 교환해나가는 방식</span><br><span class="line">function SelectionSort(arr) &#123;</span><br><span class="line">  let min;</span><br><span class="line">  for(let outer = 0; outer &lt; arr.length -1; ++outer) &#123;</span><br><span class="line">    min = outer;</span><br><span class="line">    for(let inner = outer + 1; inner &lt; arr.length; ++inner) &#123;</span><br><span class="line">      if( arr[inner] &lt; arr[min] ) &#123;</span><br><span class="line">        min = inner;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    swap(arr, outer, min);</span><br><span class="line">  &#125;</span><br><span class="line">  return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위 코드의 시간복잡도를 계산하면 T(n) = n^2 이다. 이것을 Big-O 표기법으로 나타내면 O(n^2)이다. 앞에서도 한칸씩 가면서 갈때마다 각 배열 요소를 한번씩 다시 돌기 때문에, n^2 만큼 시간이 걸린다.</p>
<p><br></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Computer-Science/">Computer Science</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/sort-algorithms/">sort algorithms</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-search-algorithms"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/10/31/search-algorithms/">탐색(search) 알고리즘</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/10/31/search-algorithms/" class="article-date">
	  <time datetime="2018-10-31T02:54:03.000Z" itemprop="datePublished">October 31, 2018</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Computer-Science/">Computer Science</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="탐색-알고리즘"><a href="#탐색-알고리즘" class="headerlink" title="탐색 알고리즘"></a>탐색 알고리즘</h1><hr>
<p>탐색 알고리즘이란, 데이터를 탐색하면서 어떤 값을 찾는 알고리즘을 말한다.</p>
<p><br></p>
<h1 id="탐색-알고리즘-종류"><a href="#탐색-알고리즘-종류" class="headerlink" title="탐색 알고리즘 종류"></a>탐색 알고리즘 종류</h1><hr>
<ul>
<li>순차 탐색 알고리즘(linear search)</li>
<li>이진 탐색 알고리즘(binary search)</li>
</ul>
<p><br></p>
<h2 id="순차-탐색-알고리즘-linear-search"><a href="#순차-탐색-알고리즘-linear-search" class="headerlink" title="순차 탐색 알고리즘(linear search)"></a>순차 탐색 알고리즘(linear search)</h2><hr>
<p>순차 탐색 알고리즘: 맨 앞에서부터 순서대로 탐색을 진행하는 알고리즘<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">  if(array[i] === target)</span><br><span class="line">	  return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>위 for문의 경우, 데이터의 수가 n개 일때, 최악의 경우에 해당하는 연산횟수는 n이다. T(n) = n, 시간복잡도는 O(n)이다.</p>
<p><br></p>
<h2 id="이진-탐색-알고리즘-binary-search"><a href="#이진-탐색-알고리즘-binary-search" class="headerlink" title="이진 탐색 알고리즘(binary search)"></a>이진 탐색 알고리즘(binary search)</h2><hr>
<p>이진 탐색 알고리즘: 데이터가 정렬된 상태에서, 모든 데이터의 중간부터 시작해서 크기 비교를 통해 반씩 쪼개면서 탐색하는 알고리즘이다. 즉, 배열에 저장된 데이터는 정렬되어야 할 수 있는 탐색 알고리즘이다.</p>
<ul>
<li>예를 들어, array = [1, 2, 3, 4, 5, 6, 7, 8, 9]라는 배열이 있다고 해보자.</li>
<li>이 중에서 데이터 ‘6’(key 값)을 찾는다고 하면, 먼저 배열의 중간인 5와 비교한다.</li>
<li>이때, key 값이 더 크기 때문에 key 값은 중간값인 5를 기준으로 배열에서 오른쪽에 있다는 뜻이다.</li>
<li>그럼 다시 오른쪽 데이터(6, 7, 8, 9) 중에서 중간값 7를 찾아서 key 값과 비교한다.</li>
<li>이때, key 값이 더 작기 때문에 key 값은 중간값인 7보다 앞쪽에 있다는 뜻이다.</li>
<li>결국 key 값 6을 찾을 수 있게 된다.</li>
</ul>
<p>이렇게 한번 처리가 진행될 때마다, 검색해야 하는 데이터의 양이 절반씩 떨어지는 알고리즘을 이진 탐색 알고리즘이라고 한다. 이를, 시간 복잡도로 나타내면 O(logN)이다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const findAge = (num, array) =&gt; &#123;</span><br><span class="line">  const midPoint = Math.floor(array.length/2); // 2</span><br><span class="line">  if(array[midPoint] === num) &#123;</span><br><span class="line">    return true; // 1번 실행</span><br><span class="line">  &#125;</span><br><span class="line">  if(array[midPoint] &lt; num) &#123;</span><br><span class="line">    for (let i = midPoint + 1; i &lt; array.length;) &#123;</span><br><span class="line">      if(array[i] === num) &#123;</span><br><span class="line">        return true;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    for (let i = 0; i &lt; midPoint;) &#123;</span><br><span class="line">      if(array[i] === num) &#123;</span><br><span class="line">        return true;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const sortedAges = [21, 23, 25, 27, 29];</span><br><span class="line">console.log(findAge(27, sortedAges)) // true</span><br></pre></td></tr></table></figure></p>
<p>위 코드의 시간복잡도를 계산하면 T(n) = 1 + n/2 이다. 이것을 Big-O 표기법으로 나타내면 O(logn)이다.</p>
<p><br></p>
<p>재귀함수를 이용하면 다음과 같이 작성할 수도 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const binarySearch = (numArray, key) =&gt; &#123;</span><br><span class="line">  const middleIdx = Math.floor(numArray.length / 2);</span><br><span class="line">  const middleElem = numArray[middleIdx];</span><br><span class="line"></span><br><span class="line">  if (middleElem === key) return true;</span><br><span class="line">  else if (middleElem &lt; key &amp;&amp; numArray.length &gt; 1) &#123;</span><br><span class="line">      return binarySearch(numArray.splice(middleIdx, numArray.length), key);</span><br><span class="line">  &#125;</span><br><span class="line">  else if (middleElem &gt; key &amp;&amp; numArray.length &gt; 1) &#123;</span><br><span class="line">      return binarySearch(numArray.splice(0, middleIdx), key);</span><br><span class="line">  &#125;</span><br><span class="line">  else return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(binarySearch([21, 23, 25, 27, 29], 27)); // true</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Computer-Science/">Computer Science</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/search-algorithms/">search algorithms</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-fibonacci"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/10/31/fibonacci/">3. Fibonacci</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/10/31/fibonacci/" class="article-date">
	  <time datetime="2018-10-31T01:53:41.000Z" itemprop="datePublished">October 31, 2018</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Algorithms/">Algorithms</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="What-is-Fibonacci"><a href="#What-is-Fibonacci" class="headerlink" title="What is Fibonacci?"></a><h3>What is Fibonacci?</h3></h2><p>Fibonacci 수열이란, 다음 수는 앞의 두 수의 합으로 이루어진 수열을 말한다.<br>규칙에 따라 수를 나열해 보면, 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144…와 같은 수열이 된다.</p>
<p><br></p>
<h2 id="Problem"><a href="#Problem" class="headerlink" title="[Problem]"></a><h3>[Problem]</h3></h2><p>피보나치 수는 F(0) = 0, F(1) = 1일 때, 2 이상의 n에 대하여 F(n) = F(n-1) + F(n-2) 가 적용되는 점화식입니다.<br>2 이상의 n이 입력되었을 때, fibonacci 함수를 제작하여 n번째 피보나치 수를 반환해 주세요.<br>예를 들어 n = 3이라면 2를 반환해주면 됩니다. 즉, 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144…에서 3번째 피보나치의 수는 2이다.</p>
<p><br></p>
<h2 id="Algorithms"><a href="#Algorithms" class="headerlink" title="[Algorithms]"></a><h3>[Algorithms]</h3></h2><ol>
<li>n이 0일 경우, 0을 리턴하고, 1일 경우, 1을 리턴한다.(피보나치 수열에서 0번째는 0, 1번째는 1이기 때문이다.)</li>
<li>n이 2이상일 경우, 앞의 두 수의 합으로 계산되는 재귀 호출을 사용하여 구현한다.</li>
<li>함수에서 n이라는 정수를 받을 것이고, n은 몇 번째 피보나치 수를 구할 것인지를 의미한다. 예를 들어, n이 3이면, 피보나치 수열 중 3번째 피보나치 수를 구하는 함수를 구현하는 것이고, 그 값은 2이다.</li>
</ol>
<p><br></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="[Solution]"></a><h3>[Solution]</h3></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function fibonacci(num)&#123;</span><br><span class="line">  var a = 1, b = 0, temp;</span><br><span class="line"></span><br><span class="line">  while (num &gt;= 0)&#123;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = a + b;</span><br><span class="line">    b = temp;</span><br><span class="line">    num--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="Best-Practice"><a href="#Best-Practice" class="headerlink" title="[Best Practice]"></a><h3>[Best Practice]</h3></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function fibonacci(num) &#123;</span><br><span class="line">  if(num === 0) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125; else if(num === 1) &#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return fibonacci(num - 1) + fibonacci(num - 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Algorithms/">Algorithms</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Fibonacci/">Fibonacci</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-pass-by-value-and-pass-by-reference"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/09/14/pass-by-value-and-pass-by-reference/">Pass-by-Value vs Pass-by-Reference</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/09/14/pass-by-value-and-pass-by-reference/" class="article-date">
	  <time datetime="2018-09-14T03:28:23.000Z" itemprop="datePublished">September 14, 2018</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Javascript/">Javascript</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Pass-by-Value"><a href="#Pass-by-Value" class="headerlink" title="Pass-by-Value"></a>Pass-by-Value</h1><hr>
<ul>
<li>기본자료형의 값은 값(Value)으로 전달한다.(원래 값은 그대로 존재하고, 그 값이 복사되어 전달된다.)</li>
<li>기본자료형의 값은 한번 정해지면 변경할 수 없다.(Immutable, 재할당은 가능하지만 기존의 값은 메모리에 저장되어 있다.)</li>
<li>기본자료형의 값은 런타임(변수 할당 시점)에 메모리의 스택 영역(Stack Segment)에 고정된 메모리 영역을 점유하고 저장된다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">var b = a; // a의 값(1)이 복사되어 전달</span><br><span class="line"></span><br><span class="line">console.log(a, b);    // 1  1</span><br><span class="line">console.log(a === b); // true</span><br><span class="line"></span><br><span class="line">a = 10; // 재할당은 가능하지만, 기존의 값은 메모리에 저장되어 있다.</span><br><span class="line">console.log(a, b);    // 10  1</span><br><span class="line">console.log(a === b); // false</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="Pass-by-Reference"><a href="#Pass-by-Reference" class="headerlink" title="Pass-by-Reference"></a>Pass-by-Reference</h1><hr>
<ul>
<li>객체형의 값은 실제 값이 아닌 값을 참조하여 전달한다.(값의 주소(address)를 참조한다.)</li>
<li>객체형은 변경 가능(mutable)한 값으로, 프로퍼티를 변경, 추가, 삭제가 가능하다.</li>
<li>객체형의 값은 동적으로 변화할 수 있어서 어느 정도의 메모리 공간이 필요한지를 알 수가 없기 때문에, 런타임(변수 할당 시점)에 메모리 공간을 확보하고, 메모리의 힙 영역(Heap Segment)에 저장된다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123; val: 100 &#125;</span><br><span class="line"></span><br><span class="line">var obj2 = obj1; // 값을 참조하여 전달</span><br><span class="line">console.log(obj1.val, obj2.val); // 100 100</span><br><span class="line">console.log(obj1 === obj2);      // true</span><br><span class="line"></span><br><span class="line">obj2.val = 200; // 객체의 값은 변경 가능</span><br><span class="line">console.log(obj1.val, obj2.val); // 200 200</span><br><span class="line">console.log(obj1 === obj2);      // true</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="두-변수사이에-같은-내용을-할당하여도-각-별개의-객체를-생성하여-서로-다른-참조값을-가진다"><a href="#두-변수사이에-같은-내용을-할당하여도-각-별개의-객체를-생성하여-서로-다른-참조값을-가진다" class="headerlink" title="두 변수사이에 같은 내용을 할당하여도, 각 별개의 객체를 생성하여, 서로 다른 참조값을 가진다."></a>두 변수사이에 같은 내용을 할당하여도, 각 별개의 객체를 생성하여, 서로 다른 참조값을 가진다.</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123; val: 100 &#125;;</span><br><span class="line">var obj2 = &#123; val: 100 &#125;;</span><br><span class="line"></span><br><span class="line">console.log(obj1.val, obj2.val); // 100 100</span><br><span class="line">console.log(obj1 === obj2);      // false -&gt; 서로 다른 참조값을 가지기 때문에, 두 변수는 같지 않다.</span><br><span class="line"></span><br><span class="line">var obj3 = obj2;</span><br><span class="line"></span><br><span class="line">console.log(obj3.val, obj2.val); // 100 100</span><br><span class="line">console.log(obj3 === obj2);      // true -&gt; 서로 같은 참조값을 가지기 때문에, 두 변수는 같다.</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="서로-다른-빈-객체-참조-및-모두-같은-빈-객체-참조-예제"><a href="#서로-다른-빈-객체-참조-및-모두-같은-빈-객체-참조-예제" class="headerlink" title="서로 다른 빈 객체 참조 및 모두 같은 빈 객체 참조(예제)"></a>서로 다른 빈 객체 참조 및 모두 같은 빈 객체 참조(예제)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// a, b, c는 각각 다른 빈 객체를 참조</span><br><span class="line">var a = &#123;&#125;;</span><br><span class="line">var b = &#123;&#125;;</span><br><span class="line">var c = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">console.log(a === b, a === c, b === c); // false false false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// a, b, c는 모두 같은 빈 객체를 참조</span><br><span class="line">a = b = c = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">console.log(a === b, a === c, b === c); // true true true</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Javascript/">Javascript</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Object/">Object</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-complexity-for-algorithms"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/09/14/complexity-for-algorithms/">알고리즘 성능분석을 위한 복잡도 활용법</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/09/14/complexity-for-algorithms/" class="article-date">
	  <time datetime="2018-09-14T02:55:28.000Z" itemprop="datePublished">September 14, 2018</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Computer-Science/">Computer Science</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="알고리즘"><a href="#알고리즘" class="headerlink" title="알고리즘"></a>알고리즘</h1><hr>
<p><strong>알고리즘</strong>이란, <strong>어떤 목적이나 결과물(프로그램)을 만들어내기 위해 거쳐야 하는 일련의 과정들을 말한다.</strong> 어떤 프로그램을 만드는 데 있어서 방법은 여러가지가 있을 수 있다. 예를 들어, 어떤 케익 1개를 100가지 방법으로 자를 수 있는 것처럼, 하나의 문제를 여러가지의 알고리즘으로 풀 수 있다. 그렇기 때문에, 여러 알고리즘 중 최선의 알고리즘으로 하는 것이 좋다.</p>
<p>어떤 프로그램 개발을 위해 코딩을 할 때, 여러가지의 알고리즘으로 풀 수 있지만, 최선의 알고리즘으로 푸는 것이 (웹페이지 등의) 성능을 위해서 좋다. 이때, 이 성능 분석을 위해 필요한 것이 복잡도이다.</p>
<p><br></p>
<h1 id="복잡도"><a href="#복잡도" class="headerlink" title="복잡도"></a>복잡도</h1><hr>
<p>복잡도에는 크게 2가지가 있다.</p>
<ul>
<li><strong>시간 복잡도</strong>: 알고리즘이 문제를 해결하기 위한 연산의 횟수(얼마나 많은 연산이 수행되는지)</li>
<li><strong>공간 복잡도</strong>: 메모리 사용량(얼마나 많은 양의 메모리를 차지하는지)</li>
</ul>
<p>이런 복잡도를 가지고 작성한 코드 알고리즘의 성능을 분석해서, 어떻게 하면 더 적은 연산으로(시간 복잡도), 더 적은 메모리를 차지하여(공간 복잡도) (웹페이지 등의) 성능을 좋게 할 수 있다.</p>
<p>알고리즘의 성능을 평가하기 위해서는 작성된 코드의 시간복잡도 및 공간복잡도를 계산하고, 이를 점근적 표기법으로 나타내어 평가한다. 이때 점근적 표기법이란, 각 알고리즘이 주어진 데이터의 크기를 기준으로 코드에서의 연산의 횟수 또는 메모리 사용량이 얼마나 되는지를 비교할 수 있는 방법이다. 이 방법에는 Big-O, 오메가, 세타 등이 있다.</p>
<p>이 방법중에서 Big-O 표기법에 대해 알아보자.</p>
<p><br></p>
<h1 id="Big-O-표기법"><a href="#Big-O-표기법" class="headerlink" title="Big-O 표기법"></a>Big-O 표기법</h1><hr>
<p><strong>Big-O 표기법</strong>이란, <strong>계산된 복잡도를 O(n) 이런식으로 표기하는 방식인데, 이때, n은 최고차항의 차수가 된다.</strong> 예를 들어, T(n) = n^2+ 2n + 1 으로 시간복잡도가 계산되었다면, O(n^2)으로 표기하는 것이 Big-O 표기법이다.</p>
<p>대표적인 복잡도를 Big-O 표기법으로 작성한 것은 다음과 같다.</p>
<ul>
<li><strong>O(1): 상수 시간</strong><ul>
<li>입력값 n이 주어졌을 때, 알고리즘이 문제를 해결하는 데 오직 한 단계만 거친다.</li>
</ul>
</li>
<li><strong>O(logn): 로그 시간</strong><ul>
<li>입력값 n이 주어졌을 때, 문제를 해결하는데 필요한 단계들이 연산마다 특정 요인에 의해 줄어든다.</li>
</ul>
</li>
<li><strong>O(n): 직선적 시간</strong><ul>
<li>문제를 해결하기 위한 단계의 수와 입력값 n이 1:1 관계를 가진다.</li>
</ul>
</li>
<li><strong>O(n^2): 2차 시간</strong><ul>
<li>문제를 해결하기 위한 단계의 수는 입력값 n의 제곱이다.</li>
</ul>
</li>
<li><strong>O(c^n): 지수 시간</strong><ul>
<li>문제를 해결하기 위한 단계의 수는 주어진 상수값 c의 n 제곱이다.</li>
</ul>
</li>
</ul>
<p>복잡도의 크기는 다음과 같다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!)</span><br></pre></td></tr></table></figure></p>
<p>보통 O(n^2) 이상의 복잡도를 가지는 알고리즘은 좋지 않다.</p>
<p><br></p>
<h1 id="복잡도-계산하기"><a href="#복잡도-계산하기" class="headerlink" title="복잡도 계산하기"></a>복잡도 계산하기</h1><hr>
<h2 id="O-1-상수-시간-constant-time"><a href="#O-1-상수-시간-constant-time" class="headerlink" title="O(1): 상수 시간(constant time)"></a>O(1): 상수 시간(constant time)</h2><hr>
<p><strong>알고리즘이 문제를 해결하는 데 오직 한 단계만 거친다.</strong></p>
<p>O(1)은 여러가지 경우가 있겠지만, 예를 들면 다음과 같은 코드들이 있다.</p>
<p><strong>1. 전달되는 인자를 반환하는 경우</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function addTwoNumbers(num1, num2) &#123;</span><br><span class="line">  return num1 + num2; // 1번 실행</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(addTwoNumbers(1, 3)); // 4</span><br></pre></td></tr></table></figure></p>
<p>시간복잡도를 T(n)이라고 하는데, 위 코드의 시간복잡도를 계산하면 T(n) = 1 이다. 이것을 Big-O 표기법으로 나타내면 O(1)이다. 1인 이유는 Big-O 표기법에서 O(n)의 n은 최고차항의 차수를 나타내는데, 위의 경우 n^0이므로, 1이된다.</p>
<p><br></p>
<p><strong>2. 정렬되어 있는 배열에서 최소값과 최대값을 구하는 경우</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const numbers = [1, 2, 3, 4, 5, 10]; // 배열의 요소들이 순서대로 정렬되어 있다.</span><br><span class="line">function FindLargestNumber(items) &#123;</span><br><span class="line">  let smallest = items[0]; // 1번 실행</span><br><span class="line">  let largest = items[items.length - 1]; // 1번 실행</span><br><span class="line">  return (largest - smallest); // 1번 실행</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(FindLargestNumber(numbers)); // 9</span><br></pre></td></tr></table></figure></p>
<p>위 코드의 시간복잡도를 계산하면 T(n) = 3 이다. 이것을 Big-O 표기법으로 나타내면 O(1)이다.</p>
<p><br></p>
<p><strong>3. 값을 검색할 때, 객체에서 키를 알거나, 배열에서 인덱스를 알고 있으면 언제나 한 단계만 걸린다.</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function isCryptoCurrency(name) &#123;</span><br><span class="line">  return cryptoCurrency[name]; // 1번 실행</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var cryptoCurrency = &#123;</span><br><span class="line">  &apos;bitcoin&apos;: true,</span><br><span class="line">  &apos;ripple&apos;: true,</span><br><span class="line">  &apos;bitcoinCash&apos;: true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(isCryptoCurrency(&apos;bitcoin&apos;)); // true</span><br></pre></td></tr></table></figure></p>
<p>위 코드의 시간복잡도를 계산하면 T(n) = 1 이다. 이것을 Big-O 표기법으로 나타내면 O(1)이다.</p>
<p><br></p>
<h2 id="O-logN-로그-시간-log-time"><a href="#O-logN-로그-시간-log-time" class="headerlink" title="O(logN): 로그 시간(log time)"></a>O(logN): 로그 시간(log time)</h2><hr>
<p><strong>문제를 해결하는데 필요한 단계들이 연산마다 특정 요인에 의해 줄어든다.</strong></p>
<p>배열에서 값을 찾을 때, 어느 쪽에서 시작할지를 알고 있으면, 검색하는 시간이 줄어든다. 대표적인 것이 이진 검색 알고리즘이다.(binary search)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function findAge(num, array) &#123;</span><br><span class="line">  var midPoint = Math.floor(array.length/2);</span><br><span class="line">  if(array[midPoint] === num) &#123;</span><br><span class="line">    return true; // 1번 실행</span><br><span class="line">  &#125;</span><br><span class="line">  if(array[midPoint] &lt; num) &#123;</span><br><span class="line">    for (let i = midPoint + 1; i &lt; array.length) &#123;</span><br><span class="line">      if(array[i] === num) &#123;</span><br><span class="line">        return true;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; n/2번 실행</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    for (let i = 0; i &lt; midPoint) &#123;</span><br><span class="line">      if(array[i] === num) &#123;</span><br><span class="line">        return true;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; n/2번 실행</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(findAge(27, sortedAges))</span><br><span class="line">sortedAges = [21, 23, 25, 27, 29];</span><br></pre></td></tr></table></figure></p>
<p>위 코드의 시간복잡도를 계산하면 T(n) = 1 + n/2 이다. 이것을 Big-O 표기법으로 나타내면 O(logn)이다.</p>
<p><br></p>
<h2 id="O-n-직선적-시간-linear-time"><a href="#O-n-직선적-시간-linear-time" class="headerlink" title="O(n): 직선적 시간(linear time)"></a>O(n): 직선적 시간(linear time)</h2><hr>
<p><strong>문제를 해결하기 위한 단계의 수와 입력값 n이 1:1 관계를 가진다.</strong></p>
<p>for문을 1번 사용하는 경우</p>
<p>예를 들어, 배열이 정렬되어 있지 않을 경우, 최소 및 최대값을 찾기 위해 배열의 모든 숫자를 탐색하여, 비교를 수행한다. 이 경우, 수행시간은 배열의 크기에 따라 늘어난다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const numbers = [1, 9, 3, 10, 16];</span><br><span class="line">function FindLargestGap(items) &#123;</span><br><span class="line">  let smallest = items[0]; // 1번 실행</span><br><span class="line">  let largest = items[0]; // 1번 실행</span><br><span class="line">  for (let i = 1; i &lt; items.length; i++) &#123;</span><br><span class="line">    if (items[i] &lt; smallest) &#123;</span><br><span class="line">      smallest = items[i];</span><br><span class="line">    &#125; else if (items[i] &gt; largest) &#123;</span><br><span class="line">      largest = items[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; // n번 실행</span><br><span class="line">  return (largest - smallest); // 1번 실행</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(FindLargestGap(numbers));</span><br></pre></td></tr></table></figure></p>
<p>위 코드의 시간복잡도를 계산하면 T(n) = 3 + n 이다. 이것을 Big-O 표기법으로 나타내면 O(n)이다.</p>
<p><br></p>
<h2 id="O-n-2-2차-시간-quadratic-time"><a href="#O-n-2-2차-시간-quadratic-time" class="headerlink" title="O(n^2): 2차 시간(quadratic time)"></a>O(n^2): 2차 시간(quadratic time)</h2><hr>
<p><strong>문제를 해결하기 위한 단계의 수는 입력값 n의 제곱이다.</strong></p>
<p>중첩 for 문을 사용할 경우, 첫번째 for 문의 각 요소(n) x 두번째(안에있는) for 문의 각 요소(n) = n x n<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const number = [2, 10, 1, 4, 3, 10, 5];</span><br><span class="line">function FindLargestGap(items) &#123;</span><br><span class="line">  let gap; // 1번 실행</span><br><span class="line">  let maxGap = 0; // 1번 실행</span><br><span class="line">  for (let i = 0; i &lt; items.length; i++) &#123;</span><br><span class="line">    for(let j = 0; j &lt; items.length; j++) &#123;</span><br><span class="line">      gap = items[i] - items[j];</span><br><span class="line">      if (gap &lt; 0) &#123;</span><br><span class="line">        gap = gap * -1;</span><br><span class="line">      &#125;</span><br><span class="line">      if (gap &gt; maxGap) &#123;</span><br><span class="line">        maxGap = gap;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; // n^2번 실행</span><br><span class="line">  return maxGap; // 1번 실행</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(FindLargestGap(numbers)); // 9</span><br></pre></td></tr></table></figure></p>
<p>위 코드의 시간복잡도를 계산하면 T(n) = 3 + n^2 이다. 이것을 Big-O 표기법으로 나타내면 O(n^2)이다.</p>
<p><br></p>
<h2 id="O-c-n-지수-시간-exponential-time"><a href="#O-c-n-지수-시간-exponential-time" class="headerlink" title="O(c^n): 지수 시간(exponential time)"></a>O(c^n): 지수 시간(exponential time)</h2><hr>
<p><strong>문제를 해결하기 위한 단계의 수는 주어진 상수값 c의 n 제곱이다.</strong></p>
<p>지수 시간은 문제를 풀기 위해, 모든 조합과 방법을 시도할 때 사용된다.</p>
<p>예를 들어, 2^n이 걸리는 피보나치 수열이 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function fibonacci(num) &#123;</span><br><span class="line">  if(num === 0) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125; else if(num === 1) &#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return fibonacci(num - 1) + fibonacci(num - 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>위 코드는 함수가 호출될 때마다, 앞의 두 수에 대한 함수를 호출하기 때문에, 두번씩 호출하게 된다.(구조는 트리로 되어 있다.) 위 코드의 시간복잡도를 계산하면 T(n) = 2^n 이다. 이것을 Big-O 표기법으로 나타내면 O(2^n)이다.</p>
<p><br></p>
<h1 id="Worst-Case-Best-Case-and-Average-Case"><a href="#Worst-Case-Best-Case-and-Average-Case" class="headerlink" title="Worst Case, Best Case, and Average Case"></a>Worst Case, Best Case, and Average Case</h1><hr>
<p>시간 복잡도 계산을 위한 연산 횟수를 카운팅할때, 3가지의 시나리오가 있다.</p>
<ul>
<li><strong>Worst Case</strong>: 입력값 n의 규모가 동일할 때, 가장 많은 횟수의 연산으로 처리되는 경우</li>
<li><strong>Best Case</strong>: 입력값 n의 규모가 동일할 때, 가장 적은 횟수의 연산으로 처리되는 경우</li>
<li><strong>Average Case</strong>: 입력값 n의 규모가 동일할 때, 평균적인 횟수의 연산으로 처리되는 경우</li>
</ul>
<p>예를 들면 다음과 같은 코드가 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function getNumber7(items) &#123;</span><br><span class="line">  for (let i = 0; i &lt; items.length; i++) &#123;</span><br><span class="line">    if (i === 7) &#123;</span><br><span class="line">      return i</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getNumber7(numbers)</span><br><span class="line"></span><br><span class="line">// numbers = [7, 5, 3, 1]인 경우, 1번만 실행(Best Case)</span><br><span class="line">// numbers = [5, 7, 3, 1]인 경우, 2번만 실행</span><br><span class="line">// numbers = [1, 3, 5, 7]인 경우, 4번 모두 실행(Worst Case)</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Computer-Science/">Computer Science</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithms/">Algorithms</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Big-O/">Big-O</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Complexity/">Complexity</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/5/">Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/7/">Next</a>
  </nav>

</section>
          <aside id="sidebar">
  
    <div style="margin: 20px 0;">
	<div id="search-form-wrap">

    <form class="search-form">
        <label style="width: 72%;">
            <span class="screen-reader-text">Search for:</span>
            <input type="search" class="search-field" style="height: 36px; width: 100%;" placeholder=" Search…" value="" name="s" title="Search for:">
        </label>
        <input type="submit" class="search-form-submit" value="Search">
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
</div>
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Connect With Us</h3>
    <div class="widget widget_athemes_social_icons">

    	<ul class="clearfix widget-social-icons">   
    	
   			<li><a href="https://github.com/cheonmro" title="Github"><i class="fa fa-github" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Weibo"><i class="fa fa-weibo" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Twitter"><i class="fa fa-twitter" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Facebook"><i class="fa fa-facebook" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Google-plus"><i class="fa fa-google-plus" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Instagram"><i class="fa fa-instagram" aria-hidden="true"></i></a></li> 

   		
   		</ul>


   		<!--
   		<ul class="clearfix widget-social-icons">   		
   		<li class="widget-si-twitter"><a href="http://twitter.com" title="Twitter"><i class="ico-twitter"></i></a></li> 
		<li class="widget-si-facebook"><a href="http://facebook.com" title="Facebook"><i class="ico-facebook"></i></a></li>
			<li class="widget-si-gplus"><a href="http://plus.google.com" title="Google+"><i class="ico-gplus"></i></a></li>
			<li class="widget-si-pinterest"><a href="http://pinterest.com" title="Pinterest"><i class="ico-pinterest"></i></a></li>
			<li class="widget-si-flickr"><a href="http://flickr.com" title="Flickr"><i class="ico-flickr"></i></a></li>
			<li class="widget-si-instagram"><a href="http://instagram.com" title="Instagram"><i class="ico-instagram"></i></a></li>
		</ul> -->

    </div>
  </div>


  
    
  <div class="widget_athemes_tabs">
    <ul id="widget-tab" class="clearfix widget-tab-nav">
      <li class="active"><a>Recent Posts</a></li>
    </ul>
    <div class="widget">
      <ul>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2019/04/02/ethereum-state-transition-model/">Ethereum State Transition Model(이더리움 상태 전이 모델)</a></h6>
              <span>April 2, 2019</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2019/03/30/icon-data/">ICON Data</a></h6>
              <span>March 30, 2019</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2019/03/22/icon-unit/">ICON Unit</a></h6>
              <span>March 22, 2019</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2019/03/17/redux-saga/">Redux-Saga</a></h6>
              <span>March 17, 2019</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2019/03/16/what-is-redux/">Redux</a></h6>
              <span>March 16, 2019</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2019/03/10/webworker/">Web Worker</a></h6>
              <span>March 10, 2019</span>
            </div>

          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/API/">API</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithms/">Algorithms</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Blockchain-Market/">Blockchain(Market)</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Blockchain-Tech/">Blockchain(Tech)</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Computer-Science/">Computer Science</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ES6/">ES6</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Ethereum/">Ethereum</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ICON/">ICON</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Javascript/">Javascript</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Network/">Network</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node-js/">Node.js</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/">Vue</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/typescript/">typescript</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>


  
</aside>
        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/about" class="mobile-nav-link">Me &amp; Projects</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2019 Hexo All Rights Reserved.
        
            <span id="busuanzi_container_site_uv">
              本站访客数<span id="busuanzi_value_site_uv"></span>人次  
              本站总访问量<span id="busuanzi_value_site_pv"></span>次
            </span>
          
      </div>
      <div class="site-credit">
        Theme by <a href="https://github.com/iTimeTraveler/hexo-theme-hipaper" target="_blank">hipaper</a>
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
    
</script>
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>


<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-125478847-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->






  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
</body>
</html>
